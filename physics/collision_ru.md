1. # Введение
    1. Обзор содержания
        1. Глава 2: Проблемы проектирования обнаружения столкновений
        2. Глава 3: Учебник по математике и геометрии
        3. Глава 4: Ограничивающие объёмы
        4. Глава 5: Базовые примитивные тесты
        5. Глава 6: Иерархии ограничивающих объемов
        6. Глава 7: Пространственное разбиение
        7. Глава 8: Иерархии деревьев BSP
        8. Глава 9: Основанные на выпуклости методы
        9. Глава 10: Обнаружение столкновений с помощью GPU
        10. Глава 11: Числовая устойчивость
        11. Глава 12: Геометрическая устойчивость
        12. Глава 13: Оптимизация
    2. О коде
2. # Вопросы проектирования обнаружения столкновений
    1. Факторы проектирования алгоритма коллизий
    2. Представление области приложения
        1. Представления объектов
        2. Столкновение против геометрии рендеринга
        3. Специализация алгоритмов столкновений
    3. Типы запросов
    4. Параметры моделирования окружающей среды
        1. Количество объектов
        2. Последовательное или одновременное движение
        3. Дискретное и непрерывное движение
    5. Производительность
        1. Обзор оптимизации
    6. Надежность
    7. Простота реализации и использования
        1. Отладка системы обнаружения столкновений
    8. Резюме
3. # Учебник по математике и геометрии
    1. Матрицы
        1. Матричная арифметика
        2. Алгебраические тождества с матрицами
        3. Детерминанты
        4. Решение малых систем линейных уравнений с помощью правила Крамера 
        5. Обращение матриц для матриц 2 × 2 и 3 × 3
        6. Детерминантные предикаты
            1. ORIENT2D(A, B, C )
            2. ORIENT3D(A, B, C, D)
            3. INCIRCLE2D(A, B, C, D)
            4. INSPHERE(A, B, C, D, E )
    2. Системы координат и точки
    3. Векторы
        1. Векторная арифметика
        2. Алгебраические тождества с векторами
        3. Скалярное произведение
        4. Алгебраические тождества скалярных произведений
        5. Векторное произведение
        6. Алгебраические тождества векторых произведений
        7. Тройное скалярное произведение
        8. Алгебраические тождества тройных скалярных произведений
    4. Барицентрические координаты
    5. Линии, лучи и сегменты
    6. Плоскости и полупространства
    7. Многоугольники
        1. Проверка многоугольной выпуклости
    8. Многогранники
        1. Проверка многогранной выпуклости
    9. Вычисление выпуклой оболочки
        1. Алгоритм Эндрю
        2. Алгоритм Quickhull
    10. Регионы Вороного
    11. Сумма Минковского и разность
    12. Резюме
4. # Ограничивающие объёмы 
    1. Желательные характеристики BV
    2. Выровненные по оси ограничительные параллелипипеды (Axis-aligned Bounding Boxes, AABBs)
        1. AABB-AABB пересечение
        2. Вычисления и обновления AABBs
        3. AABB из ограничивающей объект сферы
        4. AABB реконструирован из исходного набора точек
        5. AABB из восхождения к вершине представления объекта
        6. AABB пересчитан из повернутого AABB
    3. Сферы
        1. Сфера-сфера пересечения
        2. Вычисление ограничивающей сферы
        3. Ограничивающая сфера из направления максимального распространения
        4. Ограничивающая сфера посредством итеративного уточнения
        5. Минимальная ограничивающая сфера
    4. Ориентированные ограничивающие параллелипипеды (Oriented Bounding Boxes, OBBs)
        1. OBB-OBB пересечение
        2. Повышение надежности теста разделительной оси
        3. Вычисление жесткого OBB
        4. Оптимизация OBB на основе PCA
        5. Установка OBB методом перебора
    5. Ометаемые сферой объёмы
        1. Пересечение ометаемых сферой объемов
        2. Вычисление ометаемых сферой ограничивающих объемов
    6. Объемы пересечения полупространства
        1. Kay–Kajiya объемы на основе плит (Slab)
        2. Дискретно-ориентированные многогранники (Discrete-orientation Polytopes, k-DOPs)
        3. Тест на пересечение k-DOP – k-DOP
        4. Вычисление и настройка k-DOP
        5. Приблизительные тесты на пересечение выпуклой оболочки
    7. Другие ограничивающие объемы
    8. Резюме
5. # Базовые примитивные тесты
    1. Вычисления ближайших точек
        1. Ближайшая точка на плоскости к точке
        2. Ближайшая точка на отрезке линии к точке
            1. Расстояние от точки до сегмента
        3. Ближайшая точка на AABB к точке
            1. Расстояние от точки до AABB
        4. Ближайшая точка OBB к точке
            1. Расстояние от точки до OBB
            2. Ближайшая точка на 3D-прямоугольнике к точке
        5. Ближайшая точка на Треугольнике к Точке
        6. Ближайшая точка на Тетраэдре к Точке
        7. Ближайшая точка Выпуклого многогранника к Точке
        8. Ближайшие точки двух Линий
        9. Ближайшие точки двух линейных участков
            1. 2D Пересечение Сегментов
        10. Ближайшие точки Отрезка линии и Треугольника
        11. Ближайшие точки двух Треугольников
    2. Тестирование пересечения примитивов
        1. Тест разделяющей оси
            1. Устойчивость теста разделяющей оси
        2. Тестирование пересечения Сферы и Плоскости
        3. Тестирование пересечения Параллелипипеда и Плоскости
        4. Тестирование пересечения Конуса и Плоскости
        5. Тестирование пересечения Сферы и AABB
        6. Тестирование пересечения Сферы и OBB
        7. Тестирование пересечения Сферы и Треугольника
        8. Тестирование пересечения Сферы и Многоугольника
        9. Тестирование пересечения AABB и Треугольника
        10. Тестирование пересечения Треугольника и Треугольника
    3. Пересекающиеся линии, лучи и (направленные) сегменты
        1. Пересекающиеся Сегмент и Плоскость
        2. Пересекающиеся Луч или Сегмент и Сфера
        3. Пересекающиеся Луч или Сегмент и Параллелипипед
        4. Пересекающиеся Линия и Треугольник
        5. Пересекающиеся Линия и Четырехугольник
        6. Пересекающиеся Луч или Сегмент и Треугольник
        7. Пересекающиеся Луч или Сегмент и Цилиндр
        8. Пересекающиеся Луч или Сегмент и Выпуклый многогранник
    4. Дополнительные тесты
        1. Тестирование Точки в многоугольнике
        2. Тестирование Точки в Треугольнике
        3. Тестирование Точки в Многограннике
        4. Пересечение двух Плоскостей
        5. Пересечение трех Плоскостей
    5. Тест динамических пересечений
        1. Уменьшение вдвое интервала пересечения движущихся объектов
        2. Тест разделяющей оси для движущихся выпуклых объектов
        3. Пересечение движущейся Сферы относительно Плоскости
        4. Пересечение движущихся AABB относительно Плоскости
        5. Пересечение движущейся Сферы относительно Сферы
        6. Пересечение движущейся сферы относительно треугольника (и многоугольника)
        7. Пересечение движущейся сферы относительно AABB
        8. Пересечение движущегося AABB относительно AABB
    6. Резюме
6. # Иерархии ограничивающих объемов
    1. Вопросы проектирования иерархии
        1. Желаемые характеристики BVH
        2. Функции стоимости
        3. Степень дерева
    2. Стратегии построения иерархии конструкций
        1. Построение сверху вниз
            1. Стратегии разбиения
            2. Выбор оси разделения
            3. Выбор точки разделения
        2. Построение снизу вверх
            1. Улучшенная конструкция снизу вверх
            2. Другие стратегии строительства снизу вверх
            3. Снизу вверх n-арные деревья кластеризации
        3. Инкрементальная (вставная) конструкция
            1. Метод инкрементной конструкции Goldsmith–Salmon
    3. Обход иерархии
        1. Правила спуска
        2. Общий информированный обход в глубину
        3. Одновременный обход в глубину
        4. Оптимизированный переход по листу в глубину
    4. Пример иерархии ограничивающих объемов
        1. OBB Деревья
        2. Деревья AABB и BoxTrees
        3. Дерево Сферы через Octree Подразделение
        4. Дерево Сферы с покрытых сферой поверхностей
        5. Покрытие сферы генерации и сокращения
        6. k-dop Деревья
    5. Объединение ограничивающих объемов
        1. Слияние двух AABB
        2. Слияние двух сфер
        3. Слияние двух OBB
        4. Слияние двух k-DOP
    6. Эффективное представление дерева и обход
        1. Представление массива
        2. Порядок обхода предзаказа
        3. Смещения вместо указателей
        4. Структуры, удобные для кеширования (Недвоичные деревья)
        5. Узел дерева и порядок примитивов
        6. О рекурсии
        7. Группировка запросов
    7. Улучшенные запросы через кеширование
        1. Кэширование поверхности: кеширование пересекающихся примитивов
        2. Переднее отслеживание
    8. Резюме
7. # Пространственное разбиение
    1. Равномерная сетка
        1. Проблемы с размером ячейки
        2. Сетки как массивы связанных списков
        3. Хешированное хранилище и бесконечные сети
        4. Хранение статических данных
        5. Неявные сетки
        6. Объектно-объектный тест Равномерной сетки
            1. Один тест за раз
            2. Все тесты одновременно
        7. Дополнительные соображения по сетке
    2. Иерархические сетки
        1. Базовая реализация Hgrid
        2. Альтернативные иерархические сеточные представления
        3. Другие иерархические сетки
    3. Деревья
        1. Октодеревья (и Квадродеревья)
        2. Назначение объекта Октодерева
        3. Коды местоположения и поиск октанта для точки
        4. Линейные октодеревья (на основе хэша)
        5. Вычисление ключа Мортона
        6. Свободные октодеревья
        7. k-d Деревья
        8. Гибридные схемы
    4. Обход лучей и отрезков направленных линий
        1. k-d Тест на пересечение деревьев
        2. Тест на пересечение Равномерной сетки
    5. Методы сортировки и поиска
        1. Реализация отсортированного связного списка
        2. Сортировка по массивам
    6. Ячейки и порталы
    7. Избегание повторного тестирования
        1. Битовые флаги
        2. Штамп времени
        3. Амортизированная очистка штампов времени
    8. Резюме
8. # Иерархии деревьев BSP
    1. BSP Деревья
    2. Типы BSP-деревьев
        1. BSP-деревья с хранением узлов
        2. Деревья BSP с хранением Листов
        3. Деревья BSP с твердыми листьями
    3. Построение BSP-дерева
        1. Выбор разделяющих плоскостей
        2. Оценка разделяющих плоскостей
        3. Классификация полигонов по плоскости
        4. Разбиение полигонов на плоскости
        5. Подробнее об устойчивости к разбиению полигонов
        6. Настройка производительности дерева BSP
    4. Использование BSP Дерева
        1. Проверка точки на BSP-дереве с твердыми листьями
        2. Пересечение луча с твердолистным деревом BSP
        3. Многогранники на деревьях BSP с твердыми листьями
    5. Резюме
9. # Основанные на выпуклости методы
    1. Обнаружение столкновений на основе границ
    2. Алгоритмы с Ближайшими особенностями
        1. Алгоритм V-Clip
    3. Иерархические представления многогранников
        1. Иерархия Добкина–Киркпатрика
    4. Линейное и квадратичное программирование
        1. Линейное программирование
            1. Устранение Фурье–Моцкина
            2. Алгоритм Зейделя
        2. Квадратичное программирование
    5. Алгоритм Гилберта–Джонсона–Кирти
        1. Алгоритм Гилберта–Джонсона–Кирти
        2. Нахождение точки минимальной нормы в симплексе
        3. GJK, Ближайшие точки и контактные многообразия
        4. Восхождение на холм для экстремальных вершин
        5. Использование когерентности с помощью кэширования вершин
        6. Оптимизация вращающихся объектов
        7. GJK для движущихся объектов
    6. Алгоритм разделяющих векторов Чанга–Ванга
    7. Резюме
10. # Обнаружение столкновений с помощью GPU
    1. Взаимодействие с графическим процессором
        1. Считывание буфера
        2. Запросы окклюзии
    2. Тестирование выпуклых объектов
    3. Тестирование вогнутых объектов
    4. Фильтрация столкновений на основе графического процессора
    5. Резюме
11. # Числовая устойчивость
    1. Типы проблем устойчивости
    2. Представление действительных чисел
        1. Форматы с плавающей запятой IEEE-754
        2. Бесконечная арифметика
        3. Источники ошибок с плавающей точкой
    3. Надежное использование чисел с плавающей запятой
        1. Сравнение допусков для значений с плавающей запятой
        2. Надежность за счет толстых плоскостей
        3. Надежность за счет совместного использования расчетов
        4. Надежность толстых предметов
    4. Интервальная арифметика
        1. Примеры интервальной арифметики
        2. Интервальная арифметика при обнаружении столкновений
    5. Точные и полуточные вычисления
        1. Точная арифметика с использованием целых чисел
        2. Целочисленное деление
        3. Пересечение сегментов с использованием целочисленной арифметики
    6. Дальнейшие предложения по повышению надежности
    7. Резюме
12. # Геометрическая устойчивость
    1. Вершинная сварка
    2. Вычисление информации о смежности
        1. Вычисление таблицы Vertex-to-Face
        2. Вычисление таблицы Edge-to-Face
        3. Проверка связности
    3. Дыры, Трещины, Зазоры и Т-образные переходы 
    4. Объединение копланарных граней
        1. Проверка копланарности двух многоугольников
        2. Проверка плоскостности многоугольника
    5. Триангуляция и выпуклое разбиение
        1. Триангуляция путем разрезания ушей [1](https://ru.wikipedia.org/wiki/Задача_о_триангуляции_многоугольника#Отрезание_ушей)
            1. Триангуляция многоугольников с отверстиями
        2. Выпуклая декомпозиция многоугольников
        3. Выпуклое разложение многогранников
        4. Работа с «неразложимой» вогнутой геометрией
    6. Проверка непротиворечивости с использованием формулы Эйлера
    7. Резюме
13. # Оптимизация
    1. Кеши процессора
    2. Оптимизация кэша инструкций
    3. Оптимизация кэша данных
        1. Оптимизация структуры
        2. Квантованные и сжатые данные вершин
        3. Предварительная загрузка
    4. Структуры данных и алгоритмы с учетом кеширования
        1. Компактное статическое k-d дерево
        2. Компактное дерево AABB
        3. Кеширование забывчивости
    5. Программное кеширование
        1. Пример кэшированной линеаризации
        2. Амортизированное кэширование с предсказательной линеаризацией
    6. Сглаживание
        1. Анализ псевдонимов на основе типов
        2. Ограниченные указатели
        3. Избегание сглаживаний
    7. Параллелизм благодаря оптимизации SIMD
        1. SIMD-тест «Четыре сферы против четырех сфер»
        2. SIMD-тест «Четыре сферы против четырех AABB»
        3. SIMD-тест «Четыре AABB  против четырех AABB»
    8. Ветвление
    9. Резюме
14. Рекомендации
15. Индекс
16. О коде


# Введение

Это произведение посвящено теме обнаружения столкновений, широкой теме, связанной с, казалось бы, простой проблемой: обнаружение пересечения двух (или более) объектов. Обнаружение столкновений касается проблем определения того, **есть ли* соприкосновение, *когда* и *где* двух объектов. *“Есть ли”* включает установление логического результата, ответ на вопрос, пересекаются ли объекты. *“Когда”* дополнительно необходимо определить, в какое время во время движения произошло столкновение. *“Где”* устанавливает, как предметы входят в контакт. Грубо говоря, на эти три типа запросов становится все сложнее отвечать в указанном порядке. Сбор информации о том, когда и где (в дополнение к логическому результату обнаружения столкновения) иногда обозначается как *«обнаружение столкновения»*. Термины *«обнаружение пересечения»* и *«обнаружение помех»* иногда используются как синонимы «обнаружение столкновения».

Обнаружение столкновений является фундаментальным для многих разнообразных приложений, включая компьютерные игры, физическое моделирование (например, компьютерную анимацию), робототехнику, виртуальное прототипирование и инженерное моделирование (и это лишь некоторые из них). В компьютерных играх обнаружение столкновений гарантирует сохранение иллюзии твердого мира. Он не дает персонажам игроков проходить сквозь стены или проваливаться через пол; он обеспечивает запросы о прямой видимости, сообщая противникам, видят ли они игрока и, следовательно, могут ли они атаковать; и он удерживает скейтбордиста прикрепленным к невидимой направляющей поверхности, гарантируя, что игрок безопасно вернется в хафпайп после того, как поднялся в воздух.

В компьютерной анимации обнаружение столкновений используется, например, для ограничения физической симуляции ткани, чтобы одежда выглядела реалистично и не соскальзывала с персонажа при его движении. Обнаружение столкновений используется для планирования пути в робототехнике, помогая роботам избегать препятствий. В виртуальном прототипировании обнаружение столкновений помогает вычислить зазоры и в целом позволяет дорабатывать прототипы без создания физических моделей. Обнаружение столкновений используется в краш-тестах и другом инженерном моделировании.

Некоторые приложения, такие как планирование пути и рендеринг анимации, не требуют работы их систем столкновения в реальном времени. Другие приложения, в частности компьютерные игры, предъявляют особые требования к эффективности систем обнаружения столкновений в реальном времени. Экшн-игры для компьютеров и консолей включают моделирование, требующее выполнения большого количества запросов с частотой кадров от 30 до 60 кадров в секунду (fps). С такими жесткими временными ограничениями и с обнаружением столкновений, являющимся неотъемлемой частью игровых и физических движков, обнаружение столкновений может составлять большую часть времени, необходимого для создания игрового кадра. В компьютерных играх плохо спроектированная система столкновений может легко стать ключевым узким местом.

Это произведение не только об обнаружении коллизий в целом, но и конкретно об эффективной реализации структур данных и алгоритмов для решения проблем обнаружения коллизий в приложениях реального времени. В то время как область игр часто используется в качестве примеров, некоторые неигровые приложения имеют требования к производительности, аналогичные (или даже превышающие) требования к играм, включая системы тактильной (силовой обратной связи), симуляции частиц, хирургические симуляторы и другие симуляции виртуальной реальности. Описанные здесь методы одинаково хорошо применимы к этим приложениям.

Многие из обсуждаемых здесь методов применимы к областям, отличным от обнаружения столкновений. Например, методы, обсуждаемые в главах с 6 по 8, могут использоваться для ускорения трассировки лучей и их преобразования (например, для вычисления освещения сцены), а также в отношении географических информационных систем (ГИС) для ответа на запросы в больших географических базах данных. Некоторые проблемы из области компьютерной графики могут быть решены как проблемы обнаружения столкновений. Например, отсечение усеченного вида можно решить, используя методы, описанные в главах 6 и 7.

## 1.1 Обзор содержания

В следующих разделах дается краткое описание глав этой книги.

### 1.1.1 Глава 2: Проблемы проектирования обнаружения столкновений

В этой главе рассказывается о проблемах, которые необходимо учитывать при построении системы обнаружения столкновений, и о факторах, влияющих на проектирование. К таким факторам относятся то, как представлены объекты, их количество, как они перемещаются и какие типы запросов о столкновениях пользователь хочет задать. Глава 2 также знакомит с терминологией, которая используется в остальной части книги.

### 1.1.2 Глава 3: Учебник по математике и геометрии

Любая нетривиальная система обнаружения столкновений требует много математических расчетов, основанных на геометрии, чтобы определить, есть ли, когда и где для запросов столкновения. Глава 3 знакомит с математическими и геометрическими понятиями, необходимыми для понимания материала, изучаемого в остальных главах.

### 1.1.3 Глава 4: Граничные объемы

Чтобы ускорить выполнение запросов на столкновение, сначала используются простые геометрические объекты, такие как сферы и прямоугольники, для представления объектов более сложной природы. Только в случае столкновения «простых» ограничивающих объемов (которые достаточно велики для инкапсуляции сложных объектов) выполняются тесты на сложной геометрии. Глава 4 описывает несколько типов ограничивающих объемов, как выполнять для них тесты на пересечение и как подогнать ограничивающий объем к сложному объекту.

### 1.1.4 Глава 5: Базовые тесты примитивов

В предыдущей главе мы начали рассматривать тесты на пересечение. В главе 5 подробно описывается большое количество тестов для определения статуса пересечения и расстояния между парами объектов разного типа, включая линии, лучи, сегменты, плоскости, треугольники, многоугольники, сферы, параллелипипеды, цилиндры и многогранники. В этих тестах рассматриваются как статические, так и движущиеся объекты.

### 1.1.5 Глава 6: Иерархии ограничивающих объемов

Для больших объектов и для коллекций объектов повышение производительности может быть достигнуто за счет построения иерархий ограничивающих объемов над объектом (объектами). Такие иерархии обеспечивают быструю идентификацию объектов или частей объекта, которые не могут участвовать в столкновении, позволяя запросам ограничивать тестирование небольшим количеством объектов или частей объекта. В главе 6 рассказывается о желаемых характеристиках иерархий ограничивающих объёмов и способах построения и выполнения запросов к ним. В главе также исследуются эффективные способы представления этих иерархий.

### 1.1.6 Глава 7: Пространственное разбиение

Когда рассматривается большое количество объектов для столкновения, объекты должны быть разделены на небольшие непересекающиеся подгруппы для облегчения быстрых тестов (с целью избежать наихудшего квадратичного поведения тестирования всех объектов относительно всех других объектов). Иерархии ограничивающих объемов, обсуждаемые в главе 6, представляют собой один из способов выполнения такого разделения. Глава 7 исследует другие подходы к разделению, основанные на сетках, деревьях и сортировке объектов.

### 1.1.7 Глава 8: Иерархии деревьев BSP

Одной из наиболее универсальных древовидных структур для представления данных обнаружения столкновений является дерево разделения двоичного пространства (binary space partitioning, BSP). Деревья BSP можно использовать для разделения пространства независимо от объектов в пространстве. Их также можно использовать для отделения границы объекта от пространства, в котором он находится, тем самым эффективно формируя объемное представление объекта. Глава 8 рассказывает о надежном построении BSP-деревьев и о том, как выполнять тесты на полученных деревьях.

### 1.1.8 Глава 9: Основанные на выпуклости методы

Глава 9 рассматривает ряд более продвинутых методов выполнения запросов на столкновение с выпуклыми объектами, используя особые свойства выпуклых объектов. Представлены иерархические представления, алгоритм ближайших особенностей V-Clip, математические методы оптимизации линейного и квадратичного программирования, эффективный алгоритм Гилберта–Джонсона–Кирти и алгоритм разделяющих векторов Чанга и Ванга.

### 1.1.9 Глава 10: Обнаружение столкновений с помощью GPU

Обычные графические карты для ПК достигли такой степени, что обладают большей вычислительной мощностью, чем основной процессор ПК. Это изменение вызвало интерес к переложению вычислений на видеокарты. В главе 10 кратко рассказывается, как выполнять тесты обнаружения столкновений с использованием графического оборудования.

### 1.1.10 Глава 11: Числовая устойчивость

Даже самые маленькие ошибки в системе обнаружения столкновений могут привести к катастрофическим сбоям. Например: объекты не могут столкнуться со статическим пейзажем геометрии мира и, таким образом, выпадают из мира. В этой главе обсуждаются вопросы устойчивости, связанные с работой с арифметикой с плавающей запятой, и предлагаются подходы к решению этих проблем.

### 1.1.11 Глава 12: Геометрическая устойчивость

В то время как Глава 11 рассматривает, как надежно выполнять вычисления, Глава 12 рассматривает проблему взятия произвольного набора многоугольников и превращения его в хорошо сформированную геометрию, пригодную для ввода в систему обнаружения столкновений. Представлены методы сварки вершин, удаления зазоров и трещин, сращивания копланарных граней и разложения объектов на выпуклые (или треугольные) части.

### 1.1.12 Глава 13: Оптимизация

В последней главе книги рассказывается о том, как взять эффективные структуры данных и алгоритмы, представленные в книге, и сделать их еще более эффективными, нацелив и настроив их для конкретной аппаратной платформы. Значительный прирост производительности может быть достигнут за счет оптимизации кода для использования преимуществ иерархии памяти (кешей) и параллелизма кода и данных. В главе 13 представлено подробное описание того, как проводить такую оптимизацию.

## 1.2 О коде

В рамках практического характера этой книги многие из представленных идей дополняются примерами кода. В то время как многие книги полагаются исключительно на высокоуровневый псевдокод для передачи общих идей алгоритма, здесь большая часть кода дается на C++. Есть две причины для представления кода в этом виде. Во-первых, он предоставляет детали, которые часто жизненно важны для понимания (и реализации) алгоритма. Во-вторых, понимание теперь можно дополнительно получить, запустив код и изучив значения переменных во время выполнения. Последнее особенно важно для читателя, который не может полностью разбираться в математике, необходимой для реализации конкретного алгоритма. Лишь в нескольких местах книги данный код выражен псевдокодом, в основном там, где было бы непрактично предоставить полную реализацию.

Хотя C++ используется для кода в книге, следует подчеркнуть, что основное внимание в книге уделяется не C++. C++ используется только как средство для представления подробных исполняемых алгоритмов описанных концепций. Этой цели мог бы служить любой компьютерный язык, но C++ был выбран по нескольким причинам, включая его популярность и его способность кратко абстрагироваться от низкоуровневых манипуляций с геометрическими объектами, такими как точки и векторы, с использованием классов и (перегруженных) инфиксных операторов. Чтобы сделать представленный код доступным как можно большему количеству программистов (например, тех, кто знаком только с C или Java), по возможности намеренно избегали определенных функций C++, таких как шаблоны и STL (Стандартная библиотека шаблонов). Любители C++ могут захотеть сделать несколько глубоких вдохов в начале каждой главы!

Точно так же это не книга по разработке программного обеспечения. Чтобы основные идеи были представлены как можно лучше, код должен быть кратким и по существу. Были сделаны уступки, чтобы не загромождать текст подробным синтаксисом C++. Например, определения классов намеренно минималистичны (или отсутствуют), глобальные переменные иногда заменяют правильные переменные-члены, указатели не объявляются как константы (или ограничивают), а массивы часто объявляются фиксированного размера вместо того, чтобы динамически выделяться соответствующего размера. Имена переменных также были ограничены по длине, чтобы строки кода лучше вписывались на страницу набора.

Чтобы превратить представленный код в реальный производственный код, могут потребоваться некоторые дополнения. Например, тесты на деление на ноль не всегда выполняются, чтобы не вдаваться в детали, которые могут затруднить понимание общего подхода. Точно так же некоторые тесты кода могут потребовать добавления значений допуска для полной устойчивости. Цель состоит в том, чтобы обсудить надежность в главе 11, чтобы прояснить, какие изменения (если таковые имеются) необходимы для превращения представленного кода в надежный производственный код. Чтобы прояснить, какие аргументы функции являются входами, а какие - выходами, входные переменные часто передаются по значению, а выходные переменные - по ссылке. В некоторых случаях было бы более эффективно передавать входные переменные по ссылке. Это оставлено в качестве упражнения для читателя.

Комментарии набираются курсивом, а код - жирным шрифтом. Имена функций, классов, структур и определяемых пользователем типов начинаются с заглавной буквы, а переменные - с строчной буквы. Где возможно, имена переменных были выбраны в соответствии с обозначениями, используемыми в сопроводительном тексте. В некоторых случаях эти правила противоречат друг другу. Например, точки в тексте обозначаются заглавными буквами, а в коде - строчными.

Представленный в книге код реализован в большей степени в проекте Эрвина Куманса [«Bullet»](https://github.com/bulletphysics/bullet3).

# Глава 2
# Вопросы проектирования обнаружения столкновений

Проектирование эффективной системы обнаружения столкновений немного похоже на сборку головоломки: необходимо соединить множество частей, прежде чем появится общая картина. Подобным образом большая часть этой книги посвящена изучению отдельных частей, в которых используются различные подходы к обнаружению столкновений. Общая картина станет ясной по ходу книги. В этой главе дается краткий обзор ряда вопросов, которые необходимо учитывать при выборе подходов, и того, как соотносятся компоненты этих подходов. В этой главе также вводится ряд терминов, определения и пояснения которых будут даны в следующих главах. Более подробно затронутые здесь вопросы представлены в остальных главах книги.

## 2.1 Факторы проектирования алгоритма коллизий

Есть несколько факторов, влияющих на выбор, сделанный при разработке системы обнаружения столкновений. Эти факторы будут разбиты на следующие категории:

1. *Представление области приложения*. Геометрические представления, используемые для сцены и ее объектов, имеют прямое отношение к используемым алгоритмам. С меньшими ограничениями, накладываемыми на эти представления, необходимо использовать более общие решения по обнаружению столкновений с возможными последствиями для производительности.
2. *Различные типы запросов*. Как правило, чем более подробны типы запросов и результаты, тем больше вычислительных усилий требуется для их получения. Для поддержки определенных запросов могут потребоваться дополнительные структуры данных. Не все представления объектов поддерживают все типы запросов.
3. *Параметры моделирования окружающей среды*. Само моделирование содержит несколько параметров, оказывающих непосредственное влияние на систему обнаружения столкновений. Сюда входит количество объектов, их относительные размеры и положение, перемещаются ли они и как, разрешено ли им проникать друг в друга, и являются ли они жесткими или гибкими.
4. *Производительность*. Системы обнаружения столкновений в реальном времени работают с жесткими ограничениями по времени и размеру. Поскольку время и пространство всегда являются компромиссом, несколько функций обычно сбалансированы для удовлетворения заявленных требований к производительности.
5. *Надежность*. Не все приложения требуют одинакового уровня физического моделирования. Например, укладка кирпичей друг на друга требует гораздо большей сложности от системы обнаружения столкновений, чем наличие баскетбольного мяча, подпрыгивающего на баскетбольной площадке. Мяч, отскочивший слишком рано или под несколько большим углом, останется незамеченным, но даже малейшие ошибки в вычислении точек соприкосновения сложенных кирпичей могут привести к тому, что они медленно начнут проникать друг в друга или соскальзывать друг с друга.
6. *Простота реализации и использования*. Большинство проектов выполняются в установленные сроки. Планирование функций системы обнаружения столкновений ничего не значит, если система не может быть завершена и введена в эксплуатацию вовремя. Поэтому решения относительно простоты реализации играют большую роль в выборе подхода.

Эти вопросы более подробно рассматриваются в оставшейся части главы.

## 2.2 Представление области приложения

Чтобы выбрать подходящие алгоритмы обнаружения столкновений, важно учитывать типы геометрических представлений, которые будут использоваться для сцены и ее объектов. В этом разделе вкратце рассказывается о различных представлениях объектов, о том, как упрощенную геометрию можно использовать вместо геометрии моделирования, и как знание конкретных приложений может позволить использовать специализированные решения вместо более общих решений.

### 2.2.1 Представления объектов

В большинстве современных аппаратных средств в качестве основного примитива рендеринга используются треугольники. Следовательно, *многоугольное представление* является естественным выбором для сцен и объектов сцены, а также для их соответствующей геометрии столкновения. Самым общим полигональным представлением является *буфер из полигонов*: неупорядоченный набор полигонов без информации о связности, указывающей, как один полигон связан с другим. Без каких-либо ограничений, буфер из многоугольников является привлекательным представлением для художников и дизайнеров уровней. Алгоритмы, работающие с буферами полигонов, применимы к любому набору полигонов, но, как правило, менее эффективны и менее надежны, чем те, которые полагаются на дополнительную информацию. Например, многоугольный буфер не содержит информации о «внутренней части» объекта, поэтому нет простого способа узнать, оказался ли объект каким-то образом ошибочно внутри другого объекта. Упомянутая дополнительная информация может включать в себя, какие ребра соединяются с какими вершинами и какие грани соединяются с данной гранью, образует ли объект замкнутое твердое тело и является ли объект выпуклым или вогнутым.


**Рисунок 2.1** Геометрические модели, подобные изображенной на картинке, обычно строятся из набора полигональных сеток.

Многоугольники могут быть соединены друг с другом на своих рёбрах, чтобы сформировать большую многоугольную поверхность, называемую *многоугольной сеткой*. Построение объектов из набора полигональных сеток - один из наиболее распространенных методов создания геометрических моделей (рис. 2.1).

Многоугольные объекты определяются в терминах их вершин, ребер и граней. Говорят, что при таком построении объекты имеют *явное* представление. *Неявные* объекты относятся к сферам, конусам, цилиндрам, эллипсоидам, торам и другим геометрическим примитивам, которые не определены явно таким образом, но неявно через математическое выражение. Неявные объекты часто описываются как отображение функций из трехмерного пространства в действительные числа, $f:ℝ^3→ℝ$, где точки заданы $f(x,y,z)<0$
и принадлежат объекту, $f(x,y,z)=0$ граница, и $f(x,y,z)>0$ находятся вне объекта (рисунок 2.2). Граница объекта, определяемая неявной функцией, называется неявной поверхностью. Неявные объекты могут использоваться как грубые аппроксимации объектов сцены для быстрой отбраковки. Неявная форма может позволить проводить быстрые тесты на пересечение, особенно с линиями и лучами - факт, используемый в приложениях для трассировки лучей. Несколько примеров неявных тестов приведены в главе 5.

**Рисунок 2.2** Неявно определенная сфера (где сфера определяется как граница плюс внутренняя часть).

**Рисунок 2.3** (а) Куб с цилиндрическим отверстием в нем. (b) Дерево построения CSG для левого объекта, где цилиндр вычитается из куба.

Выпуклые многоугольные объекты также можно описать как пересечение ряда полупространств. Например, куб может быть выражен как пересечение шести полупространств, каждое полупространство «обрезает» часть пространства, лежащую за пределами грани куба. Полупространства и объемы пересечений полупространств более подробно описаны в главе 3.

Геометрические примитивы, такие как сферы, параллелипипеды и цилиндры, также являются строительными блоками объектов, созданных с помощью структуры конструктивной твердотельной геометрии (constructive solid geometry, CSG). Объекты CSG рекурсивно формируются путем применения теоретико-множественных операций (таких как объединение, пересечение или различие) с основными геометрическими фигурами или другими объектами CSG, что позволяет создавать объекты произвольной сложности. Таким образом, объект CSG представлен в виде (бинарного) дерева с теоретико-множественными операциями, заданными во внутренних узлах, и геометрическими примитивами в листьях (рис. 2.3). Объекты CSG подразумевают, что вершины, ребра и грани не доступны напрямую.

Сильной стороной CSG-моделирования является то, что результирующие объекты всегда действительны - без трещин и других проблем, мешающих полигональным представлениям. CSG также является представлением объёма, что позволяет легко определить, например, находится ли точка запроса внутри объекта CSG. CSG на многогранных объектах может быть реализован с помощью процессов, описанных, например, в [Laidlaw86] и [Thibault87]. Однако может быть трудно добиться надежных реализаций из-за неточности численных расчетов.

### 2.2.2 Столкновение против геометрии рендеринга

Хотя можно передать геометрию визуализации непосредственно в систему столкновений, есть несколько причин, по которым лучше иметь отдельную геометрию, с которой выполняется обнаружение столкновений.

1. Графические платформы продвинулись до такой степени, что визуализация геометрии становится слишком сложной, чтобы ее можно было использовать для обнаружения столкновений или физики. Кроме того, обычно существует ограничение на то, насколько точными должны быть столкновения. Таким образом, вместо использования той же геометрии, которая использовалась для рендеринга, для обнаружения столкновений вместо нее можно использовать упрощенную прокси-геометрию. В играх, например, принято полагаться на простые геометрические фигуры, такие как сферы и параллелипипеды, для представления игрового объекта, независимо от сложности объекта. Если прокси-объекты сталкиваются, предполагается, что сталкиваются и фактические объекты. Эти простые геометрические формы или *ограничивающие объемы* часто используются для ускорения запросов на столкновение независимо от того, какое геометрическое представление используется. Ограничивающие объемы обычно делаются так, чтобы полностью заключить геометрию. Граничные объемы подробно обсуждаются в Главе 4.

2. Для современного оборудования геометрия, как правило, задается в очень специфических форматах (таких как полосы треугольников и индексированные буферы вершин), которые позволяют быстро рендерить, но не обнаруживают столкновения. Вместо того, чтобы декодировать эти структуры на лету (даже если декодированные данные можно кэшировать для повторного использования), обычно более эффективно предоставить специальную геометрию столкновения. Кроме того, графическое оборудование часто поддерживает форматы только для треугольников. Для геометрии столкновения эффективность иногда может быть достигнута за счет поддержки других, нетреугольных примитивов.

3. Необходимые данные и организация данных для геометрии рендеринга и геометрии столкновений, вероятно, сильно различаются. В то время как данные статического рендеринга могут быть отсортированы по материалам, данные о столкновениях обычно организованы пространственно. Для визуализации геометрии требуются встроенные данные, такие как информация о материале, цвета вершин и координаты текстуры, тогда как геометрия столкновений требует связанных свойств поверхности. Разделение этих двух и хранение всей информации, относящейся к столкновениям, уменьшает данные о столкновении. Меньшие данные, в свою очередь, приводят к повышению эффективности за счет большей согласованности кэша данных.

4. Иногда геометрия столкновения отличается от визуализированной геометрии конструктивно. Например, снег по колено для игры сноуборд можно смоделировать с помощью поверхности столкновения на полметра ниже визуализированного представления поверхности снега. Аналогичным образом можно поступить с ходьбой по колышущейся траве по щиколотку или по мутной воде по пояс. Даже если геометрия визуализации используется в качестве геометрии столкновения, должны быть предусмотрены условия для исключения некоторой геометрии визуализации из (и для включения дополнительной геометрии без визуализации в) набор данных геометрии столкновения.

5. В целях моделирования данные о столкновениях должны храниться, даже если данные визуализации могут быть выброшены как невидимые. Поскольку геометрия столкновения меньше, чем соответствующая геометрия рендеринга, таким образом уменьшается объем постоянной памяти.

6. Исходная геометрия может быть представлена в виде полигонального буфера или сетки, тогда как для моделирования требуется представление твердотельного объекта. В этом случае гораздо проще вычислить твердую прокси-геометрию, чем пытаться каким-то образом укрепить исходное геометрическое представление.

Однако у использования раздельной геометрии столкновений есть некоторые потенциальные недостатки.

1. Дублирование данных (в основном вершин) приводит к использованию дополнительной памяти. Эту проблему можно облегчить, создав часть или всю геометрию столкновения из геометрии рендеринга на лету с помощью кэширования линеаризации (как описано в Разделе 13.5 и далее).

2. Для изготовления и поддержания двух наборов одинаковой геометрии может потребоваться дополнительная работа. Построение прокси-геометрии вручную ухудшит график ее создания. Если он построен с помощью инструмента, этот инструмент должен быть написан до того, как система столкновений станет пригодной для использования. Кроме того, если есть необходимость вручную изменить выходные данные инструмента, изменения необходимо каким-то образом передать обратно в инструмент и исходный набор данных.

3. Если они построены и поддерживаются отдельно, геометрия рендеринга и коллизий может не совпадать в разных местах. Когда геометрия столкновения не заполняет тот же объем, что и геометрия визуализации, объекты могут частично исчезать или парить над поверхностью других объектов.

4. Версии и другие проблемы логистики могут проявиться для двух геометрий. Была ли геометрия столкновения действительно перестроена при изменении геометрии рендеринга? Если создается вручную, что будет первым: геометрия столкновения или геометрия визуализации? И как вы обновляете одно, когда другое меняется?

Для игр достаточно хорошо работает использование прокси-геометрии, которая близка (но может не совсем соответствовать) реальным визуальным эффектам. С точки зрения восприятия люди не очень хорошо определяют, происходят ли точные столкновения. Чем больше задействовано объектов и чем быстрее они движутся, тем меньше вероятность того, что игрок заметит какие-либо несоответствия. Люди также плохо умеют предсказывать, каким должен быть исход столкновения, что позволяет проявлять вольность и при реагировании на столкновение. В играх обнаружением столкновений и реагированием на них можно эффективно управлять по принципу «если все выглядит правильно, значит, правильно». Другие приложения предъявляют более строгие требования к точности.

### 2.2.3 Специализация алгоритмов столкновений

Вместо того, чтобы иметь одну всеобъемлющую систему обнаружения столкновений, часто бывает целесообразно предоставить специализированные системы столкновений для конкретных сценариев. Примером того, где важна специализация, являются столкновения частиц. Вместо того, чтобы отправлять частицы одну за другой через обычную систему столкновений, они лучше обрабатываются и отправляются на столкновение как группы частиц, где группы могут формироваться и преобразовываться в зависимости от контекста. Частицы могут быть даже исключены из столкновения, в тех случаях, когда отсутствие столкновения не заметно.

Другой пример - использование отдельных алгоритмов для обнаружения столкновения между объектом и другими объектами, а также между объектом и сценой. Столкновения объект-объект могут быть даже дополнительно специализированы, чтобы персонаж игрока и быстро движущиеся снаряды обрабатывались иначе, чем другие объекты. Например, случай, когда все объекты всегда сталкиваются с персонажем игрока, лучше рассматривать как жестко запрограммированный тест, а не вставлять персонажа игрока в общую систему столкновений.

Рассмотрим также моделирование больших миров. Для маленьких миров данные о столкновениях могут всегда храниться в памяти. Однако в большом бесшовном мире данные о столкновениях должны загружаться и выгружаться по мере прохождения мира. В последнем случае наличие объектов, отделенных от мировой структуры, снова является привлекательным выбором, поэтому на объекты не влияют изменения мировой структуры. Возможный недостаток наличия отдельных структур для хранения, скажем, объектов и мира, заключается в том, что теперь выполнение запросов влечет за собой обход двух структур данных, а не только одной.

## 2.3 Типы запросов

Самый простой запрос на столкновение - это проблема *обнаружения пересечения* или *проверки пересечения*: ответ на логический вопрос о том, перекрываются ли два (статических) объекта, A и B, в их заданных положениях и ориентациях. Логические запросы пересечения быстро и легко реализовать, поэтому они широко используются. Однако иногда логического результата недостаточно и необходимо найти пересекающиеся части. Проблема *поиска пересечений* является более сложной, поскольку включает поиск одной или нескольких точек соприкосновения.

Для некоторых приложений достаточно найти какую-либо общую точку между объектами. В других случаях, например, при моделировании твердого тела, может потребоваться определение набора точек соприкосновения, то есть *контактного коллектора*. Надежное вычисление контактного многообразия - сложная задача. В целом, с *приблизительными запросами*, ответы на которые требуются только с точностью до заданного допуска, гораздо проще иметь дело, чем с *точными запросами*. Примерные запросы - обычное дело в играх. Кроме того, в играх запросы о столкновении обычно требуются для сообщения определенных свойств столкновения, назначенных объектам и их границам. Например, такие свойства могут включать скользкость дорожного покрытия или способность преодолевать подъем по поверхности стены.

Если объекты проникают, некоторые приложения требуют определения *глубины проникновения*. Глубина проникновения обычно определяется как *минимальное поступательное расстояние*: длина самого короткого вектора движения, который разделял бы объекты. В общем, вычисление этого вектора движения - сложная задача. *Расстояние разделения* между двумя непересекающимися объектами A и B определяется как минимум расстояний между точками в A и точками в B. Когда расстояние равно нулю, объекты пересекаются. Измерение расстояния между двумя объектами полезно, так как позволяет прогнозировать следующее столкновение. Более общая проблема заключается в нахождении *ближайших точек* к A и B: точки в A и точки в B, определяющих расстояние между объектами. Обратите внимание, что ближайшие точки не обязательно уникальны; может быть бесконечное количество ближайших точек. Для динамических объектов вычисление следующего времени столкновения известно как расчет *предполагаемого времени прибытия* (estimated time of arrival, ETA) или *времени столкновения* (time of impact, TOI). Значение ETA можно использовать, например, для управления временным шагом при моделировании твердого тела. Тип движения - один из параметров моделирования, обсуждаемых далее в следующем разделе.

## 2.4 Параметры моделирования окружающей среды

Как упоминалось ранее в этой главе, несколько параметров моделирования напрямую влияют на то, что является подходящим выбором для системы обнаружения столкновений. Чтобы проиллюстрировать некоторые из проблем, которые они могут вызвать, в следующих разделах конкретно рассматривается, как количество объектов и их перемещение связаны с обработкой столкновений.

### 2.4.1 Количество объектов

Поскольку любой объект потенциально может столкнуться с любым другим объектом, требуется симуляция с n объектами (n−1)+(n−2)+...+1=n(n−1)/2=O(n<sup>2</sup>) попарных тестов,
худший случай. Из-за квадратичной временной сложности наивное тестирование каждой пары объектов на столкновение быстро становится слишком дорогостоящим даже при умеренных значениях n. Снижение затрат, связанных с парным тестом, только линейно повлияет на время выполнения. Чтобы действительно ускорить процесс, необходимо уменьшить количество тестируемых пар. Это сокращение выполняется путем разделения обработки столкновений нескольких объектов на две фазы: *широкую фазу (broad phase)* и *узкую фазу (narrow phase)*.

На широкой фазе определяются более мелкие группы объектов, которые *могут* сталкиваться, и быстро исключаются те, которые определенно *не сталкиваются*. Узкая фаза представляет собой попарные тесты внутри подгрупп. Он отвечает за определение точных столкновений, если таковые имеются. Широкую и узкую фазы иногда называют обработкой n тел и парной обработкой соответственно.

На рисунке 2.4 показано, как широкофазная обработка снижает рабочую нагрузку за счет стратегии «разделяй и властвуй» (divide-and-conquer). Для 11 объектов (показаны прямоугольниками) для теста всех пар потребуется 55 тестов отдельных пар. После того, как обработка в широкой фазе дала 5 непересекающихся подгрупп (обозначенных заштрихованными областями), в узкой фазе нужно будет выполнить только 10 индивидуальных парных тестов. Методы обработки с широкой фазой обсуждаются в главах с 6 по 8. Обработка с узкой фазой рассматривается в главах 4, 5 и 9.

**Рисунок 2.4** На широкой фазе определяются непересекающиеся группы возможно пересекающихся объектов.

Помимо количества объектов, относительный размер объектов также влияет на количество тестов, которые необходимо выполнить. Когда в сцене присутствуют как маленькие, так и большие объекты, широкофазная система обычно должна работать усерднее (или быть более сложной) для идентификации групп, чем для набора однородных по размеру объектов. Как размер объекта влияет на широкофазовые методы, обсуждается далее в главе 7.

### 2.4.2 Последовательное или одновременное движение

В реальной жизни объекты движутся *одновременно* в течение заданного временного шага движения, и любые возможные столкновения разрешаются за этот временной шаг. Для точного компьютерного моделирования реального события необходимо каким-то образом определить самое раннее время контакта между любыми двумя движущимися объектами. Затем симуляцию можно продвинуть до этого момента времени, переместив все объекты в положение, в котором они были бы, когда произойдет первое столкновение. Затем столкновение разрешается, и процесс продолжает определять следующее столкновение, повторяя его до тех пор, пока не будет использован весь временной шаг движения.

Выполнение моделирования путем многократного перехода к следующему наиболее раннему моменту контакта становится довольно дорогостоящим. Например, когда один или несколько объектов упираются в поверхность, следующее столкновение происходит почти сразу после текущего времени столкновения. Таким образом, симуляция продвигается лишь на небольшую часть, и для определения полного временного шага перемещения может потребоваться практически «вечность». Одно из решений этой проблемы - использовать широкую фазу для идентификации групп объектов, которые могут взаимодействовать внутри группы, но не с объектами других групп в течение временного шага. Таким образом, моделирование каждой группы может выполняться с разной скоростью, помогая облегчить проблему в целом.

**Рисунок 2.5** (a) Вверху: Если оба объекта движутся одновременно, столкновения нет. Внизу: если круговой объект перемещается раньше треугольником, объекты сталкиваются. В (b) снова нет столкновения для одновременного движения, но для последовательного движения объекты сталкиваются. (c) объекты сталкиваются при одновременном движении, но не при последовательном движении.

Альтернативный вариант - перемещать объекты одновременно, но с фиксированным (маленьким) шагом по времени для перемещения. Одновременное движение может привести к взаимопроникновению объектов, с чем обычно нужно как-то бороться, например, путем резервного копирования моделирования в более раннее состояние. В обоих случаях одновременные обновления остаются дорогостоящими и поэтому часто используются для точного моделирования твердого тела. Однако многие игры, как и другие приложения, не являются симуляциями твердого тела, и было бы излишним и потраченным впустую попытки имитировать движение с высокой точностью. Для них альтернативным вариантом является *последовательное* разрешение движения. То есть объекты перемещаются по одному объекту за раз, и любые столкновения обнаруживаются и разрешаются до того, как процесс продолжится со следующим объектом.

Ясно, что последовательное движение не является физически точной моделью движения. Некоторые объекты могут столкнуться с объектами, которые еще не двигались в этом кадре, но которые бы сдвинулись с места, если бы два объекта двигались одновременно (рис. 2.5a). Другие объекты могут столкнуться с объектами, которые двигались раньше, а теперь находятся на их пути (рис. 2.5b). В некоторых случаях, когда два одновременно движущихся объекта столкнулись бы на полпути своего движения, столкновения теперь будут пропускаться, поскольку один объект перемещается мимо другого (рис. 2.5c). В играх, например, проблемы, связанные с моделью последовательного движения, часто можно игнорировать. Высокая частота кадров в играх часто делает шаг движения настолько маленьким, что перекрытие также невелико и не очень заметно.

Одним из преимуществ модели последовательного движения является то, что инвариант непроникания объекта очень легко поддерживать. Если во время движения объекта происходит столкновение, движение можно просто отменить (например). Только необходимость отменить движение одного объекта следует противопоставить модели одновременного движения с фиксированным временным шагом, в которой движение всех одновременно перемещаемых объектов должно быть отменено.

### 2.4.3 Дискретное и непрерывное движение

То, что может сильно повлиять как на вычислительные усилия, необходимые для определения результата столкновения, так и на точность самого результата, заключается в том, что два объекта, участвующие в парном тесте, движутся во время тестирования. *Обнаружение статического столкновения* включает обнаружение пересечения между объектами в дискретные моменты времени во время их движения. В каждый такой момент времени объекты обрабатываются так, как если бы они были неподвижны в своих текущих положениях с нулевой скоростью. Напротив, *динамическое обнаружение столкновений* учитывает полное непрерывное движение объектов в течение заданного интервала времени. Динамические тесты столкновения обычно могут сообщать точное время столкновения и точку (точки) первого контакта. Статические тесты (намного) дешевле, чем динамические, но интервалы времени между тестами должны быть короткими, чтобы движение объектов было меньше пространственной протяженности объектов. В противном случае объекты могут просто переходить друг друга от одного временного шага к следующему без обнаружения столкновения. Это явление называется *туннелированием*.

Объем, покрываемый объектом, непрерывно движущимся за заданный промежуток времени, называется *охватываемым объемом (swept volume)*. Если эти объемы двух движущихся объектов не пересекаются, значит, между объектами нет пересечения. Даже если охватываемые объемы пересекаются, объекты могут не пересекаться во время движения. Таким образом, пересечение охватываемых объемов является достаточным, но не необходимым условием столкновения объектов. Для сложных движений охватываемый объем сложно вычислить и с ним работать. К счастью, идеальная точность требуется редко. Динамическое испытание на столкновение сложных опрокидывающихся движений обычно можно упростить, допустив кусочно-линейное движение; то есть линейное перемещение по диапазону движения с мгновенным вращением в конце (или начале) движения. Где-то между этими двумя альтернативами находится замена неограниченного движения винтовым движением (то есть фиксированным вращательным и поступательным движением).

При работе с движущимися объектами практически всегда предпочтительно учитывать относительное движение объектов, вычитая движение одного объекта из другого объекта, таким образом фактически оставляя один объект статичным. Предполагая линейное поступательное движение для объектов, эта операция представляет собой простое вычитание вектора. Ключевым преимуществом рассмотрения только относительного движения является то, что для тестирования одного движущегося объекта относительно неподвижного объекта тест с охватываемым объемом теперь является тестом на точное пересечение. В играх весь охватываемый объем иногда просто заменяется *скоростным коробкой*: продолговатым прямоугольником, закрывающим весь диапазон движения объекта (или каким-либо аналогичным простым прокси-объектом, не обязательно прямоугольником).

## 2.5 Производительность

Если взять в качестве примера игровые приставки, для получения наилучших визуальных эффектов игры должны работать со скоростью 60 кадров в секунду (в странах с форматом NTSC TV; 50 кадров в секунду на территории PAL). Эта частота кадров оставляет 16,7 мс для подготовки каждого игрового кадра. В зависимости от типа игры обнаружение столкновений может составлять, скажем, от 10 до 30% кадра, в свою очередь оставляя от 2 до 5 мс для обнаружения столкновений. Для платформенной игры, в которой могут быть десятки объектов, зависящих от столкновений, активных в данный момент времени, для обработки столкновения для каждого объекта может быть доступно только от 50 до 250 мкс - это немного времени. Ясно, что очень важно уменьшить среднее время выполнения запросов на столкновение. Однако, поскольку в играх очень заметны большие внезапные падения частоты кадров, также важно убедиться, что худший случай для выбранных алгоритмов не занимает больше времени, чем в среднем.

Можно сделать несколько вещей, чтобы ускорить обработку столкновений, чему в значительной степени и посвящена это произведение. Некоторые общие идеи относительно того, какие оптимизации важны для обнаружения столкновений, обсуждаются в следующем разделе.

### 2.5.1 Обзор оптимизации

Первый принцип оптимизации заключается в том, что нет ничего быстрее, чем вообще не выполнять задачу. Таким образом, некоторые из наиболее успешных оптимизаций скорости вращаются вокруг как можно более быстрого сокращения объема работы до минимально возможного. Таким образом, одной из наиболее важных оптимизаций для системы обнаружения столкновений является широкая фаза обработки, упомянутая в разделе 2.4.1, то есть использование пространственной локализации объектов. Поскольку объекты могут поражать только те предметы, которые находятся рядом с ними, испытаний с удаленными объектами можно избежать, разбив их по пространству. Затем тесты производятся только в отношении областей, расположенных непосредственно рядом с объектом, игнорируя те, которые находятся слишком далеко, чтобы пересекать объект. Есть сильное сходство между этим пространственным разделением и тем, что сделано для отсечения вида, чтобы ограничить количество нарисованных графических объектов.

Пространственное разделение может быть выполнено с использованием плоской структуры, например, путем разделения пространства на сетку ячеек одинакового размера. Это также может быть реализовано в терминах иерархии, где пространство рекурсивно делится пополам, пока не будет достигнута некоторая цель завершения. Затем объекты вставляются в сетку или иерархию. Сетки и иерархическое разбиение также полезны для парных тестов узкой фазы, особенно когда объекты имеют высокую сложность. Вместо того, чтобы тестировать один объект против другого, они позволяют ограничить тесты столкновений частями двух ближайших друг к другу объектов. Объектное и пространственное разбиение обсуждается в главах 6 и 7.

Проведение недорогих тестов ограничивающего объема перед выполнением более дорогих геометрических тестов также является хорошим способом сократить объем работы, необходимой для определения столкновения. Скажем, охватывающие ограничивающие сферы были добавлены ко всем объектам, тогда простой тест на пересечение сфер со сферами теперь покажет - когда сферы не перекрываются - что дальнейшее тестирование сложной содержащейся геометрии не требуется. Граничные объемы рассматриваются в главе 4.

Понимание того, что объекты имеют тенденцию делать небольшие локальные шаги от кадра к кадру - если они вообще перемещаются - приводит к третьей важной оптимизации: использовать эту *временную (или от кадра к кадру) когерентность*. Например, нужно тестировать только объекты, которые переместились с момента последнего кадра; статус столкновения остается таким же для других объектов. Временная когерентность также может позволить кэшировать данные и вычисления и повторно использовать их в одном или нескольких будущих кадрах, что ускоряет тесты. Предположения, основанные на согласованности движений, очевидно, становятся недействительными, если объектам разрешено «телепортироваться» в произвольные места. Согласованность более подробно обсуждается в главе 9.

Наконец, очень важны оптимизации для конкретной архитектуры. Многие платформы поддерживают некоторый тип кода или параллелизм данных, которые при полном использовании могут обеспечить значительное ускорение. Из-за больших различий между скоростью, с которой работают ЦП, и скоростью, с которой основная память может предоставлять данные для работы (с преимуществом скорости для ЦП), то, как геометрия столкновений и другие данные хранятся в памяти, также может иметь огромное влияние скорости на систему столкновения. Эти вопросы подробно рассматриваются в главе 13.

## 2.6 Надежность

Обнаружение столкновений - одно из множества геометрических приложений, для которых очень важна надежность. В этой книге надежность используется просто для обозначения способности программы работать с численными вычислениями и геометрическими конфигурациями, с которыми в некотором роде трудно справиться. Столкнувшись с такими проблемными входными данными, надежная программа дает ожидаемые результаты. Ненадежная программа может в тех же ситуациях аварийно завершиться или зайти в бесконечный цикл. Проблемы устойчивости можно в общих чертах разделить на два класса: проблемы, связанные с отсутствием *числовой устойчивости*, и проблемы, связанные с отсутствием *геометрической устойчивости*.

Проблемы числовой устойчивости возникают из-за использования переменных конечной точности во время вычислений. Например, когда промежуточные вычисления становятся больше, чем может быть представлено переменной с плавающей точкой или целым числом, промежуточный результат будет недействительным. Если такие проблемы не обнаружены, окончательный результат вычисления также может быть неверным. Надежные реализации должны гарантировать невозможность возникновения таких проблем, или если они это сделают, вместо них будут возвращены скорректированные действительные результаты.

Геометрическая устойчивость влечет за собой обеспечение топологической правильности и общей геометрической согласованности. Проблемы часто связаны с невозможной или вырожденной геометрией, что может быть результатом неправильного численного расчета. Большинство алгоритмов на том или ином уровне ожидают правильно сформированных входных данных. Если задана неправильная входная геометрия, например, треугольники, вырождающиеся в точку, или многоугольники, не все вершины которых лежат в плоскости, может произойти что угодно, если эти случаи не будут обнаружены и рассмотрены.

Иногда трудно провести различие между числовой и геометрической надежностью, поскольку одно может порождать другое. Чтобы избежать неясных и трудно исправляемых ошибок времени выполнения, надежность должна рассматриваться как при проектировании, так и при разработке системы обнаружения столкновений. В главах 11 и 12 устойчивость обсуждается более подробно.

## 2.7 Простота реализации и использования

В случае внедрения системы обнаружения столкновений с нуля вопрос ожидаемого времени разработки может быть столь же важным, как и желаемый набор функций. Например, игры часто имеют ограниченный бюджет и временные рамки, и задержка любого критического компонента может дорого обойтись. При оценке простоты реализации интересно посмотреть не только на общую сложность алгоритма, но и на то, сколько и какого типа особые случаи задействованы, сколько задействованных переменных настройки (таких как числовые допуски) и другие ограничения, которые могут повлиять на время разработки.

Несколько дополнительных вопросов связаны с использованием системы обнаружения столкновений. Например, насколько общая система? Может ли она работать с объектами самых разных размеров? Может ли она также отвечать на различные запросы? Сколько времени требуется в процессе сборки для создания структур данных, связанных с конфликтами? Что касается последнего вопроса, хотя время, затрачиваемое на предварительную обработку, не имеет значения для производительности во время выполнения, оно все ещё важно на этапе проектирования и производства. В процессе разработки модели часто меняются, а длительное время предварительной обработки снижает производительность и затрудняет экспериментирование. Некоторые из этих вопросов можно решить, допустив более быстрое и менее оптимизированное построение структуры данных во время разработки, а также более медленное, но более оптимальное построение для неотладочных сборок.

### 2.7.1 Отладка системы обнаружения столкновений

Как и весь код, системы обнаружения столкновений подвержены ошибкам. Поиск этих ошибок иногда может быть трудным и требовать много времени. Во время разработки можно предпринять шаги, чтобы сделать этот процесс отладки менее болезненным. Вот несколько хороших идей:

- Храните циклический буфер аргументов для n последних запросов о конфликте, соответствующих данным за несколько секунд (или больше). Затем, когда что-то пойдет не так, программа может быть приостановлена, а данные могут быть выведены для дальнейшего анализа, например, для пошагового выполнения вызовов с сохраненными аргументами. Регистрируемые данные также могут предоставить полезную информацию при срабатывании утверждения.
- Предоставьте средства для визуализации геометрии столкновения. Например, вы можете визуализировать проверенные поверхности, их атрибуты столкновения, а также любые иерархии и группировки поверхностей. Кроме того, визуализируйте сами запросы на столкновение, предпочтительно с историей, предоставленной циклическим буфером, упомянутым ранее. Эта визуализация обеспечивает контекст, который позволяет легко выявлять неверные запросы на столкновение.
- Реализуйте простой *эталонный алгоритм* (например, алгоритм перебора, который проверяет все объекты или все полигоны относительно друг друга) и запускайте эталонный алгоритм параллельно с более сложным алгоритмом. Если результаты различаются, есть проблема (по всей видимости, с более продвинутым алгоритмом).
- Поддерживайте набор тестов и запускайте код столкновения с набором тестов при изменении кода. Код геометрической природы, как правило, имеет множество особых случаев, и наличие набора всеобъемлющих тестов помогает в раннем обнаружении проблем. Каждый раз, когда обнаруживается ошибка, добавляйте тестовые примеры, чтобы определить, появляется ли она когда-либо повторно.

Конечно, также применимы все общие стратегии отладки, такие как использование вызовов **assert()**. Хорошее обсуждение таких стратегий можно найти в [McConnell93,
Глава 26].

## 2.8 Резюме

В этой главе описаны многие факторы, которые необходимо учитывать при разработке и внедрении системы обнаружения столкновений. В нем говорилось о возможных представлениях геометрии столкновений и о том, следует ли использовать геометрию рендеринга или специальную геометрию для выполнения тестов столкновений. Обработка коллизий была определена как происходящая в два этапа: узкую и широкую. Широкая фаза связана с грубым определением небольших подгрупп потенциально сталкивающихся объектов, тогда как узкая фаза выполняет подробные тесты парных столкновений между объектами. Узкофазное тестирование является основной темой глав 4 и 5, где обсуждается множество различных типов запросов для самых разных геометрических представлений объектов. Узкофазное тестирование также обсуждается в главе 9. Широкофазовые методы обсуждаются в главах с 6 по 8. Была подчеркнута важность устойчивости. В этой книге две полные главы посвящены теме устойчивости, главы 11 и 12. Поскольку эта книга посвящена обнаружению столкновений для приложений реального времени, производительность также была подчеркнута как важное системное соображение. В некотором смысле большая часть книги посвящена производительности, поскольку на протяжении всего ее обсуждения обсуждаются эффективные алгоритмы и структуры данных. Книга завершается обсуждением оптимизации в главе 13.

# Глава 4
# Ограничивающие объёмы

Непосредственная проверка геометрии двух объектов на предмет столкновения друг с другом часто бывает очень дорогой, особенно когда объекты состоят из сотен или даже тысяч полигонов. Чтобы минимизировать эту стоимость, ограничивающие объемы объекта обычно проверяются на пересечение перед выполнением проверки пересечения геометрии.

Ограничивающий объем (bounding volume, BV) - это один простой объем, вмещающий один или несколько объектов более сложной природы. Идея состоит в том, чтобы более простые объемы (такие как параллелипипеды и сферы) имели более дешевые тесты на пересечение, чем сложные объекты, которые они связывали. Использование ограничивающих объемов позволяет проводить быстрые тесты на отсутствие перекрытия, потому что нужно проверять сложную геометрию, только когда первоначальный запрос перекрытия для ограничивающих объемов дает положительный результат (рисунок 4.1).

Конечно, когда объекты действительно перекрываются, этот дополнительный тест приводит к увеличению времени вычислений. Однако в большинстве случаев несколько объектов обычно находятся достаточно близко, чтобы их ограничивающие объемы перекрывались. Следовательно, использование ограничивающих объемов обычно приводит к значительному увеличению производительности, а исключение сложных объектов из дальнейших тестов хорошо оправдывает небольшие дополнительные затраты, связанные с тестом ограничивающего объема.

Для некоторых приложений тест пересечения ограничивающего объема сам по себе служит достаточным доказательством столкновения. Если этого не происходит, обычно все же целесообразно обрезать содержащиеся объекты, чтобы ограничить дальнейшие тесты полигонами, содержащимися в перекрытии ограничивающих объемов. Тестирование полигонов объекта A по сравнению с полигонами объекта B обычно имеет сложность $O(n^2)$. Таким образом, если количество тестируемых полигонов можно, скажем, сократить вдвое, рабочая нагрузка снизится на 75%. Глава 6, посвященная иерархиям ограничивающих объемов, дает более подробную информацию о том, как сократить тестирование объектов и полигонов до минимума. В этой главе обсуждение ограничивается тестами пар ограничивающих объемов. Кроме того, представленные здесь тесты в основном однородны в том смысле, что ограничивающие объемы одного и того же типа тестируются друг против друга. Однако нередко можно использовать несколько типов ограничивающих объемов одновременно. Несколько тестов на неоднородное пересечение BV обсуждаются в следующей главе.

**Рисунок 4.1** Ограничивающие объемы A и B не перекрываются, и, следовательно, A и B не могут пересекаться. Нельзя исключать пересечение между C и D, потому что их ограничивающие объемы перекрываются.

В качестве ограничивающих рамок были предложены многие геометрические формы. В этой главе основное внимание уделяется наиболее часто используемым формам; а именно сферы, параллелипипеды и выпуклые корпусные объемы. Несколько менее распространенных ограничивающих объемов приведены в Разделе 4.7.

## 4.1 Желательные характеристики BV

Не все геометрические объекты служат эффективными ограничивающими объемами. Желательные свойства ограничивающих объемов включают:

- Недорогие тесты на пересечение
- Плотное прилегание
- Недорого в вычислении
- Легко вращать и перемещать
- Занимает мало памяти

Ключевая идея, лежащая в основе ограничивающих объемов, заключается в том, чтобы предшествовать дорогим геометрическим тестам менее дорогостоящие тесты, которые позволяют тесту выйти раньше, так называемый «ранний выход». Для поддержки недорогих тестов на пересечение ограничивающий объем должен иметь простую геометрическую форму. В то же время, чтобы сделать испытание на раннем этапе максимально эффективным, ограничивающий объем должен быть как можно более плотным, что приведет к компромиссу между стоимостью испытания на герметичность и пересечением. Тест на пересечение не обязательно охватывает только сравнение с объемами одного и того же типа, но может также тестировать с другими типами ограничивающих объемов. Кроме того, тестирование может включать в себя такие запросы, как включение точек, пересечение луча с объемом и пересечение с плоскостями и многоугольниками.

**Рисунок 4.2** Типы ограничивающих объемов: сфера, выровненный по оси ограничивающий параллелипипед (axis-aligned bounding box, AABB), ориентированный ограничивающий параллелипипед (oriented
bounding box, OBB), дискретный многогранник ориентации по восьми направлениям (eight-direction discrete orientation polytope, 8-DOP) и выпуклая оболочка.

Ограничивающие объемы обычно вычисляются на этапе предварительной обработки, а не во время выполнения. Тем не менее, важно, чтобы их конструкция не влияла отрицательно на время создания ресурсов. Однако некоторые ограничивающие объемы необходимо повторно выровнять во время выполнения при перемещении содержащихся в них объектов. Для них, если вычисление ограничивающего объема является дорогостоящим, повторное выравнивание ограничивающего объема предпочтительнее (дешевле), чем его пересчет с нуля.

Поскольку ограничивающие объемы хранятся в дополнение к геометрии, в идеале они должны добавлять немного дополнительной памяти к геометрии. Более простые геометрические формы требуют меньше памяти. Поскольку многие из желаемых свойств в значительной степени исключают друг друга, отсутствие определенного ограничивающего объема - лучший выбор для всех ситуаций. Вместо этого лучше всего протестировать несколько разных ограничивающих объемов, чтобы определить наиболее подходящий для данного приложения. На рисунке 4.2 показаны некоторые компромиссы между пятью наиболее распространенными типами ограничивающего объема. Данный порядок в отношении лучших границ, лучшего отбора, более быстрых тестов и меньшего объема памяти следует рассматривать как приблизительное, а не абсолютное руководство. Первым из ограничивающих объемов, рассматриваемых в этой главе, является выровненный по оси ограничивающий параллелипипед, описанный в следующем разделе.

## 4.2 Выровненные по оси ограничительные параллелипипеды (Axis-aligned Bounding Boxes, AABBs)

Выровненный по оси ограничивающий прямоугольник (AABB) - один из наиболее распространенных ограничивающих объемов. Это прямоугольный шестигранный блок (в 3D, четырехсторонний в 2D), грани которого ориентированы таким образом, что нормали его граней всегда параллельны осям данной системы координат. Лучшая особенность AABB - это быстрая проверка перекрытия, которая просто включает прямое сравнение отдельных значений координат.

**Рисунок 4.3** Три распространенных представления AABB: (a) min-max, (b) min-widths и (c) center-radius.

Существует три распространенных представления AABB (рис. 4.3). Один - по минимальному и максимальному значениям координат по каждой оси:

 ```
    // region R = { (x, y, z) | min.x<=x<=max.x, min.y<=y<=max.y, min.z<=z<=max.z }
    struct AABB {
        Point min;
        Point max;
    };
 ```

Это представление определяет область BV пространства как область между двумя противоположными угловыми точками: min и max. Другое представление - это минимальная угловая точка min и ширина или диаметр dx, dy и dz от этого угла:

```
    // region R = { (x, y, z) | min.x<=x<=min.x+dx, min.y<=y<=min.y+dy, min.z<=z<=min.z+dz}
    struct AABB {
        Point min;
        float d[3]; // диаметр или ширина (dx, dy, dz)
};
```
Последнее представление определяет AABB как центральную точку C и пределы или радиусы полуширины rx, ry и rz вдоль ее осей:

```
    // region R = { (x, y, z) | |c.x-x|<=rx, |c.y-y|<=ry, |c.z-z|<=rz }
    struct AABB {
        Point c;    // центральная точка AABB
        float r[3]; // радиус или половина ширины (rx, ry, rz)
    };
```

С точки зрения требований к памяти представление центрального радиуса является наиболее эффективным, поскольку значения полуширины часто могут храниться в меньшем количестве бит, чем значения центрального положения. То же самое верно и для значений ширины представления min-width, хотя и в несколько меньшей степени. Наихудшим является представление min-max, в котором все шесть значений должны храниться с одинаковой точностью. Для уменьшения объема памяти требуется представление AABB с использованием целых чисел, а не чисел с плавающей запятой, как здесь используется.

Если объект перемещается только путем переноса, обновление последних двух представлений дешевле, чем представление min-max, потому что необходимо обновить только три из шести параметров. Полезной особенностью представления центрального радиуса является то, что его также можно протестировать как ограничивающую сферу.

### 4.2.1 AABB-AABB пересечение

Тесты на пересечение между AABB просты, независимо от представления. Два AABB перекрываются, только если они перекрываются по всем трем осям, причем их протяженность по каждому измерению рассматривается как интервал на соответствующей оси. Для представления min-max этот тест перекрытия интервалов принимает следующий вид:

```
    int TestAABBAABB(AABB a, AABB b) {
        // Выход без пересечения, если они разделены по оси
        if (a.max[0] < b.min[0] || a.min[0] > b.max[0]) return 0;
        if (a.max[1] < b.min[1] || a.min[1] > b.max[1]) return 0;
        if (a.max[2] < b.min[2] || a.min[2] > b.max[2]) return 0;
        // Перекрытие по всем осям означает, что AABB пересекаются
        return 1;
    }
```

Представление min-ширина наименее привлекательно. Его тест на пересечение, даже если он написан экономно, все равно не сравнится с первым тестом с точки зрения количества выполненных операций:

```
    int TestAABBAABB(AABB a, AABB b) {
        float t;
        if ((t = a.min[0] - b.min[0]) > b.d[0] || -t > a.d[0]) return 0;
        if ((t = a.min[1] - b.min[1]) > b.d[1] || -t > a.d[1]) return 0;
        if ((t = a.min[2] - b.min[2]) > b.d[2] || -t > a.d[2]) return 0;
        return 1;
    }
```

Наконец, представление центр-радиус приводит к следующему тесту на пересечение:

```
    int TestAABBAABB(AABB a, AABB b) {
        if (Abs(a.c[0] - b.c[0]) > (a.r[0] + b.r[0])) return 0;
        if (Abs(a.c[1] - b.c[1]) > (a.r[1] + b.r[1])) return 0;
        if (Abs(a.c[2] - b.c[2]) > (a.r[2] + b.r[2])) return 0;
        return 1;
    }
```

В современных архитектурах вызов **Abs()** обычно преобразуется в одну инструкцию. В противном случае функцию можно эффективно реализовать, просто удалив знаковый бит двоичного представления значения с плавающей запятой. Когда поля AABB объявляются как целые числа, а не как числа с плавающей запятой, альтернативный тест для представления центр-радиус может быть выполнен следующим образом. С целыми числами перекрытие между двумя диапазонами [A, B] и [C, D] может быть определено выражением:

```
overlap = (unsigned int)(B - C) <= (B - A) + (D - C);
```

При принудительном понижении значения без знака в случае, когда C>B, левая часть становится недопустимо большим значением, делая выражение ложным. Принудительное переполнение эффективно заменяет вызов функции абсолютного значения и позволяет записать тест представления центрального радиуса как:

```
    int TestAABBAABB(AABB a, AABB b) {
        int r;
        r = a.r[0] + b.r[0]; if ((unsigned int)(a.c[0] - b.c[0] + r) > r + r) return 0;
        r = a.r[1] + b.r[1]; if ((unsigned int)(a.c[1] - b.c[1] + r) > r + r) return 0;
        r = a.r[2] + b.r[2]; if ((unsigned int)(a.c[2] - b.c[2] + r) > r + r) return 0;
        return 1;
    }
```

Работа с целыми числами позволяет использовать другие приемы реализации, многие из которых зависят от архитектуры. Инструкции SIMD, если они есть, обычно позволяют реализовать тесты AABB в виде всего лишь нескольких инструкций кода (примеры которых можно найти в главе 13). Наконец, в системе обнаружения столкновений, которая должна выполнять огромное количество тестов на пересечение, может быть целесообразно упорядочить тесты в соответствии с вероятностью их проведения. Например, если операции в основном выполняются в почти плоской плоскости xz, проверка координаты y должна выполняться в последнюю очередь, поскольку она вероятнее одинакова.

### 4.2.2 Вычисления и обновления AABB

Ограничивающие объемы обычно задаются в локальном пространстве модели связанных объектов (которое может быть мировым пространством). Чтобы выполнить запрос на пересечение между двумя ограничивающими объемами, объемы должны быть преобразованы в общую систему координат. Выбор стоит между преобразованием двух ограничивающих объемов в мировое пространство и преобразованием одного ограничивающего объема в локальное пространство другого. Одно из преимуществ преобразования в локальное пространство состоит в том, что в результате ему приходится выполнять половину работы по преобразованию в мировое пространство. Это также часто приводит к более жесткому ограничению объема, чем преобразование в мировое пространство. Рисунок 4.4 иллюстрирует эту концепцию. Пересчитанные AABB объектов A и B перекрываются в мировом пространстве (рис. 4.4a). Однако в пространстве объекта B объекты оказываются разделенными (рисунок 4.4c).

**Рисунок 4.4** (a) AABB A и B в мировом пространстве. (b) AABB в локальном пространстве A. (c) AABB в локальном пространстве B.

Точность - еще одна веская причина для преобразования одного ограничивающего объема в локальное пространство другого. Мировое пространственный тест может сдвинуть оба объекта далеко от начала координат. Действие добавления смещения в перенос во время преобразования локальных координат, близких к началу координат ограничивающего объема, может привести к потере многих (или даже всех) бит точности исходных значений. Для локальных пространственных тестов объекты хранятся рядом с исходной точкой и точность расчетов сохраняется. Обратите внимание, однако, что путем корректировки переносов так, чтобы преобразованные объекты были сосредоточены в начале мирового пространства, преобразования также могут быть выполнены для поддержания точности.

Преобразование в мировое пространство становится интересным, когда обновленные ограничивающие объёмы могут кратковременно кэшироваться в течение временного шага. Путем кэширования ограничивающего объема после преобразования любой ограничивающий объем должен быть преобразован только один раз в любое заданное пространство. Поскольку все ограничивающие объемы преобразуются в одно и то же пространство при преобразовании в мировое пространство, это становится преимуществом в ситуациях, когда объекты проверяются на пересечение несколько раз. Напротив, кэширование обновленных ограничивающих объемов вообще не помогает при преобразовании в локальное пространство других ограничивающих объемов, поскольку все преобразования включают либо новые объекты, либо новые целевые системы координат. Кэширование обновленных ограничивающих объемов имеет недостаток, состоящий в почти удвоении необходимого пространства для хранения, так как большинство полей представления ограничивающих объемов изменяются во время обновления.

Некоторые ограничивающие объемы, такие как сферы или выпуклые оболочки, естественным образом преобразуются в любую систему координат, так как они не ограничены определенной ориентацией. Следовательно, они называются невыровненными или (свободно) ориентированными ограничивающими объемами. Напротив, выровненные ограничивающие объемы (такие как AABB) ограничены в том, какую ориентацию они могут принимать. Выровненные ограничивающие объемы необходимо повторно выровнять, поскольку они становятся невыровненными из-за вращения объекта во время движения. Для обновления или реконструкции AABB есть четыре общие стратегии:

- Использование свободного AABB фиксированного размера, который всегда охватывает объект
- Вычисление точной динамической реконструкции из исходного набора точек
- Вычисление плотной динамической реконструкции с использованием восхождения на холм
- Вычисление приблизительной динамической реконструкции из повернутого AABB

В следующих четырех разделах эти подходы рассматриваются более подробно.

### 4.2.3 AABB из ограничивающей объект сферы

Первый метод полностью исключает необходимость изменения формы AABB, делая его достаточно большим, чтобы вмещать объект в любой ориентации. Этот охватывающий AABB фиксированного размера вычисляется как ограничивающий параллелипипед ограничивающей сферы содержащегося объекта A. Ограничивающая сфера, в свою очередь, центрируется в точке поворота P, вокруг которой A вращается. Его радиус r - это расстояние до самой дальней вершины объекта от этого центра (как показано на рисунке 4.5). Убедившись, что точка поворота объекта P находится в центре объекта, радиус сферы минимизируется.

**Рисунок 4.5** AABB ограничивающей сферы, которая полностью содержит объект A при произвольной ориентации.

Преимущество этого представления заключается в том, что во время обновления этот AABB просто необходимо преобразовать (тем же преобразованием, что и ограниченный объект), и любое вращение объекта можно полностью игнорировать. Однако сама ограничивающая сфера (которая имеет лучшие свойства, чем AABB) также будет обладать этим свойством. Таким образом, ограничивающие сферы следует рассматривать как потенциально лучший выбор ограничивающего объема в этом случае.

### 4.2.4 AABB реконструирован из исходного набора точек

Стратегия обновления, описанная в этом разделе (а также две оставшиеся стратегии обновления, которые будут описаны) динамически изменяет размер AABB, поскольку он повторно выравнивается с осями системы координат. Для плотно подогнанного ограничивающего прямоугольника исследуется основная геометрия ограниченного объекта и устанавливаются границы прямоугольника путем нахождения крайних вершин во всех шести направлениях координатных осей. Прямой подход проходит через все вершины, отслеживая вершину, наиболее удаленную от вектора направления. Это расстояние может быть вычислено через проекцию вектора вершины на вектор направления. Для сравнения нет необходимости нормализовать вектор направления. Эта процедура проиллюстрирована в следующем коде, который находит как наименьшие, так и наиболее удаленные точки вдоль вектора направления:

```
    // Возвращает индексы imin и imax в массив pt[] соответственно 
    // наименьшей и наиболее удаленной точки вдоль направления dir
    void ExtremePointsAlongDirection(Vector dir, Point pt[], int n, int *imin, int *imax) {
        float minproj = FLT_MAX, maxproj = -FLT_MAX;
        for (int i = 0; i < n; i++) {
            // Спроецировать вектор от начала до точки на вектор направления
            float proj = Dot(pt[i], dir);
            // Следить за наименее удаленной точкой вдоль вектора направления
            if (proj < minproj) {
                minproj = proj;
                *imin = i;
            }
            // Следить за самой удаленной точкой вдоль вектора направления
            if (proj > maxproj) {
                maxproj = proj;
                *imax = i;
            }
        }
    }
```

Когда n велико, эта процедура $O(n)$ может быть дорогостоящей, если осуществляется во время выполнения. Предварительная обработка данных вершин может ускорить процесс. Один простой подход, который не добавляет никаких дополнительных данных, основан на том факте, что только вершины на выпуклой оболочке объекта могут способствовать определению формы ограничивающего объема (Рисунок 4.6). На этапе предварительной обработки все k вершин выпуклой оболочки объекта будут сохранены таким образом, чтобы они располагались перед всеми оставшимися вершинами. Затем можно построить плотный AABB, исследуя только эти k первых вершин. Для обычных вогнутых объемов это было бы победой, но выпуклый объем, все вершины которого уже находятся на выпуклой оболочке, не улучшится.

Используя дополнительные специализированные предварительно вычисленные структуры поиска, поиск экстремальных вершин может быть выполнен за время $O(\log n)$. Например, для этой цели может использоваться иерархия Добкина–Киркпатрика (описанная в главе 9). Однако из-за дополнительной памяти, необходимой для этих структур, а также из-за накладных расходов при их обходе, в большинстве случаев их следует рассматривать как избыточные. Конечно, если жесткие ограничивающие объемы так важны, следует рассмотреть более жесткие ограничивающие объемы, чем AABB.

### 4.2.5 AABB из восхождения к вершине представления объекта

Другой способ ускорить процесс перестройки AABB - использовать представление объекта, в котором можно быстро найти соседние вершины для вершины. Такое представление позволяет расположить крайние вершины, определяющие новый AABB, путем простого подъема на холм (Рисунок 4.7).

**Рисунок 4.7** (a) Крайняя вершина E в направлении d. (b) После поворота объекта против часовой стрелки новая крайняя вершина E в направлении d может быть получена путем подъема на холм по пути вершины, выделенному серым цветом.

Вместо того, чтобы отслеживать минимальные и максимальные значения экстентов по каждой оси, поддерживаются шесть указателей вершин. Соответствуя тем же значениям, что и раньше, теперь они фактически указывают на (до шести) экстремальных вершин объекта вдоль каждого направления оси. Шаг подъема на холм теперь продолжается путем сравнения указанных вершин с их соседними вершинами, чтобы увидеть, являются ли они по-прежнему экстремальными в том же направлении, что и раньше. Те, которые не были заменены одним из их наиболее крайних соседей, и проверка повторяется до тех пор, пока не будет найдена экстремальная вершина в этом направлении. Чтобы не застрять в локальных минимумах, в процессе подъема на холм предметы должны быть выпуклыми. По этой причине восхождение на холм выполняется на предварительно рассчитанных выпуклых оболочках невыпуклых объектов. В целом, этот пересчет точного AABB является ожидаемой операцией с постоянным временем.

Необходимость преобразовывать вершины только при их фактическом исследовании в процессе восхождения на холм значительно сокращает вычислительные затраты. Однако это можно улучшить, если осознать, что только один из компонентов x, y или z используется для нахождения экстремальной вершины вдоль данной оси. Например, при нахождении экстремальной точки по оси +x необходимо вычислить только x-компоненты преобразованных вершин. Следовательно, трансформационные издержки снижаются на две трети.

Необходимо проявить осторожность, чтобы написать надежную реализацию этого метода восхождения. Рассмотрим экстремальную вершину вдоль любой оси, окруженную только компланарными вершинами. Если теперь объект вращается на 180 градусов вокруг любой из оставшихся двух осей, вершина становится экстремальной в противоположном направлении по той же оси.
Однако, поскольку он окружен компланарными вершинами, шаг подъема на холм не может найти лучшую соседнюю вершину и, таким образом, заканчивается вершиной, которая фактически является наименее экстремальной в искомом направлении! Надежная реализация должна учитывать эту ситуацию. В качестве альтернативы копланарные вершины могут быть удалены на этапе предварительной обработки, как описано в главе 12. Проблема поиска экстремальных вершин вновь рассматривается в разделе 9.5.4.

### 4.2.6 AABB пересчитан из повернутого AABB

Последний из четырех методов перестройки, наиболее распространенный подход - просто обернуть повернутый AABB в новый AABB. Это дает приблизительный, а не точный AABB. Поскольку результирующий AABB больше, чем тот, с которого был начат, важно, чтобы приблизительный AABB вычислялся из поворота исходного AABB локального пространства. В противном случае повторное вычисление из повернутого AABB на предыдущем временном шаге заставит AABB расти бесконечно.

Рассмотрим выровненный по оси ограничивающий параллелипипед A, на который действует матрица вращения **M**, в результате чего ориентированный ограничивающий параллелипипед A' имеет некоторую ориентацию. Три столбца (или строки, в зависимости от используемого матричного соглашения) матрицы вращения **M** задают оси мировых координат A' в его локальной системе координат. (Если векторы являются векторами-столбцами и умножаются справа от матрицы, то столбцы **M** являются осями. Если вместо этого векторы умножаются слева от матрицы как векторы-строки, тогда строки **M** являются осями.)

Скажем, A задается с использованием представления min-max, а **M** - матрица столбцов. Выровненный по осям ограничивающий параллелипипед B, ограничивающий A', задается интервалами экстентов, образованными проекцией восьми повернутых вершин A' на оси мировых координат. Для, скажем, x экстентов B, только x компоненты векторов-столбцов **M** вносят вклад.
Следовательно, поиск экстентов соответствует поиску вершин, которые производят минимальное и максимальное произведения со строками **M**. Каждая вершина B представляет собой комбинацию трех преобразованных минимальных или максимальных значений из A. Минимальное значение экстента - это сумма меньших членов, а максимальное значение - сумма больших членов. Смещение не влияет на вычисление размера нового ограничивающего параллелипипеда и может быть просто добавлено. Например, максимальный размер по оси x может быть вычислен как:

```
    B.max[0] = max(m[0][0] * A.min[0], m[0][0] * A.max[0])
             + max(m[0][1] * A.min[1], m[0][1] * A.max[1])
             + max(m[0][2] * A.min[2], m[0][2] * A.max[2]) + t[0];
```

Таким образом, вычисление ограничивающего параллелипипеда для повернутого AABB с использованием представления min-max может быть реализовано следующим образом:

```
    // Преобразование AABB a матрицей m и переносом t,
    // поиск максимальных экстентов и сохранение результата в AABB b.
    void UpdateAABB(AABB a, float m[3][3], float t[3], AABB &b) {
        // По всем трем осям
        for (int i = 0; i < 3; i++) {
            // Начало с добавления переноса
            b.min[i] = b.max[i] = t[i];
            // Формирование экстента 
            // суммированием меньших и больших членов соответственно
            for (int j = 0; j < 3; j++) {
                float e = m[i][j] * a.min[j];
                float f = m[i][j] * a.max[j];
                if (e < f) {
                    b.min[i] += e;
                    b.max[i] += f;
                } else {
                    b.min[i] += f;
                    b.max[i] += e;
                }
            }
        }
    }
```
Соответственно, код для представления AABB с центральным радиусом становится [Arvo90]:

```
    // Преобразование AABB a с помощью матрицы m и переноса t,
    // поиск максимальных экстентов и сохранение результата в AABB b.
    void UpdateAABB(AABB a, float m[3][3], float t[3], AABB &b) {
        for (int i = 0; i < 3; i++) {
            b.c[i] = t[i];
            b.r[i] = 0.0f;
            for (int j = 0; j < 3; j++) {
                b.c[i] += m[i][j] * a.c[j];
                b.r[i] += Abs(m[i][j]) * a.r[j];
            }
        }
    }
```

Обратите внимание, что вычисление AABB из повернутого AABB эквивалентно вычислению его из свободно ориентированного ограничивающего параллелипипеда. Ориентированные ограничивающие параллелипипеды и тесты их пересечения будут описаны более подробно ниже. Однако между методами, представленными здесь, и методами, которые будут представлены, будет классифицироваться метод сохранения ориентированных ограничивающих параллелипипедов с объектами, но все же пересекающих их как реконструированных AABB (как это сделано здесь). Для этого потребуется дополнительная память для хранения матрицы ориентации. Это также потребует дополнительного умножения матрицы на матрицу для комбинирования матрицы вращения ориентированного ограничивающего параллелипипеда с матрицей преобразования **M**. Преимущество этого решения состоит в том, что реконструированный выровненный по оси параллелипипед будет намного плотнее, начиная с ориентированного параллелипипеда. Проверка соосности по оси также намного дешевле, чем полномасштабная проверка для ориентированных параллелипипедов.

## 4.3 Сферы

Сфера - еще один очень распространенный ограничивающий объем, который по популярности может соперничать с ограничивающим прямоугольником, выровненным по оси. Как и у AABB, у сфер есть недорогой тест на пересечение. Сферы также имеют то преимущество, что они инвариантны относительно вращения, что означает, что их легко преобразовать: их просто нужно перенести в новое положение. Сферы определяются положением центра и радиусом:

```
    // Region R = { (x, y, z) | (x-c.x)∧2 + (y-c.y)∧2 + (z-c.z)∧2 <= r∧2 }
    struct Sphere {
        Point c; // Центр сферы
        float r; // Радиус сферы
    };
```

Ограничивающая сфера, состоящая всего из четырех компонентов, является ограничивающим объемом с наиболее эффективным использованием памяти. Часто центр или начало существующего объекта можно отрегулировать так, чтобы он совпадал с центром сферы, и нужно сохранить только один компонент, радиус. Вычислить оптимальную ограничивающую сферу не так просто, как вычислить оптимальный ограничивающий параллепипед, выровненный по оси. Некоторые методы вычисления ограничивающих сфер рассматриваются в следующих разделах в порядке увеличения точности, в заключение приводится алгоритм вычисления минимальной ограничивающей сферы. Методы, исследованные для алгоритмов неоптимальной аппроксимации, остаются актуальными в том смысле, что их можно применять к другим ограничивающим объемам.

### 4.3.1 Сфера-сфера пересечения

Тест на пересечение двух сфер очень прост. Вычисляется евклидово расстояние между центрами сфер и сравнивается с суммой радиусов сфер. Чтобы избежать часто дорогостоящей операции извлечения квадратного корня, сравниваются квадраты расстояний. Тест выглядит так:

```
    int TestSphereSphere(Sphere a, Sphere b) {
        // Вычисление квадрата расстояния между центрами
        Vector d = a.c - b.c;
        float dist2 = Dot(d, d);
        // Сферы пересекаются, если квадрат расстояния меньше квадрата суммы радиусов
        float radiusSum = a.r + b.r;
        return dist2 <= radiusSum * radiusSum;
    }
```

Хотя тест сферы имеет несколько больше арифметических операций, чем тест AABB, он также имеет меньше ветвей и требует меньше данных для выборки. В современных архитектурах тест сферы, вероятно, немногим быстрее теста AABB. Однако скорость этих простых тестов не должна быть определяющим фактором при выборе между ними. Плотность фактических данных - гораздо более важное соображение.

### 4.3.2 Вычисление ограничивающей сферы

Простую аппроксимативную ограничивающую сферу можно получить, сначала вычислив AABB всех точек. Затем средняя точка AABB выбирается в качестве центра сферы, а радиус сферы устанавливается как расстояние до точки, наиболее удаленной от этой центральной точки. Обратите внимание, что использование геометрического центра (среднего) всех точек вместо средней точки AABB может дать чрезвычайно плохие ограничивающие сферы для неравномерно распределенных точек (до двойного необходимого радиуса). Хотя это быстрый метод, он, как правило, не очень хорош по сравнению с оптимальным методом.

Альтернативный подход к вычислению простой аппроксимированной ограничивающей сферы описан в [Ritter90]. Этот алгоритм пытается найти хорошую начальную почти ограничивающую сферу, а затем за несколько шагов улучшить ее, пока она не ограничит все точки. Алгоритм выполняется за два прохода. На первом проходе находятся шесть (не обязательно уникальных) экстремальных точек по осям системы координат. Из этих шести точек выбирается пара точек, наиболее удаленных друг от друга. (Обратите внимание, что эти две точки не обязательно соответствуют точкам, определяющим самый длинный край AABB набора точек.) Центр сферы теперь выбран как середина между этими двумя точками, а радиус установлен равным половине расстояния между ними. Код для этого первого прохода указан в функциях **MostSeparatedPointsOnAABB()** и **SphereFromDistantPoints()** следующим образом:

```
    // Вычисление индексов двух наиболее разделенных точек, до шести точек, 
    // определяющих AABB, охватывающую набор точек. Возвращаем их как минимум и максимум.
    void MostSeparatedPointsOnAABB(int &min, int &max, Point pt[], int numPts) {
        // Сначала найти самые крайние точки вдоль главных осей
        int minx = 0, maxx = 0, miny = 0, maxy = 0, minz = 0, maxz = 0;
        for (int i = 1; i < numPts; i++) {
            if (pt[i].x < pt[minx].x) minx = i;
            if (pt[i].x > pt[maxx].x) maxx = i;
            if (pt[i].y < pt[miny].y) miny = i;
            if (pt[i].y > pt[maxy].y) maxy = i;
            if (pt[i].z < pt[minz].z) minz = i;
            if (pt[i].z > pt[maxz].z) maxz = i;
        }
        // Вычисление квадратов расстояний для трех пар точек
        float dist2x = Dot(pt[maxx] - pt[minx], pt[maxx] - pt[minx]);
        float dist2y = Dot(pt[maxy] - pt[miny], pt[maxy] - pt[miny]);
        float dist2z = Dot(pt[maxz] - pt[minz], pt[maxz] - pt[minz]);
        // Выбор пары (минимум, максимум) наиболее удаленных точек
        min = minx;
        max = maxx;
        if (dist2y > dist2x && dist2y > dist2z) {
            max = maxy;
            min = miny;
        }
        if (dist2z > dist2x && dist2z > dist2y) {
            max = maxz;
            min = minz;
        }
    }

    void SphereFromDistantPoints(Sphere &s, Point pt[], int numPts) {
        // Поиск наиболее разделенной пары точек, определяющей охватывающий AABB
        int min, max;
        MostSeparatedPointsOnAABB(min, max, pt, numPts);
        // Настройка сферы для охвата этих двух точек
        s.c = (pt[min] + pt[max]) * 0.5f;
        s.r = Dot(pt[max] - s.c, pt[max] - s.c);
        s.r = Sqrt(s.r);
    }
```

Во втором проходе все точки снова проходят. Для всех точек за пределами текущей сферы сфера обновляется до сферы, охватывающей старую сферу и внешнюю точку. Другими словами, диаметр новой сферы простирается от внешней точки до точки на задней стороне старой сферы напротив внешней точки относительно центра старой сферы.

```
    // Для Sphere s и Point p, обновление s (если необходимо), чтобы охватить p
    void SphereOfSphereAndPt(Sphere &s, Point &p) {
        // Вычислить квадрат расстояния между точкой и центром сферы
        Vector d = p - s.c;
        float dist2 = Dot(d, d);
        // Обновить s, только если точка p находится за её пределами
        if (dist2 > s.r * s.r) {
            float dist = Sqrt(dist2);
            float newRadius = (s.r + dist) * 0.5f;
            float k = (newRadius - s.r) / dist;
            s.r = newRadius;
            s.c += d * k;
        }
    }
```
Полный код для вычисления приблизительной ограничивающей сферы выглядит так:

```
    void RitterSphere(Sphere &s, Point pt[], int numPts) {
        // Получить сферу, охватывающую две примерно самые дальние точки
        SphereFromDistantPoints(s, pt, numPts);
        // Увеличить сферу, чтобы включить все точки
        for (int i = 0; i < numPts; i++)
        SphereOfSphereAndPt(s, pt[i]);
    }
```

Начав с лучшего приближения к истинной ограничивающей сфере, можно было ожидать, что полученная сфера будет ещё более плотной. Использование лучшего начального приближения рассматривается в следующем разделе.

### 4.3.3 Ограничивающая сфера из направления максимального распространения

Вместо нахождения пары удаленных точек с помощью AABB, как в предыдущем разделе, предлагаемый подход заключается в анализе облака точек с использованием статистических методов для определения направления максимального распространения [Wu92]. Определим это направление, две наиболее удаленные друг от друга точки при проецировании на эту ось будут использоваться для определения центра и радиуса начальной сферы. На рисунке 4.8 показана разница в разбросе по двум разным осям для одного и того же облака точек.

Среднее значение набора значений данных (то есть сумма всех значений, деленная на количество значений) является мерой центральной тенденции значений, дисперсия является мерой их разброса. Среднее $u$ и дисперсия $σ^2$ задаются как

$$u=\frac{1}{n}\sum_{i=1}^nx_i$$

$$\sigma^2=\frac{1}{n}\sum_{i=1}^n(x_i-u)^2=\frac{1}{n}(\sum_{i=1}^nx_i^2)-u^2$$

Квадратный корень из дисперсии известен как стандартное отклонение. Для значений, распределенных по одной оси, дисперсия легко вычисляется как среднее квадратичное отклонение значений от среднего:

```
    // Вычисление дисперсии набора одномерных значений
    float Variance(float x[], int n) {
        float u = 0.0f;
        for (int i = 0; i < n; i++)
            u += x[i];
        u /= n;
        float s2 = 0.0f;
        for (int i = 0; i < n; i++)
            s2 += (x[i] - u) * (x[i] - u);
        return s2 / n;
    }
```
Обычно нет очевидной прямой интерпретации дисперсии и стандартного отклонения. Однако они важны как сравнительные меры. Для двух переменных ковариация измеряет их тенденцию к изменению вместе. Она вычисляется как среднее значение произведений отклонения значений переменных от их средних значений. Для нескольких переменных ковариация данных обычно вычисляется и выражается в виде матрицы, матрицы ковариации (также называемой матрицей дисперсии-ковариации или матрицей дисперсии).

**Рисунок 4.8** Одно и то же облако точек в проекции на две разные оси. В (а) разброс по оси небольшой. В (б) разброс намного больше. Ограничивающая сфера может быть определена по оси, для которой набор проецируемых точек имеет максимальный разброс.

Ковариационная матрица $C = [c_{ij}]$ для набора из n точек $P_1 , P_2 , ... , P_n$ задаётся

$$c_{ij}=\frac{1}{n}\sum_{k=1}^n(P_{k,i}-u_i)(P_{k,j}-u_j)$$ 

или, что эквивалентно

$$c_{ij}=\frac{1}{n}(\sum_{k=1}^n P_{k,i}P_{k,j})-u_iu_j$$

Член $u_i$ (и $u_j$) - это среднее значение i-й координаты точек, заданный как

$$u_i=\frac{1}{n}\sum_{k=1}^nP_{k,i}$$

Неформально, чтобы увидеть, как работает ковариация, рассмотрим первую формулу ковариации. Когда две переменные имеют тенденцию отклоняться в одном и том же направлении от их соответствующих средних значений, умножение,

$$(P_{k,i}-u_i)(P_{k,j}-u_j)$$

чаще будет положительным, чем отрицательным. Если переменные имеют тенденцию отклоняться в разные стороны, произведение будет чаще отрицательным, чем положительным. Сумма этих произведений определяет взаимозависимость переменных. При реализации с использованием чисел с плавающей запятой одинарной точности первая из двух ковариационных формул имеет тенденцию давать более точные результаты за счет сохранения большего количества битов точности. При использовании двойной точности результаты обычно практически не различаются. Следующий код реализует первую формулу:

```
void CovarianceMatrix(Matrix33 &cov, Point pt[], int numPts) {
    float oon = 1.0f / (float)numPts;
    Point c = Point(0.0f, 0.0f, 0.0f);
    float e00, e11, e22, e01, e02, e12;
    // Вычислить центр масс (центроид) точек
    for (int i = 0; i < numPts; i++)
        c += pt[i];
    c *= oon;
    // Вычислить элементы ковариации
    e00 = e11 = e22 = e01 = e02 = e12 = 0.0f;
    for (int i = 0; i < numPts; i++) {
        // Перенести точки так, чтобы центр масс находился в начале координат
        Point p = pt[i] - c;
        // Вычислить ковариацию перенесенных точек
        e00 += p.x * p.x;
        e11 += p.y * p.y;
        e22 += p.z * p.z;
        e01 += p.x * p.y;
        e02 += p.x * p.z; //?
        e12 += p.y * p.z;
    }
    // Заполнить элементы ковариационной матрицы
    cov[0][0] = e00 * oon;
    cov[1][1] = e11 * oon;
    cov[2][2] = e22 * oon;
    cov[0][1] = cov[1][0] = e01 * oon;
    cov[0][2] = cov[2][0] = e02 * oon;
    cov[1][2] = cov[2][1] = e12 * oon;
}
```

После того, как ковариационная матрица вычислена, ее можно разложить таким образом, чтобы больше узнать о главных направлениях дисперсии. Это разложение выполняется путем вычисления собственных значений и собственных векторов матрицы. Связь между ними такова, что собственный вектор, связанный с собственным значением наибольшей величины, соответствует оси, вдоль которой точечные данные имеют наибольшую дисперсию. Точно так же собственный вектор, связанный с наименьшим собственным значением магнитуды, является осью, вдоль которой данные имеют наименьшую дисперсию. Надежное нахождение собственных значений и собственных векторов матрицы в общем случае является нетривиальной задачей. Как правило, их находят с помощью некоторого (итеративного) численного метода (для которого есть хороший источник [Golub96]).

По определению ковариационная матрица всегда симметрична. В результате он распадается на действительные (а не комплексные) собственные значения и ортонормированный базис собственных векторов. Для симметричных матриц можно использовать более простой подход декомпозиции. Для матрицы среднего размера, как здесь, метод Якоби работает довольно хорошо. Сложные детали метода Якоби выходят за рамки этой книги. Вкратце, однако, алгоритм выполняет ряд шагов преобразования заданной входной матрицы.

Каждый шаг заключается в применении поворота к матрице, приближая матрицу к диагональной матрице (все элементы равны нулю, кроме элементов на диагонали). Когда матрица диагональна, элементы на диагонали являются собственными значениями. При этом все повороты также объединяются в другую матрицу. После выхода эта матрица будет содержать собственные векторы. В идеале это разложение должно выполняться в арифметике с двойной точностью, чтобы минимизировать числовые ошибки. Следующий код для метода Якоби основан на презентации в [Golub96]. Во-первых, это подпрограмма для помощи в вычислении матрицы вращения.

```
    // Симметричное разложение Шура 2 на 2. 
    // Для симметричной матрицы размера n на n и индексов p, q 
    // таких, что 1 <= p < q <= n, 
    // вычисляем пару синус-косинус (s, c), которая будет служить 
    // для формирования матрицы вращения Якоби.
    //
    // Смотрите Golub, Van Loan, Matrix Computations, 4th ed, 
    // страница 478 (в pdf файле 502)
    void SymSchur2(Matrix33 &a, int p, int q, float &c, float &s) {
        if (Abs(a[p][q]) > 0.0001f) {
            float r = (a[q][q] - a[p][p]) / (2.0f * a[p][q]);
            float t;
            if (r >= 0.0f)
                t = 1.0f / (r + Sqrt(1.0f + r*r));
            else
                t = -1.0f / (-r + Sqrt(1.0f + r*r));
            c = 1.0f / Sqrt(1.0f + t*t);
            s = t * c;
        } else {
            c = 1.0f;
            s = 0.0f;
        }
    }
```
С учетом этой вспомогательной функции полный метод Якоби теперь реализован как:

```
// Вычисление собственных векторов и собственных значений симметричной матрицы A, 
// с помощью классического метода Якоби итеративного обновления A как A = J^T * A * J,
// где J = J(p, q, theta) матрица вращения Якоби.
//
// На выходе v будет содержать собственные векторы, а диагональные 
// элементы a являются соответствующими собственными значениями.
//
// Смотрите Golub, Van Loan, Matrix Computations, 4th ed, p428 
// страница 479 (в pdf файле 503)
void Jacobi(Matrix33 &a, Matrix33 &v) {
    int i, j, n, p, q;
    float prevoff, c, s;
    Matrix33 J, b, t;
    // Инициализация v единичной матрицей
    for (i = 0; i < 3; i++) {
        v[i][0] = v[i][1] = v[i][2] = 0.0f;
        v[i][i] = 1.0f;
    }
    // Повторение до некоторого максимального количества итераций
    const int MAX_ITERATIONS = 50;
    for (n = 0; n < MAX_ITERATIONS; n++) {
        // Найти наибольший недиагональный абсолютный элемент a[p][q]
        p = 0; q = 1;
        for (i = 0; i < 3; i++) {
            for (j = 0; j < 3; j++) {
                if (i == j) continue;
                if (Abs(a[i][j]) > Abs(a[p][q])) {
                    p = i;
                    q = j;
                }
            }
        }
        // Вычислить матрицу вращения Якоби J(p, q, theta)
        // (Этот код можно оптимизировать для трех разных случаев вращения)
        SymSchur2(a, p, q, c, s);
        for (i = 0; i < 3; i++) {
            J[i][0] = J[i][1] = J[i][2] = 0.0f;
            J[i][i] = 1.0f;
        }
        J[p][p] = c; J[p][q] = s;
        J[q][p] = -s; J[q][q] = c;
        // Накопите повороты в то, что будет содержать собственные векторы
        v = v * J;
        // Сделать 'a' более диагональной, пока на диагонали не останутся 
        // только собственные значения
        a = (J.Transpose() * a) * J;
        // Вычислить 'норму' недиагональных элементов
        float off = 0.0f;
        for (i = 0; i < 3; i++) {
            for (j = 0; j < 3; j++) {
                if (i == j) continue;
                off += a[i][j] * a[i][j];
            }
        }
        /* off = sqrt(off); not needed for norm comparison */
        // Остановиться, когда норма больше не снижается
        if (n > 2 && off >= prevoff)
        return;
        prevoff = off;
        }
    }
```

Для конкретной матрицы 3 × 3, используемой здесь, вместо применения общего подхода, такого как метод Якоби, собственные значения могут быть непосредственно вычислены из простого кубического уравнения. Тогда собственные векторы можно было бы легко найти, например, с помощью метода исключения Гаусса. Такой подход описан в [Cromwell94]. Учитывая ранее определенные функции, вычисление сферы из двух наиболее удаленных точек (в соответствии с разбросом) теперь выглядит так:

```
    void EigenSphere(Sphere &eigSphere, Point pt[], int numPts) {
        Matrix33 m, v;
        // Вычислить ковариационную матрицу m
        CovarianceMatrix(m, pt, numPts);
        // Разложить её на собственные векторы (в v) и собственные значения (в m)
        Jacobi(m, v);
        // Найти компонент с наибольшим собственным значением (наибольшим разбросом)
        Vector e;
        int maxc = 0;
        float maxf, maxe = Abs(m[0][0]);
        if ((maxf = Abs(m[1][1])) > maxe) maxc = 1, maxe = maxf;
        if ((maxf = Abs(m[2][2])) > maxe) maxc = 2, maxe = maxf;
        e[0] = v[0][maxc];
        e[1] = v[1][maxc];
        e[2] = v[2][maxc];
        // Найти самые крайние точки в направлении ’e’
        int imin, imax;
        ExtremePointsAlongDirection(e, pt, numPts, &imin, &imax);
        Point minpt = pt[imin];
        Point maxpt = pt[imax];
        float dist = Sqrt(Dot(maxpt - minpt, maxpt - minpt));
        eigSphere.r = dist * 0.5f;
        eigSphere.c = (minpt + maxpt) * 0.5f;
    }
```

Модифицированный полный код для расчета приблизительной ограничивающей сферы становится:

```
    void RitterEigenSphere(Sphere &s, Point pt[], int numPts) {
        // Начало со сферой из максимального распространения
        EigenSphere(s, pt, numPts);
        // Увеличение сферы до включения всех точек
        for (int i = 0; i < numPts; i++)
        SphereOfSphereAndPt(s, pt[i]);
    }
```

Тип ковариационного анализа, выполняемый здесь, обычно используется для уменьшения размерности и статистического анализа данных и известен как анализ главных компонентов (PCA). Дополнительную информацию о PCA можно найти в [Jolliffe02]. Собственные векторы ковариационной матрицы также можно использовать для ориентации ориентированного ограничивающего прямоугольника, как описано в разделе 4.4.3.

### 4.3.4 Ограничивающая сфера посредством итеративного уточнения

Основная идея алгоритма, описанного в разделе 4.3.2, заключается в том, чтобы начать с довольно хорошего, слегка недооцененного приближения к фактической наименьшей сфере, а затем увеличивать ее, пока она не охватит все точки. Учитывая лучшую начальную сферу, можно ожидать, что и последняя сфера будет лучше. Следовательно, неудивительно, что выходные данные алгоритма могут быть очень эффективно использованы для самоподдержки итеративным способом. Результирующая сфера одной итерации просто уменьшается на небольшую величину, чтобы сделать ее недооцененной для следующего итеративного вызова.

```
void RitterIterative(Sphere &s, Point pt[], int numPts) {
    const int NUM_ITER = 8;
    RitterSphere(s, pt, numPts);
    Sphere s2 = s;
    for (int k = 0; k < NUM_ITER; k++) {
        // Слегка сжать сферу, чтобы сделать её недооцененной (не ограниченной)
        s2.r = s2.r * 0.95f;
        // Сделать данные снова привязанными к сфере
        for (int i = 0; i < numPts; i++) {
            // Обмен pt[i] с pt[j], где j случайно из интервала [i+1,numPts-1]
            DoRandomSwap();
            SphereOfSphereAndPt(s2, pt[i]);
        }
        // Обновить s при обнаружении более плотной сферы
        if (s2.r < s.r) s = s2;
    }
}
```

Для дальнейшего улучшения результатов точки рассматриваются случайным образом, а не в одном и том же порядке от итерации к итерации. Результирующая сфера обычно намного лучше, чем сфера, созданная методом Ву (описанным в предыдущем разделе), за счет нескольких дополнительных итераций над входными данными. Если применить тот же итерационный подход к алгоритму Ву, результаты будут сопоставимы. Как и в случае со всеми итеративными алгоритмами восхождения на холм этого типа (такими как методы градиентного спуска, имитация отжига или поиск TABU), поиск может застрять в локальных минимумах, и оптимальный результат не гарантируется. Однако возвращаемый результат часто почти оптимален. Результат также очень надежный.

### 4.3.5 Минимальная ограничивающая сфера

Сфера однозначно определяется четырьмя (не копланарными) точками. Таким образом, алгоритм прямого перебора для вычисления минимальной ограничивающей сферы для набора точек должен учитывать все возможные комбинации четырех (затем трех, затем двух) точек, вычисление самой маленькой сферы через эти точки и сохранение сферы, если она содержит все другие точки. Сохраненная сфера с наименьшим радиусом тогда является минимальной ограничивающей сферой. Этот брутфорс алгоритм имеет сложность $O(n^5)$ и поэтому не практичен. К счастью, проблема вычисления минимальной ограничивающей сферы для набора точек хорошо изучена в области вычислительной геометрии, и рандомизированный алгоритм, который работает в течение ожидаемого линейного времени, был дан [Welzl91].

Предположим, что минимальная ограничивающая сфера S была вычислена для набора точек P. Если к P добавляется новая точка Q, то S нужно пересчитывать только в том случае, если Q лежит вне S. Нетрудно видеть, что Q должна лежать на границе новой минимальной ограничивающей сферы для множества точек $P∪{Q}$. Алгоритм Вельцля основан на этом наблюдении, в результате чего получается рекурсивный алгоритм. Он продолжается, поддерживая как набор входных точек, так и набор опор, который содержит точки из входного набора, которые должны лежать на границе минимальной сферы. Следующий фрагмент кода описывает алгоритм Вельцля:


```
    Sphere WelzlSphere(Point pt[], unsigned int numPts, Point sos[], unsigned int numSos) {
        // если нет точек ввода, рекурсия достигла дна. Теперь вычислить 
        // точную сферу на основе точек в наборе опор (от нуля до четырех точек)
        if (numPts == 0) {
            switch (numSos) {
            case 0: return Sphere();
            case 1: return Sphere(sos[0]);
            case 2: return Sphere(sos[0], sos[1]);
            case 3: return Sphere(sos[0], sos[1], sos[2]);
            case 4: return Sphere(sos[0], sos[1], sos[2], sos[3]);
            }
        }
        // Выбрать точку случайным образом (здесь только последняя точка входного набора)
        int index = numPts - 1;
        // Рекурсивно вычислить наименьшую ограничивающую сферу оставшихся точек
        Sphere smallestSphere = WelzlSphere(pt, numPts - 1, sos, numSos); // (*)
        // Если выбранная точка находится внутри этой сферы, она действительно самая маленькая
        if(PointInsideSphere(pt[index], smallestSphere))
        return smallestSphere;
        // В противном случае обновить набор опор, чтобы дополнительно включить новую точку
        sos[numSos] = pt[index];
        // Рекурсивно вычислить наименьшую сферу из оставшихся точек с новыми н.у. (s.o.s.)
        return WelzlSphere(pt, numPts - 1, sos, numSos + 1);
    }
```

Хотя два рекурсивных вызова внутри функции делают функцию дорогостоящей, Вельцл показал, что, если предположить, что точки удаляются из входного набора случайным образом, алгоритм выполняется за ожидаемое линейное время. Обратите внимание, что, как показано, первый рекурсивный вызов (отмеченный звездочкой в коде) может вызвать переполнение стека для входных данных, превышающих несколько тысяч точек. Небольшие изменения в коде позволяют избежать этой проблемы, как описано в [Gärtner99]. Полная реализация приведена в [Capens01].
В Интернете также доступна более сложная реализация, часть библиотеки алгоритмов вычислительной геометрии (Computational Geometry Algorithms Library, CGAL). Для написания надежной реализации алгоритма Вельцля необходимо, чтобы четыре вспомогательные функции для вычисления точных сфер от одной до четырех точек правильно обрабатывали вырожденные входные данные, такие как коллинеарные точки.

Алгоритм Вельцля можно применять для вычисления как ограничивающих кругов, так и шаров более высоких размеров. Однако он не распространяется напрямую на вычисление минимальной сферы, ограничивающей набор сфер. Алгоритм решения последней задачи приведен в [Fischer03]. Подробно рассмотрев сферы, мы теперь обратим внимание на ограничивающие параллелипипеды произвольной ориентации.

## 4.4 Ориентированные ограничивающие параллелипипеды (Oriented Bounding Boxes, OBBs)

Ориентированный ограничивающий параллелипипед (OBB) - это прямоугольный блок, очень похожий на AABB, но с произвольной ориентацией. Есть много возможных представлений OBB: как набор из восьми вершин, набор из шести плоскостей, набор из трех плит (пара параллельных плоскостей), угловая вершина плюс три взаимно ортогональных вектора ребра или центральная точка плюс матрица ориентации и три длины половинного ребра. Последнее обычно является предпочтительным представлением для OBB, поскольку оно позволяет проводить гораздо более дешевый тест на пересечение OBB-OBB, чем другие представления. Этот тест основан на теореме о разделяющей оси, которая более подробно обсуждается в главе 5.

```
// Region R = { x | x = c+r*u[0]+s*u[1]+t*u[2] } , |r|<=e[0], |s|<=e[1], |t|<=e[2]
struct OBB {
    Point c;     // Центральная точка OBB
    Vector u[3]; // Локальные оси x, y и z
    Vector e;    // Положительные значения полуширины OBB по каждой оси
};
```

При 15 числах с плавающей запятой или 60 байтах для чисел с плавающей запятой одинарной точности IEEE OBB является довольно дорогим ограничивающим объемом с точки зрения использования памяти. Требования к памяти можно снизить, сохранив ориентацию не как матрицу, а как углы Эйлера или как кватернион, используя от трех до четырех компонентов с плавающей запятой вместо девяти. К сожалению, для теста пересечения OBB-OBB эти представления должны быть преобразованы обратно в матрицу для использования в тесте эффективной разделительной оси, что является очень дорогостоящей операцией. Поэтому хорошим компромиссом может быть сохранение только двух осей матрицы вращения и вычисление третьей из перекрестного произведения двух других во время тестирования. Эта относительно дешевая операция ЦП позволяет сэкономить три компонента с плавающей запятой, в результате чего экономится 20% памяти.

### 4.4.1 OBB-OBB пересечение

В отличие от предыдущих тестов на пересечение ограничивающего объема, тест на пересечение между двумя ориентированными ограничивающими параллелипипедами на удивление сложен. Поначалу это кажется испытанием, чтобы увидеть, будет ли достаточно одного параллелипипеда, полностью выходящего за границу другого. В простейшей форме этот тест может быть выполнен путем проверки, находятся ли все вершины блока A за пределами плоскостей, определяемых гранями блока B, и наоборот. Однако, хотя этот тест работает в 2D, он не работает правильно в 3D. Он не может справиться, например, со случаем, когда A и B почти пересекаются от рёбра до рёбра, причем рёбра перпендикулярны друг другу. Здесь ни один параллелипипед не находится полностью вне одной стороны другой. Следовательно, простой тест сообщает, что они пересекаются, хотя это не так. Даже в этом случае простой тест может быть полезен. Хотя это не всегда правильно, он консервативен в том, что никогда не перестает обнаруживать столкновение. Только в некоторых случаях он неверно сообщает о перекрытии разделенных полей. Таким образом, он может служить предварительным испытанием для более дорогостоящего точного теста.

**Рисунок 4.9** Два OBB разделяются, если для некоторой оси L сумма их проецируемых радиусов меньше расстояния между их проектируемыми центрами.

Точный тест на пересечение OBB и OBB может быть реализован в терминах так называемого теста разделяющей оси. Этот тест подробно обсуждается в главе 5, но здесь достаточно отметить, что два OBB разделяются, если по отношению к некоторой оси L сумма их радиусов меньше, чем расстояние между проекциями их центральных точек (как показано на рисунке 4.9). То есть, если

$$|T · L| > r_A + r_B$$

Для OBB можно показать, что не более 15 из этих разделяющих осей должны быть протестированы, чтобы правильно определить статус перекрытия OBB. Эти оси соответствуют трем координатным осям A, трем координатным осям B и девяти осям, перпендикулярным каждой оси. Если блоки не пересекаются ни по одной из 15 осей, они не пересекаются. Если ни одна из осей не обеспечивает этого раньше, значит, блоки должны перекрываться.

Количество операций в тесте можно уменьшить, выразив $B$ в системе координат $A$. Если **t** - вектор перевода из $A$ в $B$ и $R = r_{ij}$ (матрица вращения, переводящая $B$ в систему координат $A$), тесты, которые необходимо выполнить для различных осей $L$, сведены в Таблицу 4.1.

**Таблица 4.1** 15 тестов разделительных осей, необходимых для определения пересечения OBB-OBB. Верхние индексы указывают, из какого OBB берется значение.

Этот тест можно реализовать следующим образом:

```
int TestOBBOBB(OBB &a, OBB &b) {
    float ra, rb;
    Matrix33 R, AbsR;
    // Вычислить матрицу вращения, выражающую b в системе координат a
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            R[i][j] = Dot(a.u[i], b.u[j]);
    // Вычислить вектор переноса t
    Vector t = b.c - a.c;
    // Перенос в систему координат
    t = Vector(Dot(t, a.u[0]), Dot(t, a.u[2]), Dot(t, a.u[2]));
    // Вычислить общие подвыражения. Добавить термин эпсилон, 
    // чтобы противодействовать арифметическим ошибкам, когда два ребра параллельны 
    // и их перекрестное произведение (почти) равно нулю (подробности см. в тексте)
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            AbsR[i][j] = Abs(R[i][j]) + EPSILON;
    // Тест осей L = A0, L = A1, L = A2
    for (int i = 0; i < 3; i++) {
        ra = a.e[i];
        rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];
        if (Abs(t[i]) > ra + rb) return 0;
    }
    // Тест осей L = B0, L = B1, L = B2
    for (int i = 0; i < 3; i++) {
        ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];
        rb = b.e[i];
        if (Abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return 0;
    }
    // Тест оси L = A0 x B0
    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];
    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];
    if (Abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return 0;
    
    // Тест оси L = A0 x B1
    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];
    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];
    if (Abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return 0;

    // Тест оси L = A0 x B2
    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];
    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];
    if (Abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return 0;

    // Тест оси L = A1 x B0
    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];
    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];
    if (Abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return 0;

    // Тест оси L = A1 x B1
    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];
    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];
    if (Abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return 0;

    // Тест оси L = A1 x B2
    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];
    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];
    if (Abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return 0;

    // Тест оси L = A2 x B0
    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];
    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];
    if (Abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return 0;

    // Тест оси L = A2 x B1
    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];
    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];
    if (Abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return 0;

    // Тест оси L = A2 x B2
    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];
    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];
    if (Abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return 0;

    // Поскольку разделительная ось не найдена, OBB должны пересекаться
    return 1;
}
```

Чтобы сделать тест OBB-OBB как можно более эффективным, важно, чтобы оси проверялись в порядке, указанном в таблице 4.1. Первая причина для использования этого порядка заключается в том, что при тестировании сначала трех ортогональных осей в тестах мало пространственной избыточности, и все пространство быстро покрывается. Во-вторых, с настройкой, приведенной здесь, где A преобразуется в начало координат и выравнивается с осями системы координат, проверка осей A составляет примерно половину стоимости проверки осей B. Хотя здесь это не делается, вычисления **R** и **AbsR** следует чередовать с первыми тремя тестами, чтобы они не выполнялись без необходимости полностью, когда тест OBB завершается в одном из первых нескольких операторов if.

Если OBB используются в приложениях, в которых они часто имеют тенденцию иметь одну ось, выровненную с текущим миром вверх, например, при путешествии по земле, стоит использовать специальные кожухи для этих «вертикально выровненных» OBB. Это упрощение позволяет проводить гораздо более быстрый тест на пересечение, который включает в себя тестирование только четырех разделяющих осей в дополнение к дешевому тесту в вертикальном направлении.

В некоторых случаях выполнение только первых 6 из 15 осевых тестов может привести к более быстрым результатам. В эмпирических тестах [Bergen97] обнаружил, что последние 9 тестов в коде перекрытия OBB определяют непересечение примерно в 15% случаев. Поскольку, возможно, половина всех запросов с самого начала являются положительными, пропуск этих 9 тестов приводит к ложноположительным результатам примерно в 6–7% случаев. Когда тест OBB выполняется как предварительный тест для точного теста на ограниченную геометрию, тест по-прежнему остаётся точным, и никакие столкновения не пропускаются.

### 4.4.2 Повышение надежности теста разделительной оси

Очень важным вопросом, который упускают из виду в некоторых популярных трактовках теоремы о разделяющей оси, является надежность теста. К сожалению, любой код, реализующий этот тест, должен быть очень тщательно разработан, чтобы работать так, как задумано. Когда разделяющая ось формируется путем взятия поперечного произведения ребра из каждого ограничивающего прямоугольника, существует вероятность, что эти ребра параллельны. В результате их векторное произведение является нулевым вектором, все проекции на этот нулевой вектор равны нулю, а сумма произведений с каждой стороны неравенства оси равна нулю. Остается сравнение 0 > 0. В идеальном мире точной арифметической математики это выражение было бы тривиально ложно. В действительности, любая компьютерная реализация должна иметь дело с неточностями, вызванными использованием арифметики с плавающей запятой.

Для оптимизированных неравенств, представленных ранее, случай параллельных ребер соответствует только нулевым элементам матрицы вращения **R**, на которую делается ссылка. Теоретически это еще приводит к сравнению 0 > 0. Однако на практике из-за накопления ошибок матрица вращения не будет идеально ортонормированной, и ее нулевые элементы не будут точно равны нулю. Таким образом, сумма произведений по обе стороны неравенства тоже будет не нулем, а некоторой небольшой ошибкой. Поскольку такое накопление ошибок может привести к изменению знака или сдвигу величины любой из сторон неравенства, результат будет совершенно случайным. Следовательно, если тесты на неравенство не будут выполняться очень тщательно, эти арифметические ошибки могут привести к тому, что (почти) нулевой вектор неправильно интерпретируется как разделительная ось. Таким образом, два перекрывающихся OBB могут ошибочно считаться непересекающимися.

Поскольку правая часть неравенств должна быть больше, когда два OBB взаимопроникают, простое решение проблемы состоит в добавлении небольшого эпсилон-значения к абсолютным значениям матричных элементов, встречающихся в правой части неравенств. Для близких к нулю членов этот эпсилон-член будет доминирующим, и тесты осей, соответствующие (почти) параллельным рёбрам, таким образом, становятся непропорционально консервативными. Для других, отличных от нуля случаев, маленький эпсилон-член просто исчезнет. Обратите внимание, что, поскольку абсолютные значения компонентов матрицы вращения ограничены диапазоном [0, 1], использование эпсилона фиксированной величины отлично работает независимо от размеров задействованных блоков. Устойчивость теста разделяющей оси еще раз рассматривается в главе 5.

### 4.4.3 Вычисление жесткого OBB

**Рисунок 4.10** (а) плохо выровненный и (б) хорошо выровненный OBB.

Вычисление плотно подогнанных ориентированных ограничивающих параллелипипедов - сложная проблема, усугубляемая тем фактом, что разница в объеме между плохо выровненным и хорошо выровненным OBB может быть довольно большой (рисунок 4.10). Существует алгоритм вычисления ограничивающего параллелипипеда минимального объема многогранника, представленный в [O’Rourke85]. Ключевое наблюдение, лежащее в основе алгоритма, заключается в том, что для данного многогранника либо одна грань и одно ребро, либо три ребра многогранника будут на разных гранях его ограничивающего прямоугольника. Таким образом, эти конфигурации ребер и граней можно искать систематическим образом, что дает алгоритм $O(n^3)$. Хотя это интересный теоретический результат, к сожалению, алгоритм слишком сложный и слишком медленный, чтобы иметь большую практическую ценность.

Два других теоретических алгоритма для вычисления близких аппроксимаций ограничивающего параллелипипеда минимального объема представлены в [Barequet99]. Однако авторы признают, что эти алгоритмы, вероятно, слишком сложно реализовать и даже в этом случае будут непрактичными из-за больших накладных расходов на постоянный коэффициент в алгоритмах. Таким образом, с доступными в настоящее время теоретическими алгоритмами, мало пригодными для практического использования, OBB должны быть вычислены с использованием либо приближенных методов, либо методом перебора.

Более простой алгоритм, предложенный в [Barequet99] обеспечивает грубую аппроксимацию оптимального OBB для набора точек, сначала вычисляя минимальный AABB набора. Из набора точек выбирается пара точек на двух параллельных сторонах параллелипипеда, наиболее удаленных друг от друга, чтобы определить направление длины OBB. Затем набор точек проецируется на плоскость, перпендикулярную направлению длины OBB. Та же процедура теперь применяется снова, только на этот раз вычисляется минимальный выровненный по оси прямоугольник с точками на двух параллельных сторонах, наиболее удаленными друг от друга, определяющими вторую ось для OBB. Третья ось OBB перпендикулярна первым двум осям. Хотя этот алгоритм очень легко закодировать, на практике ограничивающие параллелипипеды, намного более близкие к оптимальным, могут быть получены с помощью других алгоритмов аналогичной сложности, как описано ниже.

Для длинных и тонких объектов ось OBB должна быть совмещена с направлением объектов. Для плоского объекта ось OBB должна быть выровнена по нормали к плоскому объекту. Эти направления соответствуют основным направлениям объектов, и здесь можно использовать анализ главных компонент, используемый в разделе 4.3.3.

Вычисление ограничивающих параллелипипедов на основе ковариации вершин модели обычно удовлетворительно работает для моделей, вершины которых равномерно распределены в пространстве модели. К сожалению, влияние внутренних точек часто искажает ковариацию и может заставить OBB принять любую ориентацию независимо от экстремальных точек. По этой причине в идеале следует избегать всех методов вычисления ограничивающих объемов, основанных на взвешивании позиций вершин. Достаточно отметить, что все определяющие характеристики (центр, размеры и ориентация) минимального ограничивающего объема не зависят от кластеризации вершин объекта. Это легко увидеть, добавив (или убрав) лишние вершины вне центра, внутри или на границе ограничивающего объема. Эти действия не влияют на определяющие характеристики объема и, следовательно, не должны влиять на его расчет. Однако добавление дополнительных точек таким образом изменяет ковариационную матрицу точек и, следовательно, любые характеристики OBB, непосредственно вычисленные из матрицы. Ситуацию можно улучшить, рассматривая только экстремальные точки, используя только те точки на выпуклой оболочке модели. Это устраняет внутренние точки, которые больше не могут смещать OBB. Однако даже если все оставшиеся точки являются экстремальными, результирующий OBB все равно может быть сколь угодно плохим из-за распределения точек. Группирование точек по-прежнему будет смещать ось в сторону кластера. Другими словами, использование одних только вершин просто не может дать надежных ковариационных матриц.

Предлагаемое решение - использовать непрерывную формулировку ковариации, вычисляя ковариацию по всей поверхности примитивов [Gottschalk00]. Для расчетов все же следует использовать выпуклую оболочку. В противном случае небольшая внешняя геометрия расширила бы ограничивающую рамку, но не внесла бы достаточного значения для правильного выравнивания рамки. Кроме того, внутренняя геометрия все равно будет искажать ковариацию. Если выпуклая оболочка уже доступна, этот алгоритм $O(n)$. Если необходимо вычислить выпуклую оболочку, она равна $O(n \log n)$.

Даны n треугольников $p_k, q_k, r_k, 0 ≤ k < n$, в выпуклой оболочке ковариационная матрица имеет вид

$$C_{ij}=\Bigl(\frac{1}{a_H}\sum_{0 ≤ k < n}\frac{a_k}{12}(9m_{k,i} m_{k,j} + p_{k,i} p_{k,j} + q_{k,i} q_{k,j} + r_{k,i} r_{k,j})\Bigr) − m_{H,i} m_{H,j} ,$$

<!-- 
$$\Bigl(\bigl\{\{ | \}|\bigr \}|\Bigr)$$
-->

где $a_k = |(q_k − p_k) × (r_k − p_k)|/2$ это площадь и $m_k = (p_k + q_k + r_k)/3$ центр тяжести треугольника k.

Общая площадь выпуклой оболочки определяется выражением

$$a_H = \sum_{0 ≤ k < n} a_k ,$$

и центр тяжести выпуклой оболочки,

$$m_H =\frac{1}{a_H}\sum_{0 ≤ k < n} a_k m_k ,$$

вычисляется как среднее значение центроидов треугольников, взвешенных по их площади. Индексы i и j указывают, какой компонент координат взят (то есть x, y или z). Код для этого расчета можно найти в общедоступном пакете обнаружения столкновений RAPID. Несколько другая формулировка этой ковариационной матрицы приведена в [Eberly01],
и код доступен на прилагаемом компакт-диске к этой книге.

Только что описанный метод рассматривает многогранник как полое тело, вычисляя ковариационную матрицу по площадям поверхности. Родственный метод, рассматривающий многогранник как твердое тело, описан в [Mirtich96a]. Учитывая предполагаемый многогранник однородной плотности, алгоритм массовых свойств многогранника Миртиха интегрирует по объему многогранника, вычисляя его тензор инерции 3 × 3 (также известный как матрица инерции или массы). Собственные векторы этой симметричной матрицы называются главными осями инерции, а собственные значения - главными моментами инерции. Как и в случае с ковариационными матрицами ранее, метод Якоби может использоваться для извлечения этих осей, которые, в свою очередь, могут затем служить в качестве матрицы ориентации OBB. Подробный псевдокод для вычисления матрицы инерции приведен в статье Миртича. Реализация общедоступного домена на языке C также доступна для загрузки в Интернете. Возвращение к статье Миртича [Eberly03], в котором получен более эффективный с вычислительной точки зрения подход и для которого предоставляется псевдокод.

Обратите внимание, что ни ковариационно-ориентированные, ни ориентированные по инерции ограничивающие параллелипипеды не являются оптимальными. Рассмотрим объект A и связанный с ним OBB B. Пусть A будет расширен добавлением к нему некоторой геометрии, но оставаясь в пределах B. Для обоих методов это, как правило, приведет к другому OBB B' для нового объекта A'. По построению B и B' оба покрывают два объекта A и A'. Однако, поскольку размеры двух OBB в общем случае различны, один OBB должен быть неоптимальным.

### 4.4.4 Оптимизация OBB на основе PCA

Поскольку OBB с выравниванием по ковариации не являются оптимальными, есть основания полагать, что их можно улучшить с помощью небольших модификаций. Например, возможно, OBB можно было бы повернуть вокруг одной из своих осей, чтобы найти ориентацию, для которой его объем наименьший. Один из улучшенных подходов к подгонке OBB - выровнять блок только по одному основному компоненту. Остальные два направления определяются из вычисленного ограничивающего прямоугольника с минимальной площадью проекции всех вершин на перпендикулярную плоскость к выбранной оси. Фактически, этот метод определяет наилучшее вращение вокруг данной оси для получения OBB наименьшего объема.

Такой подход был предложен в [Barequet96], в котором были исследованы три различных метода.

- Параллелипипед всех главных компонент
- Параллелипипед max-главных компонент
- Параллелипипед min-главных компонент

«Параллелипипед всех главных компонент» использует все три основных компонента для выравнивания OBB и эквивалентен методу, представленному в предыдущем разделе. Для параллелипипеда максимальных главных компонент собственный вектор, соответствующий наибольшему собственному значению, выбирается как длина OBB. Затем все точки проецируются на плоскость, перпендикулярную этому направлению. После проекции вычисляется ограничивающий прямоугольник с минимальной площадью проецируемых точек, определяющий оставшиеся два направления OBB. Наконец, блок min-главных компонент выбирает самый короткий главный компонент в качестве начального направления OBB, а затем действует, как в предыдущем методе. На основании эмпирических результатов [Barequet96]
сделал вывод, что метод минимальной главной компоненты работает лучше всего. Также приводится убедительная причина, по которой max-главных компонент не работает лучше: поскольку максимальная главная компонента - это направление с максимальной дисперсией, она будет давать максимально длинный край и, следовательно, вероятно, приведет к большему объему.

Локальный минимальный объем может быть достигнут повторением этого метода для данного начального OBB. Процедура проецирует все вершины на плоскость, перпендикулярную одному из направлений OBB, обновляя OBB для выравнивания с ограничивающим прямоугольником минимальной площади проекции. Итерации будут повторяться до тех пор, пока никакая проекция (вдоль любого направления OBB) не даст улучшения, после чего локальный минимум не будет найден. Этот метод служит отличной оптимизацией блоков, вычисляемых другими методами, такими как метод Миртиха, когда выполняется в качестве этапа предварительной обработки.

Остается проблема вычисления ограничивающего прямоугольника с минимальной площадью набора точек на плоскости. Ключевой вывод здесь сделан из области вычислительной геометрии. Он утверждает, что ограничивающий прямоугольник с минимальной площадью выпуклого многоугольника имеет (по крайней мере) одну сторону, коллинеарную ребру многоугольника [Freeman75].

Таким образом, минимальный прямоугольник можно легко вычислить с помощью простого алгоритма. Сначала вычисляется выпуклая оболочка набора точек, в результате чего получается выпуклый многоугольник. Затем ребро многоугольника рассматривается как одно направление ограничивающего параллелипипеда. Получается перпендикуляр к этому направлению, и все вершины многоугольника проецируются на эти две оси, и вычисляется площадь прямоугольника. Когда все ребра многоугольника были протестированы, ребро (и его перпендикуляр), дающий наименьшую площадь, определяет направления ограничивающего прямоугольника с минимальной площадью. Для каждого рассматриваемого ребра площадь прямоугольника вычисляется за время $O(n)$, общая сложность алгоритма в целом составляет $O(n^2)$. Этот алгоритм может быть реализован следующим образом:

```
    // Вычислить центральную точку, ’c’, и ориентацию оси, u[0] и u[1], 
    // прямоугольника минимальной площади в плоскости xy, содержащего точки pt[].
    float MinAreaRect(Point2D pt[], int numPts, Point2D &c, Vector2D u[2]) {
        float minArea = FLT_MAX;
        // Пройти все рёбра; j отстает от i на 1 по модулю numPts
        for (int i = 0, j = numPts - 1; i < numPts; j = i, i++) {
            // Получить текущее ребро e0 (e0x,e0y), нормализовать
            Vector2D e0 = pt[i] - pt[j];
            e0 /= Length(e0);
            // Получить ось e1, перпендикулярную ребру e0
            Vector2D e1 = Vector2D(-e0.y, e0.x); // = Perp2D(e0)
            // Цикл по всем точкам, чтобы получить максимальные размеры
            float min0 = 0.0f, min1 = 0.0f, max0 = 0.0f, max1 = 0.0f;
            for (int k = 0; k < numPts; k++) {
                // Спроецировать точки на оси e0 и e1 и отслеживать 
                // минимальные и максимальные значения по двум осям
                Vector2D d = pt[k] - pt[j];
                float dot = Dot2D(d, e0);
                if (dot < min0) min0 = dot;
                if (dot > max0) max0 = dot;
                dot = Dot2D(d, e1);
                if (dot < min1) min1 = dot;
                if (dot > max1) max1 = dot;
            }
            float area = (max0 - min0) * (max1 - min1);
            // Если пока что лучше, запомнить площадь, центр и оси
            if (area < minArea) {
                minArea = area;
                c = pt[j] + 0.5f * ((min0 + max0) * e0 + (min1 + max1) * e1);
                u[0] = e0; u[1] = e1;
            }
        }
        return minArea;
    }
```

Прямоугольник, ограничивающий минимальную площадь выпуклого многоугольника, также можно вычислить за время $O(n \log n)$, используя метод *вращающихся измерителей* [Toussaint83]. Алгоритм вращающихся измерителей начинается с ограничения многоугольника четырьмя линиями через крайние точки многоугольника, так что линии определяют прямоугольник. Выбирается хотя бы одна линия, совпадающая с ребром многоугольника. Для каждой итерации алгоритма линии одновременно поворачиваются по часовой стрелке вокруг своих опорных точек, пока линия не совпадет с ребром многоугольника. Теперь линии образуют новый ограничивающий прямоугольник вокруг многоугольника. Процесс повторяется до тех пор, пока линии не будут повернуты на угол 90 градусов от их первоначальной ориентации. Ограничивающий прямоугольник с минимальной площадью соответствует прямоугольнику с наименьшей площадью, определяемым линиями на всех итерациях. Временная сложность алгоритма ограничена стоимостью вычисления выпуклой оболочки. Если она уже доступна, то сложность $O(n)$.

### 4.4.5 Установка OBB методом перебора

Последний рассмотренный здесь подход к подгонке OBB - это просто вычисление OBB брутфорсом. Один из способов выполнить подгонку методом перебора - каким-либо образом параметризовать ориентацию OBB. Пространство ориентаций дискретизируется через равные промежутки времени в процессе параметризации, и сохраняется лучший OBB для всех выбранных вращений. Затем ориентация OBB уточняется путем выборки интервала, в котором был найден лучший OBB при более высоком разрешении субинтервалов. Этот подход к восхождению на холм повторяется с все меньшим и меньшим интервалом разрешения до тех пор, пока не будет практически никакого изменения ориентации для наилучшего OBB.

Для каждой тестируемой системы координат вычисление OBB-кандидата требует преобразования всех вершин в систему координат. Поскольку это преобразование является дорогостоящим, поиск должен завершиться, как только OBB-кандидат станет хуже, чем лучший в настоящее время OBB. Поскольку он дешев в вычислении и имеет относительно хорошее соответствие, OBB, оснащенный PCA, обеспечивает хорошее начальное предположение, увеличивая шансы на раннее отключение во время точечного преобразования [Miettinen02a]. Чтобы еще больше повысить вероятность раннего завершения, (до) шести крайних точек, определяющих предыдущий OBB, должны быть первыми преобразованными вершинами. В [Miettinen02b] сообщается, что более 90% тестов завершаются досрочно с использованием этой оптимизации. Подгонка OBB методом грубой силы обычно приводит к гораздо более точным OBB, чем полученная при подгонке на основе PCA.

Только что описанный подход к восхождению в гору учитывает множество точек выборки в пространстве ориентации перед обновлением лучшего на данный момент OBB. Метод OBB-подгонки на основе оптимизации, описанный в [Lahanas00], поднимается по пространству поиска по одной выборке за раз, но использует технику множественных выборок, чтобы помочь оптимизатору выйти из локальных минимумов.

## 4.5 Ометаемые сферой объёмы

После сфер и параллелипипедов естественно рассматривать цилиндры как ограничивающие объемы.
К сожалению, когда математика проработана, выясняется, что испытание на пересечение для цилиндров довольно дорогое, что делает их менее привлекательными в качестве ограничивающих объемов. Однако, если цилиндр снабжен сферическими торцевыми крышками, результирующий объем цилиндра с крышкой становится более привлекательным ограничивающим объемом. Пусть цилиндр описывается точками A и B (образующими его среднюю ось) и радиусом r. Цилиндр с крышкой был бы объемом, полученным в результате перемещения сферы радиуса r вдоль отрезка AB. Этот объём является частью семейства объёмов, расширений основной сферы.

**Рисунок 4.11** (a) Ометаемая сферой Точка (sphere-swept point, SSP). (b) Ометаемая сферой Линия (sphere-swept line, SSL). (c) Ометаемый сферой Прямоугольник (sphere-swept rectangle, SSR).

Напомним, что тест между двумя сферами вычисляет расстояние между двумя центральными точками, сравнивая результат с суммой радиусов (возведение величин в квадрат, чтобы избежать дорогостоящего квадратного корня). Заменяя центральные точки сферы произвольными внутренними примитивами или средними структурами, можно получить новые ограничивающие объемы. Результирующие объемы эквивалентны охвату внутреннего примитива сферой радиуса r (или, технически, формированию суммы Минковского сферы и примитива). Таким образом, все это семейство ограничивающих объемов вместе называется *ометаемыми сферой объемами* (sphere-swept volumes, SSVs). Все точки на расстоянии r от внутренней медиальной структуры принадлежат SSV. На рисунке 4.11 проиллюстрированы три типа ометаемых сферой объема.

После теста на пересечение сфер тест на пересечение для двух SSV просто сводится к вычислению (возведенного в квадрат) расстояния между двумя внутренними примитивами и его сравнению с (возведенной в квадрат) суммой их объединенных радиусов. Стоимость тестов со сферами полностью определяется стоимостью функции расстояния. Чтобы сделать проверку расстояния как можно более дешевой, внутренние примитивы обычно ограничиваются точками, отрезками линий или прямоугольниками. Результирующие SSV - Ометаемая сферой Точка (SSP), Ометаемая сферой Линия (SSL) и Ометаемый сферой Прямоугольник (SSR) - обычно называются, соответственно, сферами, капсулами и леденцами (lozenge). Последний выглядит как OBB с закругленными углами и краями. Капсулы также называют цилиндрами с крышками или сфероцилиндрами. Структуры данных для капсул и леденцов можно определить следующим образом:

```
    // Region R = { x | (x - [a + (b - a)*t])∧2 <= r } , 0 <= t <= 1
    struct Capsule {
        Point a;
        // Начальная точка отрезка средней линии
        Point b;
        // Конечная точка отрезка средней линии
        float r;
        // Радиус
        };
        // Region R = { x | (x - [a + u[0]*s + u[1]*t]) ∧ 2 <= r } , 0 <= s,t <= 1
        struct Lozenge {
        Point a;     // Начало
        Vector u[2]; // Оси двух рёбер прямоугольника
        float r;     // Радиус
    };
```

Из-за схожести по форме леденцы могут быть жизнеспособной заменой OBB. В условиях непосредственной близости вычисление расстояния леденцов становится менее затратным, чем тест разделительной оси OBB.

### 4.5.1 Пересечение ометаемых сферой объемов

По конструкции все тесты с ометанием сферой могут быть сформулированы одинаково. Сначала вычисляется расстояние между внутренними конструкциями. Затем это расстояние сравнивается с суммой радиусов. Единственная разница между любыми двумя типами тестов с ометанием сфер заключается в расчетах, используемых для вычисления расстояния между внутренними структурами двух объемов. Полезное свойство сферических объемов состоит в том, что вычисление расстояния между внутренними структурами не зависит от того, являются ли внутренние структуры одного типа. Таким образом, можно легко построить тесты смешанного типа или гибридные. Ниже представлены два теста: сфера-капсула и капсула-капсула.

```
    int TestSphereCapsule(Sphere s, Capsule capsule) {
        // Вычислить (возведенное в квадрат) расстояние между центром сферы и отрезком линии капсулы
        float dist2 = SqDistPointSegment(capsule.a, capsule.b, s.c);
        // Если квадрат расстояния меньше квадрата суммы радиусов, они сталкиваются
        float radius = s.r + capsule.r;
        return dist2 <= radius * radius;
    }
```
```
    int TestCapsuleCapsule(Capsule capsule1, Capsule capsule2) {
        // Вычислить (возведенное в квадрат) расстояние между внутренними структурами капсул
        float s, t;
        Point c1, c2;
        float dist2 = ClosestPtSegmentSegment(capsule1.a, capsule1.b,
        capsule2.a, capsule2.b, s, t, c1, c2);
        // Если квадрат расстояния меньше квадрата суммы радиусов, они сталкиваются
        float radius = capsule1.r + capsule2.r;
        return dist2 <= radius * radius;
    }
```

Используемые здесь функции **SqDistPointSegment()** и **ClosestPtSegmentSegment()** находятся в главе 5 (разделы 5.1.2.1 и 5.1.9 соответственно). Тест расстояния для SSR (и, следовательно, путем сокращения, также для SSL и SSP) на основе тестов полупространства приведен в [Larsen99] и [Larsen00].

### 4.5.2 Вычисление ометаемых сферой ограничивающих объемов

Аппарат, необходимый для вычисления SSV, был описан в предыдущих разделах. Например, вычислив главные оси, капсула может быть подогнана с помощью самой длинной оси в качестве длины капсулы. Следующая по длине ось определяет радиус. В качестве альтернативы, длина также может быть подобрана с использованием метода наименьших квадратов для подгонки линии к набору точек. Для SSR будут использоваться все три оси, причем самая короткая ось образует нормаль прямоугольной грани. Смотрите подробнее [Eberly01], [Larsen99], и [Larsen00].

## 4.6 Объемы пересечения полупространства

За исключением сфер, большинство ограничивающих объемов представляют собой выпуклые многогранники. Все эти ограничивающие многогранные объемы могут быть представлены как пересечение набора полупространств, причем плоскости, разделяющие полупространство, совпадают со сторонами ограничивающего объема. Например, AABB и OBB являются пересечением шести полупространств. Тетраэдр - это пересечение четырех полупространств - наименьшее количество полупространств, необходимых для образования замкнутого объема. Как правило, чем больше полупространств используется, тем лучше полученный объем пересечения подходит для объекта. Если ограниченный объект является многогранным, то самый плотный выпуклый ограничивающий объем - это выпуклая оболочка объекта. В этом случае количество граней на корпусе служит практическим верхним пределом того, сколько полупространств необходимо для формирования ограничивающего объема. Выпуклые оболочки являются важными ограничивающими объемами, и подробное рассмотрение алгоритмов обнаружения столкновений для выпуклых оболочек дается в главе 9.

Хотя выпуклые оболочки образуют самые плотные ограничивающие объемы, они не обязательно являются лучшим выбором ограничивающего объема. Некоторые недостатки выпуклых оболочек включают в себя их дороговизну и сложность вычислений, требующие больших объемов памяти для представления и потенциально дорогостоящие операции. Ограничивая количество полупространств, используемых в объеме пересечения, можно сформировать несколько более простых альтернативных ограничивающих объемов. Несколько вариантов описаны в следующих разделах.

**Рисунок 4.12** Плита - это бесконечная область пространства между двумя плоскостями, определяемая нормалью **n** и двумя знаковыми расстояниями от начала координат.

### 4.6.1 Kay–Kajiya объемы на основе плит (Slab)

Объемы Kay–Kajiya, впервые представленные Каем и Каджией для ускорения тестов на пересечение лучей и объектов, представляют собой семейство многосторонних параллелепипедных ограничивающих объемов, основанных на пересечении плит [Kay86]. Плита - это бесконечная область пространства между двумя параллельными плоскостями (Рисунок 4.12). Этот набор плоскостей представлен единичным вектором **n** (нормаль набора плоскостей) и двумя скалярными значениями, дающими знаковое расстояние от начала координат (вдоль **n**) для обеих плоскостей.

```
    // Region R = { (x, y, z) | dNear <= a*x + b*y + c*z <= dFar }
    struct Slab {
        float n[3];  // Нормаль n = (a, b, c)
        float dNear; // Знаковое расстояние от начала координат для ближней плоскости (dNear)
        float dFar;  // Знаковое расстояние от начала координат для дальней плоскости (dFar)
    };
```

Для формирования ограничивающего объема выбирается ряд нормалей. Затем для каждой нормали располагаются пары плоскостей так, чтобы они ограничивали объект с обеих сторон вдоль направления нормали. Для многоугольных объектов положение плоскостей может быть найдено путем вычисления скалярного произведения нормали и каждой вершины объекта. Тогда минимальное и максимальное значения являются необходимыми скалярными значениями, определяющими положения плоскости.

Для образования замкнутого 3D-объема требуется не менее трех плит. И AABB, и OBB являются примерами объемов, образованных на пересечении трех плит. Увеличивая количество плит, можно сделать так, чтобы ограничивающие объемы на основе плиты соответствовали выпуклой оболочке объектов с произвольной плотностью.

Для первоначального применения пересечения лучей быстрая проверка может быть основана на том факте, что параметризованный луч пересекает плиту тогда и только тогда, когда он одновременно находится внутри всех (трех) плит в течение некоторого интервала, или, что эквивалентно, если пересечение интервалов для перекрытие лучей и плит отличное от нуля. Если пары плоскостей имеют одну и ту же нормаль, вычисления могут быть разделены между двумя тестами на пересечение лучей и плоскостей, что повышает производительность теста.

Объемы на основе плит позволяют проводить тесты на быстрое пересечение лучей, разделяя нормали для всех объектов, можно выполнять быстрые объектно-объектные тесты (подробнее об этом в следующем разделе).

### 4.6.2 Дискретно-ориентированные многогранники (Discrete-orientation Polytopes, k-DOPs)

Основанные на той же идее, что и объемы на основе плит Кая–Каджи, объемы, известные как многогранники с дискретной ориентацией (k-DOP) или оболочки фиксированного направления (fixed-direction hulls, FDH), предложенные
[Konečný97] и [Klosowski98]. (Хотя последний, возможно, более описательный термин, первый используется чаще и применяется здесь.) Эти k-DOP представляют собой выпуклые многогранники, почти идентичные объемам на основе плит, за исключением того, что нормали определяются как фиксированный набор осей, общие для всех ограничивающих объемов k-DOP. Нормальные компоненты обычно ограничиваются набором {-1, 0, 1}, а нормали не нормализуются. Эти нормали удешевляют вычисление k-DOP, что важно, поскольку k-DOP необходимо динамически перестраивать. Распределение нормалей между всеми объектами делает хранение k-DOP очень дешевым. Должны быть сохранены только минимальные и максимальные интервалы для каждой оси. Например, 8-DOP становится:

```
    struct DOP8 {
        float min[4]; // Минимальное  расстояние (от начала координат) по осям от 0 до 3
        float max[4]; // Максимальное расстояние (от начала координат) по осям от 0 до 3
    };
```

6-DOP обычно относится к многогранникам с гранями, выровненными по шести направлениям
(±1, 0, 0), (0, ±1, 0), и (0, 0, ±1). Этот 6-DOP, конечно, является AABB, но AABB - это просто особый случай 6-DOP; любой ориентированный ограничивающий параллелипипед можно также описать как 6-DOP. У 8-DOP грани выровнены по восьми направлениям (±1, ±1, ±1) и 12-DOP с 12 направлениями (±1, ±1, 0), (±1, 0, ±1), и (0, ±1, ±1). Пример 2D 8-DOP показан на рисунке 4.13.

14-DOP определяется с использованием комбинированных направлений 6-DOP и 8-DOP. Аналогичным образом формируются 18-DOP, 20-DOP, и 26-DOP. 14-DOP соответствует выровненному по оси прямоугольнику с обрезанными восемью углами. 18-DOP - это AABB, у которого обрезаны 12 рёбер. 18-DOP также называют трибоксом [Crosnier99].

**Рисунок 4.13** 8-DOP для треугольника (3, 1), (5, 4), (1, 5) это {1, 1, 4, −4, 5, 5, 9, 2} для осей (1, 0), (0, 1), (1, 1), (1, −1).

Обратите внимание, что k-DOP - это не просто пересечение плит, а самые плотные плиты, образующие тело. Например, треугольник (0, 0), (1, 0), (0, 1) может быть представлен разными пересечениями плит, но описывает это только один k-DOP. Если и только если плоскости перекрытий имеют общую точку с объемом, образованным пересечением плит, эти плиты определяют k-DOP. Этот критерий герметичности важен, так как тест на пересечение для k-DOP работает не на объеме пересечения, а только на определениях плиты. Без данного ограничения проверка на пересечение была бы совершенно неэффективной.

По сравнению с ориентированными ограничивающими параллелипипедами, тест на пересечение для k-DOP намного быстрее (примерно на порядок), даже для DOP с большим числом элементов, благодаря плоскостям с фиксированным направлением. Что касается хранилища, такой же объем памяти, необходимый для OBB, примерно соответствует объему 14-DOP. k-DOP имеют (вероятно) более плотную посадку, чем OBB, конечно, когда k растет и k-DOP напоминает выпуклую оболочку. Для геометрии, которая плохо совпадает с осями k-DOP, OBB могут быть более тугими. OBB также будет лучше работать в непосредственной близости.

Самый большой недостаток k-DOP состоит в том, что даже если объёмы редко сталкиваются, k-DOP все равно нужно обновлять или «переворачивать». Поскольку эта операция дорогостоящая, по возможности следует избегать операции переворачивания. Обычно это делается путем предварительного тестирования объектов с использованием ограничивающих сфер (без выполнения теста k-DOP, если тест сферы не прошел). В общем, k-DOP работают лучше всего, когда несколько динамических объектов тестируются на многих статических объектах (необходимо обновить несколько k-DOP) или когда один и тот же объект участвует в нескольких тестах (стоимость обновления k-DOP уменьшается по тестам).

Немного другой k-DOP рассматривается в [Zachmann00]. Здесь оси k-DOP выбираются с использованием процесса моделирования отжига, в котором k точек случайным образом распределяются на единичной сфере с учетом того, что для каждой точки P, −P тоже есть в комплекте. Отталкивающая сила между точками используется в качестве температуры отжига.

### 4.6.3 Тест на пересечение k-DOP – k-DOP


```
```

### 4.6.4 Вычисление и настройка k-DOP


```
```

### 4.6.5 Приблизительные тесты на пересечение выпуклой оболочки


```
```

## 4.7 Другие ограничивающие объемы


```
```

## 4.8 Резюме

Ограничивающие объемы - это простые геометрические формы, используемые для инкапсуляции одного или нескольких объектов большей геометрической сложности. Чаще всего в качестве ограничивающих объемов используются сферы и параллелипипеды. Если требуется действительно точная подгонка, можно использовать объемные плиты или выпуклые оболочки. Ограничивающие объемы используются в качестве ранних тестов на пересечение, прежде чем более дорогие тесты будут выполнены на геометрии, заключенной в них. Как обсуждалось в Разделе 4.1, при выборе формы ограничивающего объема приходится сталкиваться с некоторыми трудностями.
При использовании ограничивающих объемов с более точной подгонкой вероятность раннего отклонения увеличивается, но в то же время тест ограничивающего объема становится более дорогим, а требования к памяти для ограничивающего объема возрастают. Как правило, ограничивающие объемы вычисляются на этапе предварительной обработки и, при необходимости, преобразуются с помощью ограниченных объектов во время выполнения, чтобы соответствовать движениям объектов.

В дополнение к подробному описанию наиболее распространенных ограничивающих объемов и того, как их вычислять, в этой главе описывается, как выполнять тесты на однородные пересечения (между объемами одного типа). Эти тесты были задуманы как тизер к главе 5, в которой подробно рассматриваются (разнородные) тесты пересечения и вычисления расстояний между примитивными геометрическими фигурами, такими как прямые и линейные сегменты, сферы, прямоугольники, треугольники, многоугольники и многогранники.


- Морозова В.Д. Введение в анализ.
- Иванова Е.Е. Дифференциальное исчисление функций одного переменного
- Канатников А.Н., Крищенко А.П. Аналитическая геометрия
- Канатников А.Н., Крищенко А.П. Линейная алгебра
- Канатников А.Н., Крищенко А.П., Четвериков В.Н. Дифференциальное исчисление функций - многих переменных
- Зарубин B.C., Иванова Е.Е., Кувыркин Г.Н. Интегральное исчисление функций одного переменного
- Гаврилов В.Р., Иванова Б.Б., Морозова В.Д. Кратные и криволинейные интегралы. Элементы теории поля
- Агафонов С.А., Герман А.Д., Муратова Т.В. Дифференциальные уравнения
- Власова Е.А. Ряды
- Морозова В.Д. Теория функций комплексного переменного
- Волков И.К., Канатников А.Н. Интегральные преобразования и операционное исчисление
- Мартинсон Л.К., Малов Ю.И. Дифференциальные уравнения математической физики
- Власова Е.А., Зарубин B.C., Кувыркин Г.Н. Приближенные методы математической физики
- Аттетков А.В., Галкин С.В., Зарубин B.C. Методы оптимизации
- Ванько В.И., Ермошина О.В., Кувыркин Г.Н. Вариационное исчисление и оптимальное управление
- Печинкин А.В., Тескин О.И., Цветкова Г.М. и др. Теория вероятностей
- Горяинов В.Б., Павлов И.В., Цветкова Г.М. и др. Математическая статистика
- Волков И.К., Зуев С.М., Цветкова Г.М. Случайные процессы
- Белоусов А.И., Ткачев С.Б. Дискретная математика
- Волков И.К., Загоруйко Е.А. Исследование операций
- Зарубин B.C. Математическое моделирование в технике

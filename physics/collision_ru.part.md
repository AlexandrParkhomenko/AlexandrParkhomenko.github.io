

$P = C + x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (оригинальное выражение)

$P − C = x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (перемещение C влево)

$(P − C) · \textbf u_0 = (x \textbf u_0 + y \textbf u_1 + z \textbf u_2 ) · \textbf u_0$ ⇔ (взяв скалярное произведение с $u_0$ с обеих сторон)

$(P − C) · \textbf u_0 = x( \textbf u_0 · \textbf u_0 ) + y( \textbf u_1 ·  \textbf u_0 ) + z( \textbf u_2 · \textbf u_0 )$ ⇔ (расширение выражения скалярного произведения)

$(P − C) · \textbf u_0 = x$ (упрощение использования $\textbf u_0 · \textbf u_0 = 1$, $\textbf u_1 · \textbf u_0 = \textbf u_2 · \textbf u_0 = 0$)

Таким образом, полный набор координат OBB представлен в виде $x = (P − C) · \textbf u_0$ , $y = (P − C) · \textbf u_1$ ,
и $z = (P − C) · \textbf u_2$.

Чтобы вычислить точку R на (или в) B, ближайшую к P, можно применить тот же подход, что и для AABB, выразив P в системе координат OBB как Q, ограничив Q до значений $e_0$, $e_1$ и $e_2$ и повторное выражение Q в мировых координатах. Код для этого следующий.

```cpp
// Для данной точки p вернуть точку q на (или в) OBB b, ближайшую к p
void ClosestPtPointOBB(Point p, OBB b, Point &q){
    Vector d = p - b.c;
    // Начальный результат в центре П-да; делать шаги оттуда
    q = b.c;
    // Для каждой оси OBB...
    for (int i = 0; i < 3; i++) {
        // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра параллелипипеда
        float dist = Dot(d, b.u[i]);
        // Если расстояние больше, чем размер параллелипипеда, зажмите параллелипипеда
        if (dist > b.e[i]) dist = b.e[i];
        if (dist < -b.e[i]) dist = -b.e[i];
        // Изменить это расстояние по оси, чтобы получить мировую координату
        q += dist * b.u[i];
    }
}
```

Математически описанный метод эквивалентен преобразованию точки P в локальную систему координат OBB, вычислению точки на OBB (теперь фактически AABB), ближайшей к преобразованной точке, и преобразованию полученной точки обратно в мировые координаты.

#### 5.1.4.1 Расстояние от точки до OBB

Чтобы получить квадрат расстояния между точкой P и ближайшей точкой на OBB B, предыдущая функция может быть вызвана таким образом:

```cpp
    // Вычислить квадрат расстояния между точкой p и OBB b
    float SqDistPointOBB(Point p, OBB b){
        Point closest;
        ClosestPtPointOBB(p, b, closest);
        float sqDist = Dot(closest - p, closest - p);
        return sqDist;
    }
```
Если нужен только квадрат расстояния, а не ближайшая точка, этот код можно еще больше упростить. Путем проецирования вектора $\textbf v$ из центра B в P на каждую из трех осей OBB получается расстояние d от P до центра параллелипипеда вдоль этой оси. Поскольку оси ортогональны, любое избыточное количество, которое d выходит за пределы параллелипипеда для данной оси, может быть вычислено, возведено в квадрат и добавлено к общему квадрату расстояния P независимо от двух других осей.

```cpp
// Вычислить квадрат расстояния между точкой p и OBB b
float SqDistPointOBB(Point p, OBB b){
    Vector v = p - b.c;
    float sqDist = 0.0f;
    for (int i = 0; i < 3; i++) {
        // Спроецировать вектор от центра параллелипипеда до точки p на каждой оси, получить расстояние
        // p вдоль этой оси, и подсчитать любое превышение расстояния за пределами параллелипипеда
        float d = Dot(v, b.u[i]), excess = 0.0f;
        if (d < -b.e[i])
        excess = d + b.e[i];
        else if (d > b.e[i])
        excess = d - b.e[i];
        sqDist += excess * excess;
    }
    return sqDist;
}
```

#### 5.1.4.2 Ближайшая точка на 3D-прямоугольнике к точке

Определение точки Q на трехмерном прямоугольнике R, ближайшей к данной точке P, фактически эквивалентно задаче поиска ближайшей точки на OBB, поскольку трехмерный прямоугольник можно рассматривать как OBB с нулевой протяженностью по оси z.

Таким образом, прямоугольник определяется центральной точкой C, двумя ортогональными единичными векторами $\textbf u_0$ и $\textbf u_1$, определяющими ориентацию осей x и y R, и двумя скалярными значениями $e_0$ и $e_1$, определяющими пределы полуширины прямоугольника вдоль каждого ось. В этом представлении все точки S, содержащиеся в R, имеют вид $S = C + a \textbf u_0 + b \textbf u_1$ , где $|a| ≤ e 0$ и $b ≤ e_1$ . Выраженная в виде кода, эта прямоугольная структура становится:

```cpp
struct Rect {
Point c;     // center point of rectangle
Vector u[2]; // unit vectors determining local x and y axes for the rectangle
float e[2];  // the halfwidth extents of the rectangle along the axes
};
```

### 5.1.5 Ближайшая точка на Треугольнике к Точке
### 5.1.6 Ближайшая точка на Тетраэдре к Точке
### 5.1.7 Ближайшая точка Выпуклого многогранника к Точке
### 5.1.8 Ближайшие точки двух Линий
### 5.1.9 Ближайшие точки двух линейных участков
#### 5.1.9.1 2D Пересечение Сегментов
### 5.1.10 Ближайшие точки Отрезка линии и Треугольника
### 5.1.11 Ближайшие точки двух Треугольников
## 5.2 Тестирование пересечения примитивов
### 5.2.1 Тест разделяющей оси
#### 5.2.1.1 Устойчивость теста разделяющей оси
### 5.2.2 Тестирование пересечения Сферы и Плоскости
### 5.2.3 Тестирование пересечения Параллелипипеда и Плоскости
### 5.2.4 Тестирование пересечения Конуса и Плоскости
### 5.2.5 Тестирование пересечения Сферы и AABB
### 5.2.6 Тестирование пересечения Сферы и OBB
### 5.2.7 Тестирование пересечения Сферы и Треугольника
### 5.2.8 Тестирование пересечения Сферы и Многоугольника
### 5.2.9 Тестирование пересечения AABB и Треугольника
### 5.2.10 Тестирование пересечения Треугольника и Треугольника
## 5.3 Пересекающиеся линии, лучи и (направленные) сегменты
### 5.3.1 Пересекающиеся Сегмент и Плоскость
### 5.3.2 Пересекающиеся Луч или Сегмент и Сфера
### 5.3.3 Пересекающиеся Луч или Сегмент и Параллелипипед
### 5.3.4 Пересекающиеся Линия и Треугольник
### 5.3.5 Пересекающиеся Линия и Четырехугольник
### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник
### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)
### 5.5.7 Пересечение движущейся сферы относительно AABB
### 5.5.8 Пересечение движущегося AABB относительно AABB
## 5.6 Резюме

---
layout: default
title: "Робототехника"
description: "Физика столкновений на примере свободного физического движка реального времени Эрвина Куманса Bullet"
date: 
---


### 5.3.5 Пересекающиеся Линия и Четырехугольник

Метод тройного скаляра, описанный в предыдущем разделе, можно использовать почти без изменений для вычисления точки R пересечения прямой с четырехугольником ABCD. Предположим, что ABCD выпуклый и задан против часовой стрелки. Тогда точка внутри ABCD должна быть либо внутри треугольника ABC, либо внутри треугольника DAC.

Поскольку ребро CA является общим для обоих треугольников, если это ребро проверяется в первую очередь, его можно использовать, чтобы эффективно различать, внутри какого треугольника R не должно лежать. Например, если R лежит слева от CA, R не может лежать внутри DAC, и, следовательно, нужно проверять только ABC, и проверять только два дополнительных ребра. Если вместо этого R находится справа от CA, должен быть протестирован только DAC, поскольку R не может находиться внутри ABC. Опять же, необходимо проверить только два дополнительных ребра. Случай R, лежащего на CA, может быть произвольно отнесен к любому треугольнику. Независимо от того, лежит ли R слева или справа от CA, в обоих случаях проверяются всего три ребра. С точки зрения операций с плавающей точкой, стоимость пересечения прямой с четырехугольником такая же, как и при пересечении с треугольником !

Для этого теста пересечения невозможно напрямую вернуть барицентрические координаты точки пересечения. Кроме того, необходимо указать, к какому из двух треугольников относятся координаты, или, в качестве альтернативы, координаты всегда должны быть указаны относительно, скажем, ABC, даже если точка пересечения находится внутри DAC. В следующем примере реализации точка пересечения вычисляется внутри функции и возвращается вместо барицентрических координат точки.

### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник

По сравнению с методом, представленным в предыдущем разделе, несколько иной подход к пересечению луча или отрезка прямой с треугольником описан в [Möller97a]. Напомним, что точки (плоскости) треугольника ABC заданы как
T(u, v, w) = uA + vB + wC, где (u, v, w) являются барицентрическими координатами
точки такая, что u + v + w = 1. T находится внутри ABC тогда и только тогда, когда её барицентрические координаты удовлетворяют 0 ≤ u, v, w ≤ 1. В качестве альтернативы, это также может быть написано как
T(v, w) = A + v(B − A) + w(C − A), с u = 1 − v − w. T теперь находится внутри ABC, если v ≥ 0,
w ≥ 0, и v + w ≤ 1.

Пусть направленный отрезок прямой между двумя точками P и Q определен параметрически как R(t) = P + t(Q − P), 0 ≤ t ≤ 1. Установив T(v, w) равно R(t) можно решить для t, v и w, чтобы позже проверить, находятся ли они в границах, необходимых для пересечения:

T(v, w) = R(t) ⇔ (исходное выражение)
A + v(B − A) + w(C − A) = P + t(Q − P) ⇔ (подстановка параметризованных выражений)
(P − Q)t + (B − A)v + (C − A)w = P − A (перестановка членов)

Это система линейных уравнений 3 × 3, и, таким образом, она может быть написана в матрице
Обозначение как

\begin{equation*}
\begin{bmatrix} (P−Q) (B−A) (C−A)
\end{bmatrix}
\begin{bmatrix} t \\ v \\ w
\end{bmatrix} = \begin{bmatrix}(P − A)\end{bmatrix}
\end{equation*}

где векторы даны как векторы-столбцы. Теперь t, v и w могут быть решены с помощью правила Крамера:

$t = [det (P − A) (B − A) (C − A)] / [det (P − Q) (B − A) (C − A)]$
$v = [det (P − Q) (P − A) (C − A)] / [det (P − Q) (B − A) (C − A)]$
$w = [det (P − Q) (B − A) (P − A)] / [det (P − Q) (B − A) (C − A)]$

В виде $det [\textbf a \textbf b \textbf c] = \textbf a · (\textbf b × \textbf c)$, алгебраические тождества для скалярных тройных произведений позволяют упростить эти выражения до

$$t = (P − A) · \textbf n/d$$
$$v = (C − A) · \textbf e/d$$
$$w = −(B − A) · \textbf e/d,$$

где

$$\textbf n = (B − A) × (C − A)$$
$$d = (P − Q) · \textbf n$$
$$\textbf e = (P − Q) × (P − A).$$

Обратите внимание, что если d<0, сегмент направлен от треугольника, а если d=0, сегмент проходит параллельно плоскости треугольника. Следующий код реализует этот вариант пересечения отрезка-треугольника.

```cpp
// Для данного сегмента pq и треугольника abc возвращает, 
// пересекает ли сегмент треугольник, и если да, то также возвращает
// барицентрические координаты (u, v, w) точки пересечения
int IntersectSegmentTriangle(Point p, Point q, Point a, Point b, Point c,
float &u, float &v, float &w, float &t)
{
Vector ab = b - a;
Vector ac = c - a;
Vector qp = p - q;
// Вычислить нормальный треугольник. 
// Может быть предварительно вычислен или кэширован, если несколько 
// сегментов пересекаются с одним и тем же треугольником
Vector n = Cross(ab, ac);
// Вычислить знаменатель d. Если d <= d 0, сегмент параллелен 
// треугольнику или направлен от него, поэтому выйдите пораньше
float d = Dot(qp, n);
if (d <= 0.0f) return 0;
// Вычислить значение t пересечения pq с плоскостью треугольника. 
// Луч пересекает, если 0 <= d t. Сегмент пересекает, 
// если 0 <= d t <= d 1. Задержка деления на d до тех пор, 
// пока не будет найдено пересечение, чтобы пронзить треугольник
Vector ap = p - a;
t = Dot(ap, n);
if (t < 0.0f) return 0;
if (t > d) return 0;
// Для сегмента; исключите эту строку кода для лучевого теста
// Вычислить барицентрические компоненты координат и проверить, находятся ли они в пределах границ
Vector e = Cross(qp, ap);
v = Dot(ac, e);
if (v < 0.0f || v > d) return 0;
w = -Dot(ab, e);
if (w < 0.0f || v + w > d) return 0;
// Сегмент/луч пересекает треугольник. Выполнить отложенное деление и
// вычислить последнюю барицентрическую компоненту координат
float ood = 1.0f / d;
t *= ood;
v *= ood;
w *= ood;
u = 1.0f - v - w;
return 1;
}
```

Эта формулировка немного отличается от приведенной в [Möller97a], поскольку в качестве побочного продукта она вычисляет нормаль $\textbf n$ треугольника ABC, что часто бывает полезно иметь.

Другой способ взглянуть на этот тест - сначала вычислить точку пересечения S между отрезком и плоскостью треугольника. Затем эта точка проверяется на наличие в треугольнике путем вычисления ее барицентрических координат относительно треугольника (как описано в разделе 3.4). Некоторые вычисления при вычислении S и его барицентрических координат могут использоваться совместно, в том числе для нормали плоскости треугольника. Эти расчеты также можно предварительно вычислить и сохранить с помощью треугольника.

Когда предварительные вычисления разрешены, метод может быть дополнительно оптимизирован путем вычисления и сохранения плоских уравнений для плоскости треугольника, а также для того, что можно считать «краевыми плоскостями» треугольника (три плоскости, перпендикулярные плоскости треугольника, через каждый из краев, как показано на рисунке 5.25). Масштабируя уравнения краевой плоскости так, чтобы они сообщали расстояние, равное единице для противоположной вершины треугольника (не на краевой плоскости), оценка уравнений краевой плоскости для S напрямую дает барицентрические координаты S (относительно противоположного треугольника вершина). Обратите внимание, что необходимо сохранить только две из трех краевых плоскостей, поскольку третья барицентрическая координата получается непосредственно из двух других. Тест сегмент-треугольник теперь может быть реализован в четырех вычислениях уравнения плоскости (плюс несколько случайных операций), примером которых является следующий код.

**Рисунок 5.25.** «Плоскости ребер» треугольника ABC, перпендикулярные плоскости ABC и проходящие через ребра ABC.

```cpp
struct Triangle {
Plane p;           // Уравнение плоскости для плоскости треугольника треугольника
Plane edgePlaneBC; // При оценке дает барицентрический вес u (для вершины A)
Plane edgePlaneCA; // При оценке дает барицентрический вес v (для вершины B)
};

// Для данного сегмента pq и предварительно вычисленного треугольника tri 
// возвращает, пересекает ли сегмент треугольник. Если это так, также возвращает 
// барицентрические координаты (u, v, w) точки пересечения s и 
// параметризованное значение пересечения t
int IntersectSegmentTriangle(Point p, Point q, Triangle tri,
float &u, float &v, float &w, float &t, Point &s)
{
// Вычислить расстояние p до плоскости треугольника. Выйти, если p лежит за плоскостью
float distp = Dot(p, tri.p.n) – tri.p.d;
if (distp < 0.0f) return 0;
// Вычислить расстояние q до плоскости треугольника. Выйти, если q лежит перед плоскостью
float distq = Dot(q, tri.p.n) – tri.p.d;
if (distq >= 0.0f) return 0;
// Вычислить значение t и точку s пересечения с плоскостью треугольника
float denom = distp – distq;
t = distp / denom;
s = p + t * (q – p);
// Вычислить барицентрическую координату u; выйти, если за пределами диапазона 0..1
u = Dot(s, tri.edgePlaneBC.n) – tri.edgePlaneBC.d;
if (u < 0.0f || u > 1.0f) return 0;
// Вычислить барицентрическую координату v; выход, если отрицательна
v = Dot(s, tri.edgePlaneCA.n) – tri.edgePlaneCA.d;
if (v < 0.0f) return 0;
// Вычислить барицентрическую координату w; выход, если отрицательна
w = 1.0f – u – v;
if (w < 0.0f) return 0;
// Сегмент пересекает tri на расстоянии t в позиции s (s = u*A + v*B + w*C)
return 1;
}
```

Путем умножения на **denom** можно отложить (часто дорогое) деление до тех пор, пока не будет найден сегмент, действительно пересекающий треугольник. Для треугольника ABC структуру треугольника **tri** можно инициализировать следующим образом.

```cpp
Triangle tri;
Vector n = Cross(b – a, c – a);
tri.p = Plane(n, a);
tri.edgePlaneBC = Plane(Cross(n, c – b), b);
tri.edgePlaneCA = Plane(Cross(n, a – c), c);
```

Чтобы граничные плоскости вычисляли барицентрические координаты точки, для которой они вычисляются, они должны быть масштабированы, чтобы вернуть расстояние, равное единице для противоположной вершины треугольника (не на плоскости).

```cpp
tri.edgePlaneBC *= 1.0f / (Dot(a, tri.edgePlaneBC.n) – tri.edgePlaneBC.d);
tri.edgePlaneCA *= 1.0f / (Dot(b, tri.edgePlaneCA.n) – tri.edgePlaneCA.d);
```

Теперь запись треугольника полностью инициализирована и может быть сохранена. Обратите внимание, что для выполнения теста на пересечение вершины треугольника не требуются. Для этой записи треугольника требуется 12 компонентов с плавающей точкой по сравнению с девятью компонентами с плавающей точкой, необходимыми для хранения трех вершин треугольника, которые использовались в исходном методе.

### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)

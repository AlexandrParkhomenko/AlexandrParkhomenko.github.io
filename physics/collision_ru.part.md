---
layout: default
title: "Робототехника"
description: "Физика столкновений на примере свободного физического движка реального времени Эрвина Куманса Bullet"
date: 
---


$P = C + x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (оригинальное выражение)

$P − C = x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (перемещение C влево)

$(P − C) · \textbf u_0 = (x \textbf u_0 + y \textbf u_1 + z \textbf u_2 ) · \textbf u_0$ ⇔ (взяв скалярное произведение с $u_0$ с обеих сторон)

$(P − C) · \textbf u_0 = x( \textbf u_0 · \textbf u_0 ) + y( \textbf u_1 ·  \textbf u_0 ) + z( \textbf u_2 · \textbf u_0 )$ ⇔ (расширение выражения скалярного произведения)

$(P − C) · \textbf u_0 = x$ (упрощение использования $\textbf u_0 · \textbf u_0 = 1$, $\textbf u_1 · \textbf u_0 = \textbf u_2 · \textbf u_0 = 0$)

Таким образом, полный набор координат OBB представлен в виде $x = (P − C) · \textbf u_0$ , $y = (P − C) · \textbf u_1$ ,
и $z = (P − C) · \textbf u_2$.

Чтобы вычислить точку R на (или в) B, ближайшую к P, можно применить тот же подход, что и для AABB, выразив P в системе координат OBB как Q, ограничив Q до значений $e_0$, $e_1$ и $e_2$ и повторное выражение Q в мировых координатах. Код для этого следующий.

```cpp
// Для данной точки p вернуть точку q на (или в) OBB b, ближайшую к p
void ClosestPtPointOBB(Point p, OBB b, Point &q){
    Vector d = p - b.c;
    // Начальный результат в центре П-да; делать шаги оттуда
    q = b.c;
    // Для каждой оси OBB...
    for (int i = 0; i < 3; i++) {
        // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра параллелипипеда
        float dist = Dot(d, b.u[i]);
        // Если расстояние больше, чем размер параллелипипеда, зажмите параллелипипеда
        if (dist > b.e[i]) dist = b.e[i];
        if (dist < -b.e[i]) dist = -b.e[i];
        // Изменить это расстояние по оси, чтобы получить мировую координату
        q += dist * b.u[i];
    }
}
```

Математически описанный метод эквивалентен преобразованию точки P в локальную систему координат OBB, вычислению точки на OBB (теперь фактически AABB), ближайшей к преобразованной точке, и преобразованию полученной точки обратно в мировые координаты.

#### 5.1.4.1 Расстояние от точки до OBB

Чтобы получить квадрат расстояния между точкой P и ближайшей точкой на OBB B, предыдущая функция может быть вызвана таким образом:

```cpp
    // Вычислить квадрат расстояния между точкой p и OBB b
    float SqDistPointOBB(Point p, OBB b){
        Point closest;
        ClosestPtPointOBB(p, b, closest);
        float sqDist = Dot(closest - p, closest - p);
        return sqDist;
    }
```
Если нужен только квадрат расстояния, а не ближайшая точка, этот код можно еще больше упростить. Путем проецирования вектора $\textbf v$ из центра B в P на каждую из трех осей OBB получается расстояние d от P до центра параллелипипеда вдоль этой оси. Поскольку оси ортогональны, любое избыточное количество, которое d выходит за пределы параллелипипеда для данной оси, может быть вычислено, возведено в квадрат и добавлено к общему квадрату расстояния P независимо от двух других осей.

```cpp
// Вычислить квадрат расстояния между точкой p и OBB b
float SqDistPointOBB(Point p, OBB b){
    Vector v = p - b.c;
    float sqDist = 0.0f;
    for (int i = 0; i < 3; i++) {
        // Спроецировать вектор от центра параллелипипеда до точки p на каждой оси, получить расстояние
        // p вдоль этой оси, и подсчитать любое превышение расстояния за пределами параллелипипеда
        float d = Dot(v, b.u[i]), excess = 0.0f;
        if (d < -b.e[i])
        excess = d + b.e[i];
        else if (d > b.e[i])
        excess = d - b.e[i];
        sqDist += excess * excess;
    }
    return sqDist;
}
```

#### 5.1.4.2 Ближайшая точка на 3D-прямоугольнике к точке

Определение точки Q на трехмерном прямоугольнике R, ближайшей к данной точке P, фактически эквивалентно задаче поиска ближайшей точки на OBB, поскольку трехмерный прямоугольник можно рассматривать как OBB с нулевой протяженностью по оси z.

Таким образом, прямоугольник определяется центральной точкой C, двумя ортогональными единичными векторами $\textbf u_0$ и $\textbf u_1$, определяющими ориентацию осей x и y R, и двумя скалярными значениями $e_0$ и $e_1$, определяющими пределы полуширины прямоугольника вдоль каждого ось. В этом представлении все точки S, содержащиеся в R, имеют вид $S = C + a \textbf u_0 + b \textbf u_1$ , где $|a| ≤ e 0$ и $b ≤ e_1$ . Выраженная в виде кода, эта прямоугольная структура становится:

```cpp
struct Rect {
Point c;     // центральная точка прямоугольника
Vector u[2]; // единичные векторы, определяющие локальные оси x и y для прямоугольника
float e[2];  // размеры полуширины прямоугольника по осям
};
```

Переписывание кода **ClosestPtPointOBB()** для учета оси z нулевой протяженности приводит к следующему коду для поиска ближайшей точки на 3D прямоугольнике.

```cpp
    // Для данной точки p вернуть точку q на (или в) прямоугольнике r, ближайшем к p
    void ClosestPtPointRect(Point p, Rect r, Point &q){
        Vector d = p - r.c;
        // Начальный результат в центре прямоугольника; делать шаги оттуда
        q = r.c;
        // Для каждой оси прямоугольника...
        for (int i = 0; i < 2; i++) {
            // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра прямоугольника
            float dist = Dot(d, r.u[i]);
            // Если расстояние больше, чем размеры прямоугольника, зажмите прямоугольник
            if (dist > r.e[i]) dist = r.e[i];
            if (dist < -r.e[i]) dist = -r.e[i];
            // Изменить это расстояние по оси, чтобы получить мировую координату
            q += dist * r.u[i];
        }
    }
```

Трехмерный прямоугольник R также может быть задан тремя точками (A, B и C), такими, что векторы B − A и C − A охватитывают прямоугольник. Теперь все точки S в R имеют вид $S = A + u(B − A) + v(C − A)$, $0 ≤ u ≤ 1$, и $0 ≤ v ≤ 1$. В этом сценарии можно использовать аналогичный проекционный подход (но с поправкой на новые интервалы ограничения). Оптимизация реализации для этого случая приводит к следующему коду.


```cpp
// Возвратить точку q на (или в) прямоугольнике (указанном a, b и c), ближайшем к данной точке p
void ClosestPtPointRect(Point p, Point a, Point b, Point c, Point &q){
    Vector ab = b - a; // вектор через прямоугольник
    Vector ac = c - a; // вектор вниз прямоугольника
    Vector d = p - a;
    // Начать результат в верхнем левом углу прямоугольника; делать шаги оттуда
    q = a;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник в поперечном направлении
    float dist = Dot(d, ab);
    float maxdist = Dot(ab, ab);
    if (dist >= maxdist)
    q += ab;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ab;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник был направлен вниз
    dist = Dot(d, ac);
    maxdist = Dot(ac, ac);
    if (dist >= maxdist)
    q += ac;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ac;
}
```

Это немного дороже, чем первоначальный подход, так как он не выигрывает от нормализации векторов поперек и вниз прямоугольника на этапе предварительного вычисления.

### 5.1.5 Ближайшая точка на Треугольнике к Точке

Даны треугольник ABC и точка P, пусть Q описывает точку на ABC, ближайшую к P. Один из способов получить Q - это полагаться на тот факт, что если P ортогонально проецируется внутрь ABC, точка проекции является ближайшей точкой Q. Если P проецируется вне ABC, ближайшая точка должна лежать на одном из его краев. В этом случае Q можно получить, вычислив точку, ближайшую к P для каждого из отрезков AB, BC и CA, и вернув вычисленную точку, ближайшую к P. Хотя это работает, это не очень эффективный подход. Лучшее решение - вычислить, в какой из характерных областей Вороного треугольника P находится.

**Рисунок 5.5**. Область Вороного вершины A, VR(A), является пересечением отрицательных полупространств двух плоскостей $(X – A) · (B – A) = 0$ и $(X – A) · (C – A) = 0$.

После определения необходимо вычислить только ортогональную проекцию P на соответствующий объект, чтобы получить Q.

Чтобы увидеть, как можно определить, что P находится в области Вороного вершины, рассмотрим область Вороного вершины A. Эта область определяется как пересечение отрицательных полупространств двух плоскостей, проходящих через A, одной с нормалью B - A и другой с нормальным C - A (как показано на рисунке 5.5).

Определить, находится ли P в одной из краевых областей Вороного, можно несколькими способами. Оказывается, что эффективный тест состоит в том, чтобы эффективно вычислить барицентрические координаты ортогональной проекции R точки P на ABC. Напомним из раздела 3.4, что барицентрические координаты R задаются как отношения (пропорциональные) площадей со знаком треугольников RAB, RBC и RCA к площади со знаком ABC. Пусть n - нормаль к ABC и пусть $R = P − t \textbf n$ для некоторой t. Барицентрические координаты $(u, v, w)$ для $R, R = uA + vB + wC$, затем можно рассчитать по количеству

```cpp
Vector n = Cross(b - a, c - a);
float rab = Dot(n, Cross(a - r, b - r)); // пропорционально обозначненной области RAB
float rbc = Dot(n, Cross(b - r, c - r)); // пропорционально обозначненной области RBC
float rca = Dot(n, Cross(c - r, a - r)); // пропорционально обозначненной области RCA
float abc = rab + rbc + rca; // пропорционально обозначненной области ABC
```

как $u = rbc/abc$, $v = rca/abc$, и $w = rab/abc$. Однако небольшая векторная арифметика показывает, что эти выражения упрощаются. Например, выражение для rab упрощается следующим образом:

- $\textbf n · ((A − R) × (B − R))$ = (оригинальное выражение)
- $\textbf n · (A × (B − R) − R × (B − R))$ = (раскрытие векторного произведения)
- $\textbf n · (A × B − A × R − R × B)$ = (раскрытие векторного произведения; удаление $\textbf n · (R × R) = 0$ члена)
- $\textbf n · (A × B − A × (P − t \textbf n) − (P − t \textbf n) × B)$ = (замена $R = P − tn$ для $R$)
- $\textbf n · (A × B − A × P + tA × \textbf n − P × B + t \textbf n × B)$ = (раскрытие скалярного произведения)
- $\textbf n · (A × B − A × P − P × B + t \textbf n × (B − A))$ = (группировка аналогичных членов)
- $\textbf n · (A × B − A × P − P × B)$ = (удаление $\textbf n · (t \textbf n × (B − A)) = 0$ члена)
- $\textbf n · ((A − P) × (B − P))$ (объединение векторного произведения после добавления $\textbf n · (P × P) = 0$ члена)

Другими словами, барицентрические координаты R могут быть получены непосредственно из P без вычисления R.

**Рисунок 5.6**. Когда угол в A тупой, P может лежать в области Вороного ребра CA, даже если P лежит вне AB, а не в областях вершины Вороного A или B.

Чтобы $P$ лежал в краевой области Вороного - например, область, соответствующая краю $AB - P$ должна лежать вне или на $AB$, обозначенном $rab ≤ 0$, а также в положительных полупространствах плоскостей $(X - A ) · (B - A)=0$ и $(X - B) · (A - B)=0$. Обратите внимание, что недостаточно просто проверить, находится ли $P$ вне $AB$, в этом случае для треугольника с тупым углом в $A$ , $P$ может находиться вне $AB$ и фактически находиться в области Вороного края $CA$ (рис. 5.6). (Точно так же распространенной ошибкой является предположение, например, что $A$ является ближайшей точкой к $P$, если $P$ лежит вне $AB$ и $(P - A) · (B - A) <0$.) Если $P$ не находится в любой из вершин или ребер Вороного область $Q$ должна лежать внутри $ABC$ и, фактически, ортогональная проекция R, которую теперь можно легко вычислить согласно предыдущему. Этой информации теперь достаточно, чтобы создать кодовое решение.

```cpp
Point ClosestPtPointTriangle(Point p, Point a, Point b, Point c){
    Vector ab = b - a;
    Vector ac = c - a;
    Vector bc = c - b;
    // Вычислить параметрическое положение s для проекции P’ точки P на AB,
    // P’ = A + s*AB, s = snom/(snom+sdenom)
    float snom = Dot(p - a, ab), sdenom = Dot(p - b, a - b);
    // Вычислить параметрическое положение t для проекции P’ точки P на AC,
    // P’ = A + t*AC, s = tnom/(tnom+tdenom)
    float tnom = Dot(p - a, ac), tdenom = Dot(p - c, a - c);
    if (snom <= 0.0f && tnom <= 0.0f) return a;
    // Вершинная область рано ушла
    // Вычислить параметрическое положение u для проекции P’ точки P на BC,
    // P’ = B + u*BC, u = unom/(unom+udenom)
    float unom = Dot(p - b, bc), udenom = Dot(p - c, b - c);
    if (sdenom <= 0.0f && unom <= 0.0f) return b; // Вершинная область рано ушла
    if (tdenom <= 0.0f && udenom <= 0.0f) return c; // Вершинная область рано ушла
    // P находится вне (или на) AB, если тройное скалярное произведение [N PA PB] <= 0
    Vector n = Cross(b - a, c - a);
    float vc = Dot(n, Cross(a - p, b - p));
    // Если P за пределами AB и внутри характерной области AB, 
    // вернуть проекцию P на AB
    if (vc <= 0.0f && snom >= 0.0f && sdenom >= 0.0f)
        return a + snom / (snom + sdenom) * ab;
    // P находится вне (или на) BC, если тройное скалярное произведение [N PB PC] <= 0
    float va = Dot(n, Cross(b - p, c - p));
    // Если P за пределами BC и в пределах характерного региона BC,
    // вернуть проекцию P на BC
    if (va <= 0.0f && unom >= 0.0f && udenom >= 0.0f)
        return b + unom / (unom + udenom) * bc;
    // P находится вне (или на) CA, если тройное скалярное произведение [N PC PA] <= 0
    float vb = Dot(n, Cross(c - p, a - p));
    // Если P за пределами CA и в пределах функционального региона CA,
    // вернуть проекцию P на CA
    if (vb <= 0.0f && tnom >= 0.0f && tdenom >= 0.0f)
        return a + tnom / (tnom + tdenom) * ac;
    // P должен выступать внутри области грани. Вычислить Q, используя барицентрические координаты
    float u = va / (va + vb + vc);
    float v = vb / (va + vb + vc);
    float w = 1.0f - u - v; // = vc / (va + vb + vc)
    return u * a + v * b + w * c;
}
```

В представленном виде этот код содержит четыре вызова векторного произведения. Поскольку вычисление векторных произведений зачастую обходится дороже, чем скалярных произведений, стоит изучить, можно ли их заменить более экономичными выражениями. Оказывается, тождество Лагранжа

$( \textbf a × \textbf b) · ( \textbf c × \textbf d) = ( \textbf a · \textbf c)( \textbf b · \textbf d) − ( \textbf a · \textbf d)( \textbf b ·  \textbf c)$

можно использовать для выражения трех скалярных тройных произведений

```cpp
Vector n = Cross(b - a, c - a);
float va = Dot(n, Cross(b - p, c - p));
float vb = Dot(n, Cross(c - p, a - p));
float vc = Dot(n, Cross(a - p, b - p));
```

с точки зрения шести скалярных произведений

```cpp
float d1 = Dot(b - a, p - a);
float d2 = Dot(c - a, p - a);
float d3 = Dot(b - a, p - b);
float d4 = Dot(c - a, p - b);
float d5 = Dot(b - a, p - c);
float d6 = Dot(c - a, p - c);
```
в качестве

```cpp
float va = d3*d6 - d5*d4;
float vb = d5*d2 - d1*d6;
float vc = d1*d4 - d3*d2;
```

Фактически, эти шесть скалярных произведений, от $\textbf d1$ до $\textbf d6$, также могут использоваться для вычисления членов $\textbf {snom, sdenom, tnom, tdenom, unom}$ и $\textbf {udenom}$:

```cpp
float snom = d1;
float sdenom = -d3;
float tnom = d2;
float tdenom = -d6;
float unom = d4 - d3;
float udenom = d5 - d6;
```

Вектор $\textbf n$ больше не нужен. Это позволяет оптимизировать код до финальной версии.

```cpp
Point ClosestPtPointTriangle(Point p, Point a, Point b, Point c){
    // Проверить, находится ли P в области вершин вне A
    Vector ab = b - a;
    Vector ac = c - a;
    Vector ap = p - a;
    float d1 = Dot(ab, ap);
    float d2 = Dot(ac, ap);
    if (d1 <= 0.0f && d2 <= 0.0f) return a; // барицентрические координаты (1,0,0)
    // Проверить, находится ли P в области вершины вне B
    Vector bp = p - b;
    float d3 = Dot(ab, bp);
    float d4 = Dot(ac, bp);
    if (d3 >= 0.0f && d4 <= d3) return b; // барицентрические координаты (0,1,0)
    // Проверить, находится ли P в краевой области AB, если да, вернуть проекцию P на AB
    float vc = d1*d4 - d3*d2;
    if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f) {
        float v = d1 / (d1 - d3);
        return a + v * ab; // барицентрические координаты (1-v,v,0)
    }
    // Проверить, находится ли P в области вершины вне C
    Vector cp = p - c;
    float d5 = Dot(ab, cp);
    float d6 = Dot(ac, cp);
    if (d6 >= 0.0f && d5 <= d6) return c; // барицентрические координаты (0,0,1)
    // Проверить, находится ли P в краевой области AC, если да, вернуть проекцию P на AC
    float vb = d5*d2 - d1*d6;
    if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f) {
        float w = d2 / (d2 - d6);
        return a + w * ac; // барицентрические координаты (1-w,0,w)
    }
    // Проверить, находится ли P в краевой области BC, если да, вернуть проекцию P на BC
    float va = d3*d6 - d5*d4;
    if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f) {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b); // барицентрические координаты (0,1-w,w)
    }
    // P внутри области грани. Вычислить Q через его барицентрические координаты (u,v,w)
    float denom = 1.0f / (va + vb + vc);
    float v = vb * denom;
    float w = vc * denom;
    return a + ab * v + ac * w; // = u*a + v*b + w*c, u = va * denom = 1.0f - v - w
}
```

Третий способ получить ближайшую точку - использовать метод векторного исчисления, как предложено в [Eberly01]. Вкратце, треугольник ABC параметризован как $T(s, t)=A + s (B - A) + t (C - A)$ , где $s ≥ 0$ , $t ≥ 0$ и $s + t ≤ 1$ . Ближайшая точка до данной точки P теперь соответствует минимуму функции квадрата расстояния

$d (s, t)={\parallel T (s, t) - P \parallel}^2$ , что является квадратичным выражением от $s$ и $t$. Минимум этой функции должен встречаться в одном из трех случаев: в вершине, на ребре или внутри треугольника. Сначала дифференцируя $d(s, t)$ по этим различным случаям (то есть подставляя $s=0$ , $t=0$ или $t=1 - s$, если необходимо), устанавливая производные равными нулю и решая, а затем сравнивая приводя значения $s$ и $t$ к границам треугольника, можно выяснить, какой случай соответствует минимуму.

Для этого конкретного приложения решение векторного исчисления становится более сложным, чем только что описанное. Однако общий подход рассмотрения проблемы как задачи квадратичной минимизации ценен, и ту же идею можно использовать для определения расстояния между, скажем, линией или отрезком линии и треугольником. Дополнительная информация о методе векторного исчисления, включая псевдокод, приведена в [Eberly01].

### 5.1.6 Ближайшая точка на Тетраэдре к Точке

Для точки P проблема заключается в определении точки Q на тетраэдре ABCD (или в нем), ближайшем к P (как показано на рисунке 5.7). Простое решение - вычислить Q, вызвав функцию **ClosestPtPointTriangle()** (определенную в предыдущем разделе) один раз для каждой плоскости грани тетраэдра P. Из всех вычисленных точек ближайшая к P возвращается как Q. Отдельно от расстояния тесты, проводится другой тест, чтобы увидеть, лежит ли P внутри всех плоскостей граней. Когда это произойдет, ближайшая точка - сама точка.

Предполагая, что тетраэдр ABCD определен так, что его грани ABC, ACD, ADB и BDC расположены против часовой стрелки, если смотреть снаружи тетраэдра, это решение может быть реализовано следующим образом.

```cpp
Point ClosestPtPointTetrahedron(Point p, Point a, Point b, Point c, Point d) {
    // Начнём с предположения о точке внутри всех полупространств, которая ближе всего к себе
    Point closestPt = p;
    float bestSqDist = FLT_MAX;
    // Если точка находится за пределами грани abc, вычислить ближайшую точку на abc
    if (PointOutsideOfPlane(p, a, b, c)) {
    Point q = ClosestPtPointTriangle(p, a, b, c);
    float sqDist = Dot(q - p, q - p);
    // Обновить самую близкую точку, если (в квадрате) расстояние меньше текущего лучшего
    if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    // Повторить тест для грани acd
    if (PointOutsideOfPlane(p, a, c, d)) {
        Point q = ClosestPtPointTriangle(p, a, c, d);
        float sqDist = Dot(q - p, q - p);
        if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    // Повторить тест для грани adb
    if (PointOutsideOfPlane(p, a, d, b)) {
        Point q = ClosestPtPointTriangle(p, a, d, b);
        float sqDist = Dot(q - p, q - p);
        if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    // Повторите тест для грани bdc
    if (PointOutsideOfPlane(p, b, d, c)) {
        Point q = ClosestPtPointTriangle(p, b, d, c);
        float sqDist = Dot(q - p, q - p);
        if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    return closestPt;
}
```

Здесь значение **PointOutsideOfPlane(P, A, B, C)** соответствует знаку скалярного тройного произведения векторов P − A, B − A, and C − A.

```cpp
    // Проверить, лежит ли точка p вне плоскости через abc
    int PointOutsideOfPlane(Point p, Point a, Point b, Point c){
        return Dot(p - a, Cross(b - a, c - a)) >= 0.0f; // [AP AB AC] >= 0
    }
```

Часто изгиб вершин тетраэдра заранее неизвестен, что означает, что нельзя предположить, скажем, что грань ABC повернута против часовой стрелки, если смотреть снаружи тетраэдра. В этом случае решение состоит в том, чтобы дополнительно передать четвертую вершину тетраэдра в **PointOutsideOfPlane()** и убедиться, что она и проверяемая точка лежат по разные стороны от грани проверяемого тетраэдра. Другими словами, тогда функция становится:

```cpp
    // Проверить, лежат ли точки p и d на противоположных сторонах плоскости, проходящей через abc
    int PointOutsideOfPlane(Point p, Point a, Point b, Point c, Point d){
        float signp = Dot(p - a, Cross(b - a, c - a)); // [AP AB AC]
        float signd = Dot(d - a, Cross(b - a, c - a)); // [AD AB AC]
        // Указывает на противоположные стороны, если знаки выражения противоположны
        return signp * signd < 0.0f;
    }
```

Этот общий подход хорошо работает и прост в реализации. Однако можно получить более эффективное решение, применив тот же базовый метод, который используется для поиска ближайшей точки на треугольнике. Сначала определяется характерная область Вороного, в которой находится точка P. Как только признак получен, Q задается ортогональной проекцией P на этот признак. Для тетраэдра необходимо учитывать 14 общих областей признаков Вороного: четыре области вершин, шесть краевых областей и четыре грани. Если P не лежит в одной из областей признаков, P по умолчанию должен содержаться в тетраэдре. Тесты на локализацию в функциональной области аналогичны тем, которые проводились ранее для треугольника. Например, теперь определяется, что P лежит в области Вороного вершины A, если выполняются следующие выражения.

$$(P − A) · (B − A) ≤ 0$$
$$(P − A) · (C − A) ≤ 0$$
$$(P − A) · (D − A) ≤ 0$$

Чтобы P лежал в области Вороного, связанной с ребром AB, должны быть выполнены следующие тесты (опять же при условии известного поворота граней против часовой стрелки).

$$(P − A) · (B − A) ≥ 0$$
$$(P − B) · (A − B) ≥ 0$$
$(P − A) · ((B − A) × \textbf n_{ABC} ) ≥ 0$, где $\textbf n_{ABC} = (B − A) × (C − A)$

$(P − A) · (\textbf n_{ADB} × (B − A)) ≥ 0$, где $\textbf n_{ADB} = (D − A) × (B − A)$

Аналогичные наборы выражений могут быть определены для тестирования сдерживания в остальных регионах. На первый взгляд, это может показаться не лучшим вариантом по сравнению с предыдущим тестом. Однако многие из вычисленных величин распределяются между различными регионами Вороного и не нуждаются в пересчете. Также можно упростить выражения, участвующие в тестировании областей Вороного, используя тождество Лагранжа, аналогично оптимизации, сделанной для теста ближайшей точки на треугольнике. В этом случае оказывается, что все тесты могут быть составлены из 10 различных скалярных произведений.

### 5.1.7 Ближайшая точка Выпуклого многогранника к Точке

Существует несколько подходов к нахождению расположения точки выпуклого многогранника H, ближайшей к точке P в пространстве. Простой в реализации метод O(n) состоит в том, чтобы вычислить точку на каждой грани многогранника, ближайшую к P, и вернуть ту, которая наиболее близка к P. Одновременный тест определяет, лежит ли P внутри всех граней H, и в этом случае P является внутренней по отношению к H. Чтобы ускорить тест, расчет расстояния до грани должен выполняться только тогда, когда P находится перед гранью.

Для больших многогранников более быстрый подход состоит в построении в качестве предварительного вычисления иерархии по частям многогранника. Использование предварительно построенной иерархии позволяет найти ближайшую точку в логарифмическом времени. Примером такой иерархии является иерархия Добкина – Киркпатрика, описанная в главе 9. Глава 9 также описывает другие подходы, которые могут эффективно определять местонахождение ближайшей точки на многогранниках (например, алгоритм GJK).

### 5.1.8 Ближайшие точки двух Линий

В то время как пара линий в двух измерениях всегда пересекается, если они не параллельны, пара линий в трех измерениях почти никогда не пересекается. Более того, даже если две трехмерные линии пересекаются в точной реальной арифметике, при арифметике с плавающей точкой они, скорее всего, не пересекаются из-за ошибок округления. Таким образом, чтобы иметь возможность надежно проверить пересечение двух трехмерных линий, лучше всего предположить, что линии могут не пересекаться, а только достаточно близко подходят друг к другу. Затем проверка пересечения сводится к определению расстояния между линиями и проверке того, меньше ли это расстояние заданного порогового значения.

Ближайшие точки двух линий можно определить следующим образом. Пусть прямые $L_1$ и $L_2$ параметрически заданы точками $P_1$ и $Q_1$ и $P_2$ и $Q_2$:

$$L_1 (s) = P_1 + s \textbf d_1 , \textbf d_1 = Q_1 − P_1$$
$$L_2 (t) = P_2 + t \textbf d_2 , \textbf d_2 = Q_2 − P_2$$

Для некоторой пары значений s и t, $L_1 (s)$ и $L_2 (t)$ соответствуют ближайшим точкам на линиях, а $\textbf v(s, t) = L_1(s) - L_2(t)$ описывает вектор между ними (Рисунок 5.8).
Точки наиболее близки, когда $\textbf v$ имеет минимальную длину. Ключевое понимание состоит в том, что это происходит, когда $\textbf v$ перпендикулярна как $L_1$, так и $L_2$. Чтобы убедиться в этом, предположим, что кратчайшее расстояние между точкой P и прямой L - это длина прямой линии между P и точкой Q, соответствующей ортогональной проекции P на L. Следовательно, прямая PQ ортогональна L. Поскольку это рассуждение справедливо как для $L_1 (s)$ по отношению к $L_2$, так и для $L_2 (t)$ по отношению к $L_1$, $\textbf v$ должна быть перпендикулярна обеим линиям. Для непараллельных прямых $\textbf v$ уникальна.

**Рисунок 5.8** Вектор $\textbf v (s, t)$, соединяющий две ближайшие точки двух прямых, $L_1 (s)$ и $L_2 (t)$, всегда перпендикулярен обеим линиям.

Теперь задача состоит в том, чтобы найти значения s и t, удовлетворяющие этим двум ограничениям перпендикулярности:

$$\textbf d_1 · \textbf v(s, t) = 0$$
$$\textbf d_2 · \textbf v(s, t) = 0.$$

Подстановка параметрического уравнения для $v(s, t)$ дает:

$$\textbf d_1 · (L_1 (s) − L_2 (t)) = \textbf d_1 · ((P_1 − P_2 ) + s \textbf d_1 − t \textbf d_2 ) = 0$$
$$ \textbf d_2 · (L_1 (s) − L_2 (t)) = \textbf d_2 · ((P_1 − P_2 ) + s \textbf d_1 − t \textbf d_2 ) = 0.$$

Это можно выразить в виде системы линейных уравнений 2 × 2

$$( \textbf d_1 · \textbf d_1 )s − (\textbf d_1 · \textbf d_2 )t = −(\textbf d_1 · r)$$
$$( \textbf d_2 · \textbf d_1 )s − (\textbf d_2 · \textbf d_2 )t = −(\textbf d_2 · r),$$
where $\textbf r = P_1 − P_2$ .

Написанное символически в матричной записи, это соответствует

\begin{equation*}
\begin{bmatrix}
a & -b \\
b & e 
\end{bmatrix}
\begin{bmatrix}
s \\
t 
\end{bmatrix}=
\begin{bmatrix}
-c \\
-f 
\end{bmatrix}
\end{equation*}

где $a = \textbf d_1 · \textbf d_1 , b = \textbf d_1 · \textbf d_2 , c = \textbf d_1 · r, e = \textbf d_2 · \textbf d_2$ , и $f = \textbf d_2 · r$. Эта система уравнений решается, например, с использованием правила Крамера для получения

$$s = (bf − ce)/d$$
$$t = (af − bc)/d,$$

где $d = ae − b^2$ . Обратите внимание, что $d ≥ 0$, для $d = \| \textbf d_1 \|^2 \| \textbf d_2 \|^2 ( \| \textbf d_1 \| \| \textbf d_2 \| cos(θ))^2 = ( \| \textbf d_1 \| \| \textbf d_2 \| sin(θ))^2$ . Когда $d = 0$, две линии параллельны, и их нужно обрабатывать отдельно. В этом случае любую точку P можно выбрать на одной линии. На другой строке точка, ближайшая к P, выбирается с использованием метода проекции, описанного в Разделе 5.1.2.

### 5.1.9 Ближайшие точки двух линейных участков

Задача определения ближайших точек двух отрезков $S_1$ и $S_2$,

$$S_1 (s) = P_1 + s \textbf d_1 , \textbf d_1 = Q_1 − P_1 , 0 ≤ s ≤ 1$$
$$S_2 (t) = P_2 + t \textbf d_2 , \textbf  d_2 = Q_2 − P_2 , 0 ≤ t ≤ 1,$$

является более сложной, чем вычисление ближайших точек прямых $L_1$ и $L_2$, частью которых являются отрезки. Только когда самые близкие точки $L_1$ и $L_2$ лежат на сегментах, применяется метод определения ближайших точек между линиями. В случае, когда ближайшие точки между $L_1$ и $L_2$ лежат за пределами одного или обоих сегментов, распространено заблуждение, что достаточно прижать внешние точки к ближайшей конечной точке сегмента. Однако, как показывают случаи (b) и (c) на рисунке 5.9, это неверное предположение.

Можно показать, что если хотя бы одна из ближайших точек между линиями находится за пределами соответствующего сегмента, эта точка может быть привязана к соответствующей конечной точке сегмента, и вычисляется точка на другом сегменте, ближайшая к конечной точке [Lumelsky85]. Это соответствует случаю (b) на рисунке 5.9, в котором ближайшая точка на $L_1$ привязана к конечной точке $Q_1$ на сегменте $S_1$. Затем вычисляется ближайшая точка R на $L_2$ к $Q_1$, и оказывается, что она находится на сегменте S2, оставляя ближайшие точки как $Q_1$ и R.

Если обе точки находятся за пределами соответствующих сегментов, ту же процедуру зажима необходимо повторить дважды, как показано на примере (c) на рисунке 5.9. Снова ближайшая точка на $L_1$ фиксируется к конечной точке $Q_1$ на $S_1$. Вычисляется ближайшая точка R на $L_2$ к $Q_1$. Поскольку обнаружено, что R находится вне сегмента $S_2$, он ограничивается ближайшей конечной точкой сегмента $Q_2$. Затем вычисляется ближайшая точка $S$ на $L_1$ к $Q_2$, и теперь обнаруживается, что она находится на сегменте $S_1$, оставляя самые близкие точки как $Q_2$ и $S$.

Для точки $S_2(t) = P_2 + t \textbf d_2$ на втором сегменте ближайшая точка $L_1 (s)$ на $L_1$ определяется выражением

$$s = (S_2 (t) − P_1 ) · \textbf d_1 / \textbf d_1 · \textbf d_1 = (P_2 + t \textbf d_2 − P_1 ) · \textbf d_1 / \textbf d_1 · \textbf d_1 .$$

**Рисунок 5.9** Ближайшие точки (a) внутри обоих сегментов, (b) и (c) внутри конечной точки одного сегмента другого, (d) конечные точки обоих сегментов (после [Lumelsky85]).

Так же, для точки $S_1 (s) = P_1 + s \textbf d_1$ на $S_1$ , ближайшая точка $L_2 (t)$ на $L_2$ вычисляется как

$$t = (S_1 (s) − P_2 ) · \textbf d_2 / \textbf d_2 · \textbf d_2 = (P_1 + s \textbf d_1 − P 2 ) · \textbf d_2 / \textbf d_2 · \textbf d_2 .$$

В качестве альтернативы, метод исключения Гаусса может использоваться в системе линейных уравнений 2 × 2, чтобы решить одно неизвестное через другое. В любом случае выражения для s и t упрощаются до

$$s = (bt − c)/a$$
$$t = (bs + f )/e,$$

с $a = d_1 · d_1$, $b = d_1 · d_2$, $c = d_1 · r$, $e = d_2 · d_2$ и $f = d_2 · r$. Код, реализующий эту функцию, приведен ниже.

```cpp
// Зажать n, чтобы он лежал в пределах диапазона [min, max]
float Clamp(float n, float min, float max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
}
// Вычислить ближайшие точки C1 и C2 для 
// S1(s) = P1 + s * (Q1 - P1) и S2(t) = P2 + t * (Q2 - P2), возвратить s и t. 
// Результат функции - квадрат расстояния между S1(s) и S2(t)
float ClosestPtSegmentSegment(Point p1, Point q1, Point p2, Point q2,
float &s, float &t, Point &c1, Point &c2) {
    Vector d1 = q1 - p1; // Вектор направления отрезка S1
    Vector d2 = q2 - p2; // Вектор направления отрезка S2
    Vector r = p1 - p2;
    float a = Dot(d1, d1); // Квадрат длины сегмента S1, всегда неотрицательный
    float e = Dot(d2, d2); // Квадрат длины сегмента S2, всегда неотрицательный
    float f = Dot(d2, r);
    // Проверить, превращаются ли один или оба сегмента в точки
    if (a <= EPSILON && e <= EPSILON) {
        // Оба отрезка вырождаются в точки
        s = t = 0.0f;
        c1 = p1;
        c2 = p2;
        return Dot(c1 - c2, c1 - c2);
    }
    if (a <= EPSILON) {
        // Первый отрезок вырождается в точку
        s = 0.0f;
        t = f / e; // s = 0 => t = (b*s + f) / e = f / e
        t = Clamp(t, 0.0f, 1.0f);
    } else {
        float c = Dot(d1, r);
        if (e <= EPSILON) {
        // Второй отрезок вырождается в точку
        t = 0.0f;
        s = Clamp(-c / a, 0.0f, 1.0f); // t = 0 => s = (b*t - c) / a = -c / a
        } else {
            // Здесь начинается общий невырожденный случай
            float b = Dot(d1, d2);
            float denom = a*e-b*b; // Всегда неотрицательно
            // Если сегменты не параллельны, вычислить ближайшую точку на L1 к L2
            // и зафиксировать сегмент S1. 
            // В противном случае выбрать произвольное значение s (здесь 0)
            if (denom != 0.0f) {
            s = Clamp((b*f - c*e) / denom, 0.0f, 1.0f);
            } else s = 0.0f;
            // Вычислить точку на L2, ближайшую к S1 (s), используя
            // t = Dot((P1 + D1*s) - P2,D2) / Dot(D2,D2) = (b*s + f) / e
            t = (b*s + f) / e;
            // Если t в [0,1] уже. В противном случае зажать t, 
            // пересчитать s для нового значения t, используя 
            // s = Dot((P2 + D2*t) - P1,D1) / Dot(D1,D1)= (t*b - c) / a
            // и зафиксировать s в [0, 1]
            if (t < 0.0f) {
                t = 0.0f;
                s = Clamp(-c / a, 0.0f, 1.0f);
            } else if (t > 1.0f) {
                t = 1.0f;
                s = Clamp((b - c) / a, 0.0f, 1.0f);
            }
        }
    }
    c1 = p1 + d1 * s;
    c2 = p2 + d2 * t;
    return Dot(c1 - c2, c1 - c2);
}
```

В качестве оптимизации деление на e можно отложить до тех пор, пока не станет известно, что t находится в диапазоне [0, 1], в результате чего код в конце большого оператора else будет таким :

```cpp
    ...
    float tnom = b*s + f;
    if (tnom < 0.0f) {
        t = 0.0f;
        s = Clamp(-c / a, 0.0f, 1.0f);
    } else if (tnom > e) {
        t = 1.0f;
        s = Clamp((b - c) / a, 0.0f, 1.0f);
    } else {
        t = tnom / e;
    }
```

Такая отсрочка позволяет сэкономить на одной, зачастую дорогой, операции деления в общем случае.

#### 5.1.9.1 2D Пересечение Сегментов
### 5.1.10 Ближайшие точки Отрезка линии и Треугольника
### 5.1.11 Ближайшие точки двух Треугольников
## 5.2 Тестирование пересечения примитивов
### 5.2.1 Тест разделяющей оси
#### 5.2.1.1 Устойчивость теста разделяющей оси
### 5.2.2 Тестирование пересечения Сферы и Плоскости
### 5.2.3 Тестирование пересечения Параллелипипеда и Плоскости
### 5.2.4 Тестирование пересечения Конуса и Плоскости
### 5.2.5 Тестирование пересечения Сферы и AABB
### 5.2.6 Тестирование пересечения Сферы и OBB
### 5.2.7 Тестирование пересечения Сферы и Треугольника
### 5.2.8 Тестирование пересечения Сферы и Многоугольника
### 5.2.9 Тестирование пересечения AABB и Треугольника
### 5.2.10 Тестирование пересечения Треугольника и Треугольника
## 5.3 Пересекающиеся линии, лучи и (направленные) сегменты

Испытания с использованием линий, лучей и сегментов часто используются, например, для имитации выстрела пули или для проверки прямой видимости. Иногда вместо более сложных запросов используются линейные тесты. Например, контакт руки или ноги персонажа игрока с окружающей средой или контакт колеса транспортного средства с землей часто можно эффективно смоделировать с помощью простого линейного теста. В следующих разделах исследуются эффективные тесты линий, лучей и сегментов с использованием различных общих примитивов столкновения.

### 5.3.1 Пересекающиеся Сегмент и Плоскость
### 5.3.2 Пересекающиеся Луч или Сегмент и Сфера
### 5.3.3 Пересекающиеся Луч или Сегмент и Параллелипипед
### 5.3.4 Пересекающиеся Линия и Треугольник
### 5.3.5 Пересекающиеся Линия и Четырехугольник
### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник
### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)
### 5.5.7 Пересечение движущейся сферы относительно AABB

Пусть сфера $S$ задана центром $C$ и радиусом $r$, и пусть $\textbf d$ - вектор направления для $S$, так что движение центра сферы задается формулой $C(t)=C + t \textbf d$ на интервале движения $0 ≤ t ≤ 1$. Пусть $B$ - AABB. Пересечение движущейся сферы $S$ с параллелипипедом $B$ эквивалентно пересечению отрезка $L(t)=C + t \textbf d$, $0 ≤ t ≤ 1$, с объемом $V$, который получается после переметания B с помощью S (то есть с суммой Минковского B и S, V=B ⊕ S), как показано на рисунке 5.37. Последний тест может быть эффективно выполнен без формирования V, как показано ниже.

Пусть E будет AABB, полученным расширением граней B наружу на расстояние, эквивалентное радиусу сферы r. Это самый плотный AABB, ограничивающий V, отличающийся от V только отсутствием сферически скошенных ребер. Теперь пересекаем L с E. Если L не пересекает E, то очевидно, что S не пересекает B. В противном случае пусть P=L(t) обозначает точку, в которой L пересекает E в момент времени t.

Если P лежит в области Вороного на грани поверхности B, то больше ничего не требуется: S пересекает B в момент времени t, когда центр сферы находится в точке P. Однако, если P лежит на краю или вершине области Вороного, требуются дальнейшие тесты для определить, проходит ли L через скошенную область V, отсутствующую в E, таким образом пропуская V, или L пересекает V по одному из своих скошенных ребер или вершин в некоторый более поздний момент времени t', t < t' ≤ 1.

Когда P лежит в краевой области Вороного B, L должен дополнительно пересекаться с капсулой радиуса r, определяемого ребром. Если и только если L пересекает капсулу, S пересекает B. Пересечение L и капсулы соответствует фактическому пересечению S и B.

**Рисунок 5.37**. Двухмерная иллюстрация того, как проверка движущейся сферы относительно AABB трансформируется в тестирование отрезка линии относительно объема, полученного после протягивания AABB сферой (формируя сумму Минковского сферы и AABB).

Последнее соображение - когда P лежит в вершине области Вороного. В этом случае L необходимо дополнительно пересечь по всем трем капсулам радиуса r, определяемого ребрами, совпадающими с вершиной. Если L не пересекает одну из капсул, S не пересекает B. В противном случае пересечение S с B происходит в наименьший момент времени t, когда L пересекает одну из краевых капсул. В качестве потенциального ускорения L можно проверить на сфере K радиуса r с центром в вершине. Если L пересекает K, а точка пересечения лежит в области Вороного вершины, то эта точка пересечения дает ответ, и капсулы не нужно проверять. Однако, если точка пересечения между L и K лежит вне области Вороного вершины (или если L вообще не пересекает K), проверка сферы была напрасной, и три цилиндра должны быть пересечены в любом случае. В следующем фрагменте кода показано, как эффективно определить, в какой области Вороного P содержится и какие ребра необходимо проверить для случаев области ребер и вершин.

```cpp
    int IntersectMovingSphereAABB(Sphere s, Vector d, AABB b, float &t){
        // Вычислить AABB, полученный в результате расширения b на радиус сферы r
        AABB e = b;
        e.min.x -= s.r; e.min.y -= s.r; e.min.z -= s.r;
        e.max.x += s.r; e.max.y += s.r; e.max.z += s.r;
        // Луч пересечения против расширенного AABB e. Выйти без пересечения, 
        // если луч не попадет в точку e, иначе в качестве результата получится точка пересечения p и время t
        Point p;
        if (!IntersectRayAABB(s.c, d, e, t, p) || t > 1.0f)
        return 0;
        // Вычислить, за пределами какой минимальной и максимальной граней b лежит точка пересечения p. 
        // Обратите внимание, что u и v не могут иметь одинаковые установленные биты, 
        // и среди них должен быть установлен хотя бы один бит
        int u = 0, v = 0;
        if (p.x < b.min.x) u |= 1;
        if (p.x > b.max.x) v |= 1;
        if (p.y < b.min.y) u |= 2;
        if (p.y > b.max.y) v |= 2;
        if (p.z < b.min.z) u |= 4;
        if (p.z > b.max.z) v |= 4;

        // «Или» все установленные биты вместе в битовую маску (примечание: здесь u + v == u | v)
        int m = u + v;
        // Определить отрезок [c, c + d], заданный движением сферы
        Segment seg(s.c, s.c + d);
        // Если все 3 бита установлены (m == 7), то p находится в области вершины
        if (m == 7) {
            // Теперь должен пересекать сегмент [c, c + d] относительно капсул трех ребер, 
            // встречающихся в вершине, и возвращать лучшее время, если одно или несколько попаданий
            float tmin = FLT_MAX;
            if (IntersectSegmentCapsule(seg, Corner(b, v), Corner(b, v ∧ 1), s.r, &t))
            tmin = Min(t, tmin);
            if (IntersectSegmentCapsule(seg, Corner(b, v), Corner(b, v ∧ 2), s.r, &t))
            tmin = Min(t, tmin);
            if (IntersectSegmentCapsule(seg, Corner(b, v), Corner(b, v ∧ 4), s.r, &t))
            tmin = Min(t, tmin);
            if (tmin == FLT_MAX) return 0;
            // Нет пересечения
            t = tmin;
            return 1;
            // Пересечение в момент времени t == tmin
        }
        // Если в m установлен только один бит, то p находится в области грани
        if ((m & (m - 1)) == 0) {
            // Ничего не делать. Время t от пересечения с развернутым прямоугольником 
            // является правильным временем пересечения
            return 1;
        }
        // p находится в реберной области. Пересекает капсулу ребром
        return IntersectSegmentCapsule(seg, Corner(b, u ∧ 7), Corner(b, v), s.r, &t);
    }
    // Функция поддержки, возвращающая вершину AABB с индексом n
    Point Corner(AABB b, int n){
        Point p;
        p.x = ((n & 1) ? b.max.x : b.min.x);
        p.y = ((n & 1) ? b.max.y : b.min.y);
        p.z = ((n & 1) ? b.max.z : b.min.z);
        return p;
    }
```

Этот тест также работает для выполнения того же пересечения с OBB: выражая центр сферы C и вектор движения d в локальной системе координат OBB, проблема эффективно сводится к проблеме движущейся сферы относительно AABB.

### 5.5.8 Пересечение движущегося AABB относительно AABB

**Рисунок 5.38**, иллюстрирующий расстояния, проекций параллелограмма B, для достижения первого и последнего контакта с проекцией неподвижного параллелограмма A, когда B движется к A.

Поскольку AABB является примером выпуклого многогранника, проблема определения пересечения между двумя движущимися AABB, A и B с соответствующими скоростями $v_A$ и $v_B$, может быть решена с использованием движущейся версии теста разделяющей оси, как описано в разделе 5.5.2.

Сначала задача сводится к проблеме неподвижного параллелограмма A и движущегося параллелограмма B путем вычитания скорости A из B, что дает относительную скорость $v=v_B - v_A$. На рис. 5.38 показано, что для данного B, движущегося в сторону A, расстояния $d_{ﬁrst}$ и $d_{last}$, которые B должен преодолеть, чтобы достичь первого и последнего контакта с A. Время до первого и последнего контакта, $t_{ﬁrst}$ и $t_{last}$, затем легко получить, разделив эти расстояния на скорость, с которой B движется к A. Эти времена получены для всех трех главных осей, а наибольшее t первое и наименьшее t последнее соответствуют пересечению в моментах времени, когда прямоугольники перекрываются на трех осях, если вообще перекрываются. Если окажется, что проекции прямоугольников не пересекаются и расходятся по оси, тест может быть немедленно завершен без пересечения. Далее следует полная реализация этого теста.

```cpp
// Пересечение AABB «a» и «b», движущихся с постоянными скоростями va и vb.
// При пересечении вернуть время первого и последнего контакта в tfirst и tlast
int IntersectMovingAABBAABB(AABB a, AABB b, Vector va, Vector vb,
float &tfirst, float &tlast){
    // Выйдити раньше, если «a» и «b» изначально перекрываются
    if (TestAABBAABB(a, b)) {
        tfirst = tlast = 0.0f;
        return 1;
    }
    // Использовать относительную скорость; эффективно рассматривать 'а' как стационарный
    Vector v = vb - va;
    // Инициализация время первого и последнего контакта
    tfirst = 0.0f;
    tlast = 1.0f;
    // Для каждой оси определить время первого и последнего контакта, если таковые имеются
    for (int i = 0; i < 3; i++) {
        if (v[i] < 0.0f) {
            if (b.max[i] < a.min[i]) return 0;
            // Непересекающиеся и расходящиеся
            if (a.max[i] < b.min[i]) tfirst = Max((a.max[i] - b.min[i]) / v[i], tfirst);
            if (b.max[i] > a.min[i]) tlast = Min((a.min[i] - b.max[i]) / v[i], tlast);
        }
        if (v[i] > 0.0f) {
            if (b.min[i] > a.max[i]) return 0;
            // Непересекающиеся и расходящиеся
            if (b.max[i] < a.min[i]) tfirst = Max((a.min[i] - b.max[i]) / v[i], tfirst);
            if (a.max[i] > b.min[i]) tlast = Min((a.max[i] - b.min[i]) / v[i], tlast);
        }
        // Перекрытие невозможно, если время первого контакта происходит позже времени последнего контакта
        if (tfirst > tlast) return 0;
    }
    return 1;
}
```

Решение, подобное представленному здесь, приведено в [Gomez99].

## 5.6 Резюме

В этой главе довольно подробно обсуждалось большое количество различных тестов и запросов. К ним относятся вычисления ближайших точек (которые позволяют напрямую определять расстояние между двумя объектами запроса); тесты неоднородного пересечения (например, между сферой и OBB); пересечения линий, лучей и отрезков (например, треугольников); и тесты на удержание точек (как для полигонов, так и для многогранников), и это лишь некоторые из них. В дополнение к статическим испытаниям на пересечение были описаны методы выполнения динамических испытаний, включая мощное обобщение испытания с разделительной осью.

Несмотря на то, что в этой главе был рассмотрен широкий спектр тестов, читатели неизбежно обратят внимание на конкретные тесты, которые были исключены из охвата. Как упоминалось в начале главы, цель предоставленного спектра тестов и приведенных математических деталей состоит в том, чтобы позволить читателям самостоятельно вывести эти другие тесты, используя идеи, представленные здесь. Возможность создавать тесты с нуля важна, потому что существует не так много источников, которые в значительной степени охватывают тесты пересечения, и даже те, которые содержат, вряд ли охватят конкретные тесты, необходимые читателю. Заметным исключением из отсутствия исчерпывающих источников для тестов на перекрестки является [Schneider02],
который является сокровищницей геометрических тестов всех типов и прекрасным дополнением к этой главе. [Eberly01] и [Bergen03] также являются хорошими справочными материалами, хотя и не такими исчерпывающими. Отдельные статьи по конкретным тестам также можно найти в серии пятитомных книг Graphic Gems [Glassner90], [Arvo91], [Kirk92], [Heckbert94],
и [Paeth95].
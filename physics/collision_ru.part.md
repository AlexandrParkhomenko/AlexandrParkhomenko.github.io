---
layout: default
title: "Робототехника"
description: "Физика столкновений на примере свободного физического движка реального времени Эрвина Куманса Bullet"
date: 
---


### 5.3.2 Пересекающиеся Луч или Сегмент и Сфера

Пусть луч задается формулой $R (t)=P + t \textbf d, t ≥ 0$, где P - начало луча и нормализованный вектор направления $\textbf d$, $\textbf ||d||=1$. Если $R(t)$ описывает сегмент, а не луч, то $0 ≤ t ≤ t_{max}$. Пусть граница сферы определяется как $(X - C) · (X - C)=r^2$, где $C$ - центр сферы, а $r$ - ее радиус. Чтобы найти значение $t$, при котором луч пересекает поверхность сферы, $R (t)$ подставляется вместо $X$, давая

$$(P + t \textbf d − C) · (P + t \textbf d − C) = r^2 .$$

Пусть $\textbf m = P − C$, тогда:

- $(\textbf m + t \textbf d) · (\textbf m + t \textbf d) = r^2$ ⇔ (замена $\textbf m = P − C$)
- $(\textbf d · \textbf d)t^2 + 2(\textbf +m · \textbf d)t + (\textbf m · \textbf m) = r^2$ ⇔ (раскрытие скалярного произведения)
- $t^2 + 2(\textbf m · \textbf d)t + (\textbf m · \textbf m) − r^2 = 0$  (упрощение $\textbf d · \textbf d = 1$; каноническая форма квадратного уравнения)

Это квадратное уравнение в t. Для квадратичной формулы $t^2 + 2bt + c = 0$, решения даются $t = −b ± \sqrt {b^2 − c}$. Здесь, $b = \textbf m · \textbf d$ и $c = (\textbf m · \textbf m) − r^2$ .

**Рисунок 5.21** Различные случаи пересечения луча и сферы: (a) луч пересекает сферу (дважды) при t> 0, (b) ложное пересечение при t <0, (c) луч пересекает сферу по касательной, (d) луч начинается внутри сферы, и (e) нет пересечения.

Решение квадратного уравнения имеет три результата, классифицируемых дискриминантом $d = b^2 − c$. Если $d < 0$, нет реальных корней, что соответствует лучу, никакой частью не пересекающему сферу. Если $d = 0$, существует один действительный (двойной) корень, соответствующий лучу, касающемуся сферы в точке. Если $d > 0$, есть два действительных корня, и луч дважды пересекает сферу: один раз входит и второй раз выходит за пределы сферы. В последнем случае меньшее значение t пересечения является релевантным $t = −b − \sqrt {b^2 − c}$. Однако важно различать случай ложного пересечения луча, начинающегося вне сферы и направленного от нее, что приводит к значению пересечения $t < 0$. Этот случай проиллюстрирован на рисунке 5.21 вместе со всеми другими пересечениями луча и сферы. отношения. Следующий код реализует тест пересечения лучей и сфер.

```cpp
// Пересекает луч r = p + td, |d| = 1, со сферой s и, если они пересекаются ,
// возвращает t значение пересечения и точки пересечения q
int IntersectRaySphere(Point p, Vector d, Sphere s, float &t, Point &q){
    Vector m = p - s.c;
    float b = Dot(m, d);
    float c = Dot(m, m) - s.r * s.r;
    // Выйти, если начало r находится за пределами s (c > 0) и r направлено в противоположную сторону s (b > 0)
    if (c > 0.0f && b > 0.0f) return 0;
    float discr = b*b - c;
    // Отрицательный дискриминант соответствует отсутствия луча в сфере
    if (discr < 0.0f) return 0;
    // Теперь обнаружено, что Рэй пересекает сферу, вычисляется наименьшее значение t пересечения
    t = -b - Sqrt(discr);
    // Если t отрицательно, луч начинается внутри сферы, поэтому зафиксируйте t равным нулю
    if (t < 0.0f) t = 0.0f;
    q = p + t * d;
    return 1;
}
```

Для пересечения ориентированного отрезка AB со сферой можно использовать тот же код, задав $P = A$ и $\textbf d = (B − A) ||B − A||$. На перекрестке важно это проверить $t ≤ ||B − A||$ так, чтобы обнаруженное пересечение не выходило за пределы конца отрезка. Чтобы просто проверить, пересекает ли луч сферу (но не когда и где), код можно оптимизировать, чтобы не выполнять потенциально дорогостоящую операцию извлечения квадратного корня.

Сделав ранний выход как можно скорее, код будет выглядеть следующим образом :

```cpp
// Проверить, пересекает ли луч r = p + td сферу s
int TestRaySphere(Point p, Vector d, Sphere s){
    Vector m = p - s.c;
    float c = Dot(m, m) - s.r * s.r;
    // Если определенно существует хотя бы один реальный корень, должно быть пересечение
    if (c <= 0.0f) return 1;
    float b = Dot(m, d);
    // Ранний выход, если луч выходит за пределы сферы и луч направлен от сферы
    if (b > 0.0f) return 0;
    float disc = b*b - c;
    // Отрицательный дискриминант соответствует отсутствия луча в сфере
    if (disc < 0.0f) return 0;
    // Теперь луч должен попасть в сферу
    return 1;
}
```

Если d не нормализовано, решаемое квадратное уравнение принимает вид 
$$(\textbf d · \textbf d)t^2 + 2(\textbf m · \textbf d)t + (\textbf m · \textbf m) − r^2 = 0. $$
Для квадратного уравнения, такого как это, вида $at^2 + 2bt + c = 0$, решения даются

$$t = \frac {-b ± \sqrt {b^2 - ac}}{a} $$

с дискриминантом d = b2 − ac.

### 5.3.3 Пересекающиеся Луч или Сегмент и Параллелипипед

Вспоминая определение плиты как пространства между парой параллельных плоскостей, объем прямоугольного параллелипипеда можно рассматривать как пересечение трех таких плит под прямым углом друг к другу. Так же, как точка находится внутри параллелипипеда тогда и только тогда, когда она лежит внутри всех трех плит, сегмент пересекает параллелипипед тогда и только тогда, когда пересечения между сегментом и плитами перекрываются. Если пересечения сегмента с плитами не перекрываются, сегмент не может находиться внутри плит одновременно и, следовательно, не может пересекать объем, образованный пересечением плит. Тот же принцип применим и к пересечению луча или линии с параллелипипедом. Пересечение и непересечение луча с двухмерным параллелипипедом, образованным как пересечение x-плиты и y-плиты, показано на рисунке 5.22.

**Рисунок 5.22**. Луч R1 не пересекает параллелипипед, потому что его пересечения с перекрытием x и перекрытием y не перекрываются. Луч R2 действительно пересекает прямоугольник, потому что пересечения перекрытий перекрываются.

Поэтому для проверки пересечения луча с параллелипипедом необходимо только вычислить интервалы пересечения луча с плоскостями плит и выполнить несколько простых операций сравнения для поддержания логического пересечения всех интервалов пересечения вдоль луча. Все, что требуется, - это отслеживать самый дальний из всех входов в плиту и ближайший из всех выходов из плиты. Если самый дальний вход когда-либо становится дальше, чем ближайший выход, луч не может пересекать объем пересечения плиты, и тест может выйти раньше (в результате непересечения).

Интервалы пересечения луча с плитами получаются путем вставки параметрического уравнения луча $R(t) = P + t \textbf d$, в плоские уравнения плоскостей плиты, $X · \textbf n_i = d_i$ , и решая для t, давая $t = (d − P · \textbf n_i )/(\textbf d · \textbf n_i )$. Для AABB две компоненты нормали равны нулю и, следовательно, даны $P = (p_x , p_y , p_z )$ и $d = (d_x , d_y , d_z )$
выражение упрощается, например, до, $t = (d − p_x )/d_x$ для плоскости, перпендикулярной оси x, где d просто соответствует положению плоскости вдоль оси x. Чтобы избежать деления на ноль, когда луч параллелен плите, этот случай лучше всего обрабатывать отдельно, заменяя тест на то, что начало луча содержится в плите. Следующий код является реализацией теста луча против AABB.

```cpp
// Луч пересечения R(t) = p + t*d против AABB a. При пересечении
// возвращает расстояние пересечения tmin и точку пересечения q
int IntersectRayAABB(Point p, Vector d, AABB a, float &tmin, Point &q){
    tmin = 0.0f; // установите -FLT_MAX, чтобы получить первое попадание в линию
    float tmax = FLT_MAX; // установлен на максимальное расстояние, которое может пройти луч (для сегмента)
    // Для всех трех плит
    for (int i = 0; i < 3; i++) {
        if (Abs(d[i]) < EPSILON) {
            // Луч параллелен плите. Нет попадания, если исходная точка не в пределах плиты
            if (p[i] < a.min[i] || p[i] > a.max[i]) return 0;
        } else {
            // Вычислить значение t пересечения луча с ближней и дальней плоскостями плиты
            float ood = 1.0f / d[i];
            float t1 = (a.min[i] - p[i]) * ood;
            float t2 = (a.max[i] - p[i]) * ood;
            // Сделать t1 пересечением с ближней плоскостью, t2 с дальней плоскостью
            if (t1 > t2) Swap(t1, t2);
            // Вычислить пересечение интервалов пересечения перекрытий
            if (t1 > tmin) tmin = t1;
            if (t2 > tmax) tmax = t2;
            // Выйти без столкновения, как только пересечение перекрытий станет пустым
            if (tmin > tmax) return 0;
        }
    }
    // Луч пересекает все 3 плиты. Точка возврата (q) и значение t пересечения (tmin)
    q = p + d * tmin;
    return 1;
}
```

Если один и тот же луч пересекается с большим количеством блоков, три задействованных деления могут быть предварительно вычислены один раз для луча, а затем повторно использованы для всех тестов. В качестве дальнейшей оптимизации результат утверждения **if (t1 > t2) Swap(t1, t2)**
также полностью определяется знаками компонент вектора направления луча. Поэтому его можно было бы удалить, определив заранее, какую из восьми (или четырех для двухмерного теста) альтернативных подпрограмм вызвать, в которых эффекты операторов if были включены в окружающий код.

Обратите внимание, что представленный тест на пересечение луча и параллелипипеда является частным случаем теста пересечения луча с объемом плиты Кая – Каджиа, описанным в Разделе 4.6.1. Увеличение количества плит позволяет добиться сколь угодно хорошей подгонки выпуклой оболочки объектов. Тест Кея – Каджи, в свою очередь, на самом деле является лишь специализацией алгоритма отсечения Сайруса – Бека [Cyrus78]. Подход Сайруса – Бека с отсечением также используется в разделе 5.3.8 для пересечения луча или сегмента с выпуклым многогранником.

Если проблема состоит в том, чтобы просто проверить, пересекается ли сегмент с прямоугольником, без определения точки пересечения, альтернативным решением является использование теста разделяющей оси. Без потери общности можно выбрать систему координат, в которой прямоугольник центрируется в начале координат и ориентирован вместе с осями координат. Для AABB центрирование выполняется путем перевода сегмента вместе с AABB в начало координат. Для OBB конечные точки сегмента могут быть преобразованы из мирового пространства в OBB-пространство, после чего оба могут быть переведены в исходную точку таким же образом, как и для AABB. Предполагая, что OBB задается центральной точкой C; вектор экстента половинной ширины $e = (e_0 , e_1 , e_2 )$; и локальные оси координат $\textbf u_0$ , $\textbf u_1$ , и $\textbf u_2$ ; тогда точка P в мировом пространстве может быть выражена в системе координат OBB как точка (x, y, z), где
$x = (P − C) · \textbf u_0$ , $y = (P − C) · \textbf u_1$ , и $z = (P − C) · \textbf u_2$ .

Пусть отрезок описывается средней точкой $M = (m_x , m_y , m_z )$ и конечные точки
$M − \textbf d$ и $M + \textbf d$, где $\textbf d = (d_x , d_y , d_z )$ вектор направления для сегмента. Половина сегмента равна $\mid\mid d \mid\mid$. Проецирование сегмента на какую-либо разделяющую ось $\textbf v = (v_x , v_y , v_z )$ through the origin results in a projection interval centered at a signed distance $d_s = (M·\textbf v)/\mid\mid \textbf v\mid\mid$ от начала координат (по $\textbf v$), с радиусом (или половиной длины) $r_s = \mid\textbf d · \textbf v\mid/\mid\mid \textbf v\mid\mid$. Обозначая $r_b$ радиус проекционного интервала параллелипипеда на вектор $\textbf v$, $\textbf v$ действует как разделяющая ось тогда и только тогда, когда $d_s > r_b + r_s$ (Рисунок 5.23).

**Рисунок 5.23** Проверка пересечения между сегментом и AABB с использованием теста разделяющей оси.

**Таблица 5.1** Шесть разделительных осей для испытания пересечения между сегментом и AABB.

$\textbf v_i$           | $\textbf d_s$ | $\textbf r_b$ | $\textbf r_s$  | $\mid \textbf d_s \mid > \textbf r_b + \textbf r_s$
----------------------- | ------------- | ------------- | -------------- | ---------------------------------------------------------------------------------------------------------------
(1, 0, 0)               | $m_x$         | $e_0$         | $\mid d_x\mid$ | $\mid m_x \mid > e_0 + \mid d_x \mid$
(0, 1, 0)               | $m_y$         | $e_1$         | $\mid d_y\mid$ | $\mid m_y \mid > e_1 + \mid d_y \mid$
(0, 0, 1)               | $m_z$         | $e_2$         | $\mid d_z\mid$ | $\mid m_z \mid > e_2 + \mid d_z \mid$
$\textbf d$ × (1, 0, 0) | $(m_y d_z − m_z d_y )/ \mid\mid \textbf d\mid\mid$ | $(e_1 d_z + e_2 d_y )/ \mid\mid \textbf d\mid\mid$ | 0 | $\mid m_y d_z − m_z d_y\mid > e_1 \mid d_z\mid + e_2 \mid d_y\mid$
$\textbf d$ × (0, 1, 0) | $(m_z d_x − m_x d_z )/ \mid\mid \textbf d\mid\mid$ | $(e_0 d_z + e_2 d_x )/ \mid\mid \textbf d\mid\mid$ | 0 | $\mid m_z d_x − m_x d_z\mid > e_0 \mid d_z\mid + e_2 \mid d_x\mid$
$\textbf d$ × (0, 0, 1) | $(m_x d_y − m_y d_x )/ \mid\mid \textbf d\mid\mid$ | $(e_0 d_y + e_1 d_x )/ \mid\mid \textbf d\mid\mid$ | 0 | $\mid m_x d_y − m_y d_x\mid > e_0 \mid d_y\mid + e_1 \mid d_x\mid$

Есть шесть осей, которые должны быть протестированы как разделяющие оси: три, соответствующие нормалям граней AABB ($\textbf v_0=(1, 0, 0)$, $\textbf v_1=(0, 1, 0)$ и $\textbf v_2=(0, 0, 1)$ ) и три, соответствующие перекрестным произведениям между вектором направления сегмента и нормалями граней ($\textbf v_3 = \textbf d × (1, 0, 0)$, $\textbf v_4 = \textbf d × (0, 1, 0)$ и $\textbf v_5 = \textbf d × (0, 0, 1)$ ). В таблице 5.1 приведены результаты разработки выражений для ds, rb, rs и ds> rb + rs для этих шести осей.

Выражения для разделения, приведенные в таблице 5.1, непосредственно переводятся в эффективную реализацию.

```cpp
// Проверить, пересекает ли отрезок, указанный точками p0 и p1, AABB b
int TestSegmentAABB(Point p0, Point p1, AABB b) {
    Point c = (b.min + b.max) * 0.5f;
    // Центральная точка параллелипипеда
    Vector e = b.max - c;
    // Размеры параллелипипеда половинной длины
    Point m = (p0 + p1) * 0.5f;
    // Средняя точка сегмента
    Vector d = p1 - m;
    // Вектор полудлины сегмента
    m = m - c;
    // Переведите прямоугольник и сегмент в исходную точку
    // Попробуйте использовать мировые оси координат в качестве разделительных осей
    float adx = Abs(d.x);
    if (Abs(m.x) > e.x + adx) return 0;
    float ady = Abs(d.y);
    if (Abs(m.y) > e.y + ady) return 0;
    float adz = Abs(d.z);
    if (Abs(m.z) > e.z + adz) return 0;
    // Добавьте термин эпсилон, чтобы противодействовать арифметическим ошибкам, 
    // когда сегмент (почти) параллелен оси координат (подробности см. В тексте)
    adx += EPSILON; ady += EPSILON; adz += EPSILON;
    // Попробуйте скалярное произведение вектора направления сегмента с осями координат
    if (Abs(m.y * d.z - m.z * d.y) > e.y * adz + e.z * ady) return 0;
    if (Abs(m.z * d.x - m.x * d.z) > e.x * adz + e.z * adx) return 0;
    if (Abs(m.x * d.y - m.y * d.x) > e.x * ady + e.y * adx) return 0;
    // Не обнаружено разделение оси; Сегмент должен перекрывать Абб
    return 1;
}
```

Как написано, все выражения для $e$, $d$ и $m$ имеют коэффициент 0,5, который может быть удален, что позволяет упростить первые пять строк кода начальной настройки до:

```cpp
Vector e = b.max - b.min;
Vector d = p1 - p0;
Point m = p0 + p1 - b.min - b.max;
```

Остается рассмотреть устойчивость кода, когда вектор направления сегмента $d$ параллелен одной из осей координат, в результате чего три скалярных произведения дают результат с нулевым вектором. Если сегмент не пересекает AABB, первые три теста if правильно обнаружат это. Если сегмент действительно пересекается, последние три оператора if соответствуют 0 > 0 тестам. Чтобы избежать ошибок округления, приводящих к неправильной интерпретации оси как разделяющей, к значениям $adx$, $ady$ и $adz$ можно добавить небольшой эпсилон-член для смещения сравнения, аналогично тому, как это было сделано для теста OBB-OBB в Главе 4.

### 5.3.4 Пересекающиеся Линия и Треугольник

Пересечение линий (а также лучей и отрезков) с треугольниками - очень распространенный тест. По этой причине этот тест подробно обсуждается в этом и двух следующих разделах. Начнем с теста с прямыми. Пусть дан треугольник ABC и прямая, проходящая через точки P и Q. Прямая PQ пересекает ABC, если точка R пересечения прямой и плоскости ABC лежит внутри треугольника (рисунок 5.24).
Поэтому одним из решений проблемы пересечения является вычисление R и выполнение с ним теста точки в треугольнике. Обратите внимание, что если ABC расположен против часовой стрелки от данного направления взгляда, R находится внутри ABC, если R лежит слева от ребер треугольника AB, BC и CA (где ребра считаются направленными отрезками прямой). Аналогично, если ABC расположен по часовой стрелке, R находится внутри ABC, если R находится справа от всех ребер треугольника.
Вместо того, чтобы явно вычислять R для использования в тесте на односторонность, тест может быть выполнен непосредственно с линией PQ и ребрами треугольника. Рассмотрим скалярные тройные произведения :

$$u = [PQ\text{ }PC\text{ }PB]$$

**Рисунок 5.24.** Пересечение прямой, проходящей через P и Q, с треугольником ABC.

$$v = [PQ\text{ }PA\text{ }PC]$$
$$w = [PQ\text{ }PB\text{ }PA]$$

Если ABC вращается против часовой стрелки, для того, чтобы PQ проходил слева от ребер BC, CA и AB, должны выполняться выражения $u ≥ 0$, $v ≥ 0$ и $w ≥ 0$ (соответственно). Точно так же, когда ABC вращается по часовой стрелке, скалярные тройные произведения должны быть неположительными, чтобы PQ проходил вправо от ребер. Для двустороннего треугольника, который вращается как по часовой стрелке, так и против часовой стрелки, в зависимости от того, с какой стороны на него смотреть, PQ проходит внутри, если все три скалярных тройных произведения имеют одинаковый знак (без учета нулей).

Для получения точки пересечения с ABC можно показать, что $u$, $v$ и $w$ пропорциональны $u^∗$, $v^∗$ и $w^∗$:

$$u^∗ = ku = [PR\text{ }PC\text{ }PB]$$
$$v^∗ = kv = [PR\text{ }PA\text{ }PC]$$
$$w^∗ = kw = [PR\text{ }PB\text{ }PA],$$

где $k = \mid\mid PR \mid\mid / \mid\mid PQ \mid\mid$.

Здесь $u^∗$, $v^∗$ и $w^∗$ пропорциональны объемам тетраэдров RBCP, RCAP и RABP. Поскольку все эти тетраэдры имеют одинаковую высоту (как показано в разделе 3.4 о барицентрических координатах), объемы соответственно пропорциональны площадям их базовых треугольников RBC, RCA и RAB. Отсюда следует, что $u^∗$, $v^∗$ и $w^∗$ (и, что более важно, $u$, $v$ и $w$), следовательно, могут быть непосредственно использованы для вычисления барицентрических координат R. Теперь несложно получить код для проверки прямой PQ против треугольника ABC против часовой стрелки и вычисление барицентрических координат точки пересечения, если таковая имеется.

```cpp
//Для прямой pq и ccw треугольника abc верните, пересекает ли линия треугольник. 
// Если это так, также верните барицентрические координаты (u, v, w) точки пересечения
int IntersectLineTriangle(Point p, Point q, Point a, Point b, Point c,
float &u, float &v, float &w){
    Vector pq = q - p;
    Vector pa = a - p;
    Vector pb = b - p;
    Vector pc = c - p;
    // Проверьте, находится ли pq внутри ребер bc, ca и ab. Сделано путем тестирования
    // что подписанные тетраэдрические объемы, вычисленные с использованием скалярных тройных произведений, все положительны
    u = ScalarTriple(pq, pc, pb);
    if (u < 0.0f) return 0;
    v = ScalarTriple(pq, pa, pc);
    if (v < 0.0f) return 0;
    w = ScalarTriple(pq, pb, pa);
    if (w < 0.0f) return 0;
    // Вычислите барицентрические координаты (u, v, w), 
    // определяющие точку пересечения r, r = u*a + v*b + w*c
    float denom = 1.0f / (u + v + w);
    u *= denom;
    v *= denom;
    w *= denom;
    // w = 1.0f - u - v;
    return 1;
}
```

### 5.3.5 Пересекающиеся Линия и Четырехугольник

Метод тройного скаляра, описанный в предыдущем разделе, можно использовать почти без изменений для вычисления точки R пересечения прямой с четырехугольником ABCD. Предположим, что ABCD выпуклый и задан против часовой стрелки. Тогда точка внутри ABCD должна быть либо внутри треугольника ABC, либо внутри треугольника DAC.

Поскольку ребро CA является общим для обоих треугольников, если это ребро проверяется в первую очередь, его можно использовать, чтобы эффективно различать, внутри какого треугольника R не должно лежать. Например, если R лежит слева от CA, R не может лежать внутри DAC, и, следовательно, нужно проверять только ABC, и проверять только два дополнительных ребра. Если вместо этого R находится справа от CA, должен быть протестирован только DAC, поскольку R не может находиться внутри ABC. Опять же, необходимо проверить только два дополнительных ребра. Случай R, лежащего на CA, может быть произвольно отнесен к любому треугольнику. Независимо от того, лежит ли R слева или справа от CA, в обоих случаях проверяются всего три ребра. С точки зрения операций с плавающей точкой, стоимость пересечения прямой с четырехугольником такая же, как и при пересечении с треугольником !

Для этого теста пересечения невозможно напрямую вернуть барицентрические координаты точки пересечения. Кроме того, необходимо указать, к какому из двух треугольников относятся координаты, или, в качестве альтернативы, координаты всегда должны быть указаны относительно, скажем, ABC, даже если точка пересечения находится внутри DAC. В следующем примере реализации точка пересечения вычисляется внутри функции и возвращается вместо барицентрических координат точки.

### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник
### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)

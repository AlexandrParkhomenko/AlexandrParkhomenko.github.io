

$P = C + x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (оригинальное выражение)

$P − C = x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (перемещение C влево)

$(P − C) · \textbf u_0 = (x \textbf u_0 + y \textbf u_1 + z \textbf u_2 ) · \textbf u_0$ ⇔ (взяв скалярное произведение с $u_0$ с обеих сторон)

$(P − C) · \textbf u_0 = x( \textbf u_0 · \textbf u_0 ) + y( \textbf u_1 ·  \textbf u_0 ) + z( \textbf u_2 · \textbf u_0 )$ ⇔ (расширение выражения скалярного произведения)

$(P − C) · \textbf u_0 = x$ (упрощение использования $\textbf u_0 · \textbf u_0 = 1$, $\textbf u_1 · \textbf u_0 = \textbf u_2 · \textbf u_0 = 0$)

Таким образом, полный набор координат OBB представлен в виде $x = (P − C) · \textbf u_0$ , $y = (P − C) · \textbf u_1$ ,
и $z = (P − C) · \textbf u_2$.

Чтобы вычислить точку R на (или в) B, ближайшую к P, можно применить тот же подход, что и для AABB, выразив P в системе координат OBB как Q, ограничив Q до значений $e_0$, $e_1$ и $e_2$ и повторное выражение Q в мировых координатах. Код для этого следующий.

```cpp
// Для данной точки p вернуть точку q на (или в) OBB b, ближайшую к p
void ClosestPtPointOBB(Point p, OBB b, Point &q){
    Vector d = p - b.c;
    // Начальный результат в центре П-да; делать шаги оттуда
    q = b.c;
    // Для каждой оси OBB...
    for (int i = 0; i < 3; i++) {
        // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра параллелипипеда
        float dist = Dot(d, b.u[i]);
        // Если расстояние больше, чем размер параллелипипеда, зажмите параллелипипеда
        if (dist > b.e[i]) dist = b.e[i];
        if (dist < -b.e[i]) dist = -b.e[i];
        // Изменить это расстояние по оси, чтобы получить мировую координату
        q += dist * b.u[i];
    }
}
```

Математически описанный метод эквивалентен преобразованию точки P в локальную систему координат OBB, вычислению точки на OBB (теперь фактически AABB), ближайшей к преобразованной точке, и преобразованию полученной точки обратно в мировые координаты.

#### 5.1.4.1 Расстояние от точки до OBB

Чтобы получить квадрат расстояния между точкой P и ближайшей точкой на OBB B, предыдущая функция может быть вызвана таким образом:

```cpp
    // Вычислить квадрат расстояния между точкой p и OBB b
    float SqDistPointOBB(Point p, OBB b){
        Point closest;
        ClosestPtPointOBB(p, b, closest);
        float sqDist = Dot(closest - p, closest - p);
        return sqDist;
    }
```
Если нужен только квадрат расстояния, а не ближайшая точка, этот код можно еще больше упростить. Путем проецирования вектора $\textbf v$ из центра B в P на каждую из трех осей OBB получается расстояние d от P до центра параллелипипеда вдоль этой оси. Поскольку оси ортогональны, любое избыточное количество, которое d выходит за пределы параллелипипеда для данной оси, может быть вычислено, возведено в квадрат и добавлено к общему квадрату расстояния P независимо от двух других осей.

```cpp
// Вычислить квадрат расстояния между точкой p и OBB b
float SqDistPointOBB(Point p, OBB b){
    Vector v = p - b.c;
    float sqDist = 0.0f;
    for (int i = 0; i < 3; i++) {
        // Спроецировать вектор от центра параллелипипеда до точки p на каждой оси, получить расстояние
        // p вдоль этой оси, и подсчитать любое превышение расстояния за пределами параллелипипеда
        float d = Dot(v, b.u[i]), excess = 0.0f;
        if (d < -b.e[i])
        excess = d + b.e[i];
        else if (d > b.e[i])
        excess = d - b.e[i];
        sqDist += excess * excess;
    }
    return sqDist;
}
```

#### 5.1.4.2 Ближайшая точка на 3D-прямоугольнике к точке

Определение точки Q на трехмерном прямоугольнике R, ближайшей к данной точке P, фактически эквивалентно задаче поиска ближайшей точки на OBB, поскольку трехмерный прямоугольник можно рассматривать как OBB с нулевой протяженностью по оси z.

Таким образом, прямоугольник определяется центральной точкой C, двумя ортогональными единичными векторами $\textbf u_0$ и $\textbf u_1$, определяющими ориентацию осей x и y R, и двумя скалярными значениями $e_0$ и $e_1$, определяющими пределы полуширины прямоугольника вдоль каждого ось. В этом представлении все точки S, содержащиеся в R, имеют вид $S = C + a \textbf u_0 + b \textbf u_1$ , где $|a| ≤ e 0$ и $b ≤ e_1$ . Выраженная в виде кода, эта прямоугольная структура становится:

```cpp
struct Rect {
Point c;     // центральная точка прямоугольника
Vector u[2]; // единичные векторы, определяющие локальные оси x и y для прямоугольника
float e[2];  // размеры полуширины прямоугольника по осям
};
```

Переписывание кода **ClosestPtPointOBB()** для учета оси z нулевой протяженности приводит к следующему коду для поиска ближайшей точки на 3D прямоугольнике.

```cpp
    // Для данной точки p вернуть точку q на (или в) прямоугольнике r, ближайшем к p
    void ClosestPtPointRect(Point p, Rect r, Point &q){
        Vector d = p - r.c;
        // Начальный результат в центре прямоугольника; делать шаги оттуда
        q = r.c;
        // Для каждой оси прямоугольника...
        for (int i = 0; i < 2; i++) {
            // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра прямоугольника
            float dist = Dot(d, r.u[i]);
            // Если расстояние больше, чем размеры прямоугольника, зажмите прямоугольник
            if (dist > r.e[i]) dist = r.e[i];
            if (dist < -r.e[i]) dist = -r.e[i];
            // Изменить это расстояние по оси, чтобы получить мировую координату
            q += dist * r.u[i];
        }
    }
```

Трехмерный прямоугольник R также может быть задан тремя точками (A, B и C), такими, что векторы B − A и C − A охватитывают прямоугольник. Теперь все точки S в R имеют вид $S = A + u(B − A) + v(C − A)$, $0 ≤ u ≤ 1$, и $0 ≤ v ≤ 1$. В этом сценарии можно использовать аналогичный проекционный подход (но с поправкой на новые интервалы ограничения). Оптимизация реализации для этого случая приводит к следующему коду.


```cpp
// Возвратить точку q на (или в) прямоугольнике (указанном a, b и c), ближайшем к данной точке p
void ClosestPtPointRect(Point p, Point a, Point b, Point c, Point &q){
    Vector ab = b - a; // вектор через прямоугольник
    Vector ac = c - a; // вектор вниз прямоугольника
    Vector d = p - a;
    // Начать результат в верхнем левом углу прямоугольника; делать шаги оттуда
    q = a;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник в поперечном направлении
    float dist = Dot(d, ab);
    float maxdist = Dot(ab, ab);
    if (dist >= maxdist)
    q += ab;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ab;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник был направлен вниз
    dist = Dot(d, ac);
    maxdist = Dot(ac, ac);
    if (dist >= maxdist)
    q += ac;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ac;
}
```

Это немного дороже, чем первоначальный подход, так как он не выигрывает от нормализации векторов поперек и вниз прямоугольника на этапе предварительного вычисления.

### 5.1.5 Ближайшая точка на Треугольнике к Точке

Даны треугольник ABC и точка P, пусть Q описывает точку на ABC, ближайшую к P. Один из способов получить Q - это полагаться на тот факт, что если P ортогонально проецируется внутрь ABC, точка проекции является ближайшей точкой Q. Если P проецируется вне ABC, ближайшая точка должна лежать на одном из его краев. В этом случае Q можно получить, вычислив точку, ближайшую к P для каждого из отрезков AB, BC и CA, и вернув вычисленную точку, ближайшую к P. Хотя это работает, это не очень эффективный подход. Лучшее решение - вычислить, в какой из характерных областей Вороного треугольника P находится.

**Рисунок 5.5**. Область Вороного вершины A, VR(A), является пересечением отрицательных полупространств двух плоскостей $(X – A) · (B – A) = 0$ и $(X – A) · (C – A) = 0$.



### 5.1.6 Ближайшая точка на Тетраэдре к Точке
### 5.1.7 Ближайшая точка Выпуклого многогранника к Точке
### 5.1.8 Ближайшие точки двух Линий
### 5.1.9 Ближайшие точки двух линейных участков
#### 5.1.9.1 2D Пересечение Сегментов
### 5.1.10 Ближайшие точки Отрезка линии и Треугольника
### 5.1.11 Ближайшие точки двух Треугольников
## 5.2 Тестирование пересечения примитивов
### 5.2.1 Тест разделяющей оси
#### 5.2.1.1 Устойчивость теста разделяющей оси
### 5.2.2 Тестирование пересечения Сферы и Плоскости
### 5.2.3 Тестирование пересечения Параллелипипеда и Плоскости
### 5.2.4 Тестирование пересечения Конуса и Плоскости
### 5.2.5 Тестирование пересечения Сферы и AABB
### 5.2.6 Тестирование пересечения Сферы и OBB
### 5.2.7 Тестирование пересечения Сферы и Треугольника
### 5.2.8 Тестирование пересечения Сферы и Многоугольника
### 5.2.9 Тестирование пересечения AABB и Треугольника
### 5.2.10 Тестирование пересечения Треугольника и Треугольника
## 5.3 Пересекающиеся линии, лучи и (направленные) сегменты
### 5.3.1 Пересекающиеся Сегмент и Плоскость
### 5.3.2 Пересекающиеся Луч или Сегмент и Сфера
### 5.3.3 Пересекающиеся Луч или Сегмент и Параллелипипед
### 5.3.4 Пересекающиеся Линия и Треугольник
### 5.3.5 Пересекающиеся Линия и Четырехугольник
### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник
### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)
### 5.5.7 Пересечение движущейся сферы относительно AABB
### 5.5.8 Пересечение движущегося AABB относительно AABB
## 5.6 Резюме

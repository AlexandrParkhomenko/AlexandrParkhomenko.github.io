---
layout: default
title: "Робототехника"
description: "Физика столкновений на примере свободного физического движка реального времени Эрвина Куманса Bullet"
date: 
---


$P = C + x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (оригинальное выражение)

$P − C = x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (перемещение C влево)

$(P − C) · \textbf u_0 = (x \textbf u_0 + y \textbf u_1 + z \textbf u_2 ) · \textbf u_0$ ⇔ (взяв скалярное произведение с $u_0$ с обеих сторон)

$(P − C) · \textbf u_0 = x( \textbf u_0 · \textbf u_0 ) + y( \textbf u_1 ·  \textbf u_0 ) + z( \textbf u_2 · \textbf u_0 )$ ⇔ (расширение выражения скалярного произведения)

$(P − C) · \textbf u_0 = x$ (упрощение использования $\textbf u_0 · \textbf u_0 = 1$, $\textbf u_1 · \textbf u_0 = \textbf u_2 · \textbf u_0 = 0$)

Таким образом, полный набор координат OBB представлен в виде $x = (P − C) · \textbf u_0$ , $y = (P − C) · \textbf u_1$ ,
и $z = (P − C) · \textbf u_2$.

Чтобы вычислить точку R на (или в) B, ближайшую к P, можно применить тот же подход, что и для AABB, выразив P в системе координат OBB как Q, ограничив Q до значений $e_0$, $e_1$ и $e_2$ и повторное выражение Q в мировых координатах. Код для этого следующий.

```cpp
// Для данной точки p вернуть точку q на (или в) OBB b, ближайшую к p
void ClosestPtPointOBB(Point p, OBB b, Point &q){
    Vector d = p - b.c;
    // Начальный результат в центре П-да; делать шаги оттуда
    q = b.c;
    // Для каждой оси OBB...
    for (int i = 0; i < 3; i++) {
        // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра параллелипипеда
        float dist = Dot(d, b.u[i]);
        // Если расстояние больше, чем размер параллелипипеда, зажмите параллелипипеда
        if (dist > b.e[i]) dist = b.e[i];
        if (dist < -b.e[i]) dist = -b.e[i];
        // Изменить это расстояние по оси, чтобы получить мировую координату
        q += dist * b.u[i];
    }
}
```

Математически описанный метод эквивалентен преобразованию точки P в локальную систему координат OBB, вычислению точки на OBB (теперь фактически AABB), ближайшей к преобразованной точке, и преобразованию полученной точки обратно в мировые координаты.

#### 5.1.4.1 Расстояние от точки до OBB

Чтобы получить квадрат расстояния между точкой P и ближайшей точкой на OBB B, предыдущая функция может быть вызвана таким образом:

```cpp
    // Вычислить квадрат расстояния между точкой p и OBB b
    float SqDistPointOBB(Point p, OBB b){
        Point closest;
        ClosestPtPointOBB(p, b, closest);
        float sqDist = Dot(closest - p, closest - p);
        return sqDist;
    }
```
Если нужен только квадрат расстояния, а не ближайшая точка, этот код можно еще больше упростить. Путем проецирования вектора $\textbf v$ из центра B в P на каждую из трех осей OBB получается расстояние d от P до центра параллелипипеда вдоль этой оси. Поскольку оси ортогональны, любое избыточное количество, которое d выходит за пределы параллелипипеда для данной оси, может быть вычислено, возведено в квадрат и добавлено к общему квадрату расстояния P независимо от двух других осей.

```cpp
// Вычислить квадрат расстояния между точкой p и OBB b
float SqDistPointOBB(Point p, OBB b){
    Vector v = p - b.c;
    float sqDist = 0.0f;
    for (int i = 0; i < 3; i++) {
        // Спроецировать вектор от центра параллелипипеда до точки p на каждой оси, получить расстояние
        // p вдоль этой оси, и подсчитать любое превышение расстояния за пределами параллелипипеда
        float d = Dot(v, b.u[i]), excess = 0.0f;
        if (d < -b.e[i])
        excess = d + b.e[i];
        else if (d > b.e[i])
        excess = d - b.e[i];
        sqDist += excess * excess;
    }
    return sqDist;
}
```

#### 5.1.4.2 Ближайшая точка на 3D-прямоугольнике к точке

Определение точки Q на трехмерном прямоугольнике R, ближайшей к данной точке P, фактически эквивалентно задаче поиска ближайшей точки на OBB, поскольку трехмерный прямоугольник можно рассматривать как OBB с нулевой протяженностью по оси z.

Таким образом, прямоугольник определяется центральной точкой C, двумя ортогональными единичными векторами $\textbf u_0$ и $\textbf u_1$, определяющими ориентацию осей x и y R, и двумя скалярными значениями $e_0$ и $e_1$, определяющими пределы полуширины прямоугольника вдоль каждого ось. В этом представлении все точки S, содержащиеся в R, имеют вид $S = C + a \textbf u_0 + b \textbf u_1$ , где $|a| ≤ e 0$ и $b ≤ e_1$ . Выраженная в виде кода, эта прямоугольная структура становится:

```cpp
struct Rect {
Point c;     // центральная точка прямоугольника
Vector u[2]; // единичные векторы, определяющие локальные оси x и y для прямоугольника
float e[2];  // размеры полуширины прямоугольника по осям
};
```

Переписывание кода **ClosestPtPointOBB()** для учета оси z нулевой протяженности приводит к следующему коду для поиска ближайшей точки на 3D прямоугольнике.

```cpp
    // Для данной точки p вернуть точку q на (или в) прямоугольнике r, ближайшем к p
    void ClosestPtPointRect(Point p, Rect r, Point &q){
        Vector d = p - r.c;
        // Начальный результат в центре прямоугольника; делать шаги оттуда
        q = r.c;
        // Для каждой оси прямоугольника...
        for (int i = 0; i < 2; i++) {
            // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра прямоугольника
            float dist = Dot(d, r.u[i]);
            // Если расстояние больше, чем размеры прямоугольника, зажмите прямоугольник
            if (dist > r.e[i]) dist = r.e[i];
            if (dist < -r.e[i]) dist = -r.e[i];
            // Изменить это расстояние по оси, чтобы получить мировую координату
            q += dist * r.u[i];
        }
    }
```

Трехмерный прямоугольник R также может быть задан тремя точками (A, B и C), такими, что векторы B − A и C − A охватитывают прямоугольник. Теперь все точки S в R имеют вид $S = A + u(B − A) + v(C − A)$, $0 ≤ u ≤ 1$, и $0 ≤ v ≤ 1$. В этом сценарии можно использовать аналогичный проекционный подход (но с поправкой на новые интервалы ограничения). Оптимизация реализации для этого случая приводит к следующему коду.


```cpp
// Возвратить точку q на (или в) прямоугольнике (указанном a, b и c), ближайшем к данной точке p
void ClosestPtPointRect(Point p, Point a, Point b, Point c, Point &q){
    Vector ab = b - a; // вектор через прямоугольник
    Vector ac = c - a; // вектор вниз прямоугольника
    Vector d = p - a;
    // Начать результат в верхнем левом углу прямоугольника; делать шаги оттуда
    q = a;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник в поперечном направлении
    float dist = Dot(d, ab);
    float maxdist = Dot(ab, ab);
    if (dist >= maxdist)
    q += ab;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ab;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник был направлен вниз
    dist = Dot(d, ac);
    maxdist = Dot(ac, ac);
    if (dist >= maxdist)
    q += ac;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ac;
}
```

Это немного дороже, чем первоначальный подход, так как он не выигрывает от нормализации векторов поперек и вниз прямоугольника на этапе предварительного вычисления.

### 5.1.5 Ближайшая точка на Треугольнике к Точке

Даны треугольник ABC и точка P, пусть Q описывает точку на ABC, ближайшую к P. Один из способов получить Q - это полагаться на тот факт, что если P ортогонально проецируется внутрь ABC, точка проекции является ближайшей точкой Q. Если P проецируется вне ABC, ближайшая точка должна лежать на одном из его краев. В этом случае Q можно получить, вычислив точку, ближайшую к P для каждого из отрезков AB, BC и CA, и вернув вычисленную точку, ближайшую к P. Хотя это работает, это не очень эффективный подход. Лучшее решение - вычислить, в какой из характерных областей Вороного треугольника P находится.

**Рисунок 5.5**. Область Вороного вершины A, VR(A), является пересечением отрицательных полупространств двух плоскостей $(X – A) · (B – A) = 0$ и $(X – A) · (C – A) = 0$.

После определения необходимо вычислить только ортогональную проекцию P на соответствующий объект, чтобы получить Q.

Чтобы увидеть, как можно определить, что P находится в области Вороного вершины, рассмотрим область Вороного вершины A. Эта область определяется как пересечение отрицательных полупространств двух плоскостей, проходящих через A, одной с нормалью B - A и другой с нормальным C - A (как показано на рисунке 5.5).

Определить, находится ли P в одной из краевых областей Вороного, можно несколькими способами. Оказывается, что эффективный тест состоит в том, чтобы эффективно вычислить барицентрические координаты ортогональной проекции R точки P на ABC. Напомним из раздела 3.4, что барицентрические координаты R задаются как отношения (пропорциональные) площадей со знаком треугольников RAB, RBC и RCA к площади со знаком ABC. Пусть n - нормаль к ABC и пусть $R = P − t \textbf n$ для некоторой t. Барицентрические координаты $(u, v, w)$ для $R, R = uA + vB + wC$, затем можно рассчитать по количеству

```cpp
Vector n = Cross(b - a, c - a);
float rab = Dot(n, Cross(a - r, b - r)); // пропорционально обозначненной области RAB
float rbc = Dot(n, Cross(b - r, c - r)); // пропорционально обозначненной области RBC
float rca = Dot(n, Cross(c - r, a - r)); // пропорционально обозначненной области RCA
float abc = rab + rbc + rca; // пропорционально обозначненной области ABC
```

как $u = rbc/abc$, $v = rca/abc$, и $w = rab/abc$. Однако небольшая векторная арифметика показывает, что эти выражения упрощаются. Например, выражение для rab упрощается следующим образом:

- $\textbf n · ((A − R) × (B − R))$ = (оригинальное выражение)
- $\textbf n · (A × (B − R) − R × (B − R))$ = (раскрытие векторного произведения)
- $\textbf n · (A × B − A × R − R × B)$ = (раскрытие векторного произведения; удаление $\textbf n · (R × R) = 0$ члена)
- $\textbf n · (A × B − A × (P − t \textbf n) − (P − t \textbf n) × B)$ = (замена $R = P − tn$ для $R$)
- $\textbf n · (A × B − A × P + tA × \textbf n − P × B + t \textbf n × B)$ = (раскрытие скалярного произведения)
- $\textbf n · (A × B − A × P − P × B + t \textbf n × (B − A))$ = (группировка аналогичных членов)
- $\textbf n · (A × B − A × P − P × B)$ = (удаление $\textbf n · (t \textbf n × (B − A)) = 0$ члена)
- $\textbf n · ((A − P) × (B − P))$ (объединение векторного произведения после добавления $\textbf n · (P × P) = 0$ члена)

Другими словами, барицентрические координаты R могут быть получены непосредственно из P без вычисления R.

**Рисунок 5.6**. Когда угол в A тупой, P может лежать в области Вороного ребра CA, даже если P лежит вне AB, а не в областях вершины Вороного A или B.

Чтобы $P$ лежал в краевой области Вороного - например, область, соответствующая краю $AB - P$ должна лежать вне или на $AB$, обозначенном $rab ≤ 0$, а также в положительных полупространствах плоскостей $(X - A ) · (B - A)=0$ и $(X - B) · (A - B)=0$. Обратите внимание, что недостаточно просто проверить, находится ли $P$ вне $AB$, в этом случае для треугольника с тупым углом в $A$ , $P$ может находиться вне $AB$ и фактически находиться в области Вороного края $CA$ (рис. 5.6). (Точно так же распространенной ошибкой является предположение, например, что $A$ является ближайшей точкой к $P$, если $P$ лежит вне $AB$ и $(P - A) · (B - A) <0$.) Если $P$ не находится в любой из вершин или ребер Вороного область $Q$ должна лежать внутри $ABC$ и, фактически, ортогональная проекция R, которую теперь можно легко вычислить согласно предыдущему. Этой информации теперь достаточно, чтобы создать кодовое решение.

```cpp
Point ClosestPtPointTriangle(Point p, Point a, Point b, Point c){
    Vector ab = b - a;
    Vector ac = c - a;
    Vector bc = c - b;
    // Вычислить параметрическое положение s для проекции P’ точки P на AB,
    // P’ = A + s*AB, s = snom/(snom+sdenom)
    float snom = Dot(p - a, ab), sdenom = Dot(p - b, a - b);
    // Вычислить параметрическое положение t для проекции P’ точки P на AC,
    // P’ = A + t*AC, s = tnom/(tnom+tdenom)
    float tnom = Dot(p - a, ac), tdenom = Dot(p - c, a - c);
    if (snom <= 0.0f && tnom <= 0.0f) return a;
    // Вершинная область рано ушла
    // Вычислить параметрическое положение u для проекции P’ точки P на BC,
    // P’ = B + u*BC, u = unom/(unom+udenom)
    float unom = Dot(p - b, bc), udenom = Dot(p - c, b - c);
    if (sdenom <= 0.0f && unom <= 0.0f) return b; // Вершинная область рано ушла
    if (tdenom <= 0.0f && udenom <= 0.0f) return c; // Вершинная область рано ушла
    // P находится вне (или на) AB, если тройное скалярное произведение [N PA PB] <= 0
    Vector n = Cross(b - a, c - a);
    float vc = Dot(n, Cross(a - p, b - p));
    // Если P за пределами AB и внутри характерной области AB, 
    // вернуть проекцию P на AB
    if (vc <= 0.0f && snom >= 0.0f && sdenom >= 0.0f)
        return a + snom / (snom + sdenom) * ab;
    // P находится вне (или на) BC, если тройное скалярное произведение [N PB PC] <= 0
    float va = Dot(n, Cross(b - p, c - p));
    // Если P за пределами BC и в пределах характерного региона BC,
    // вернуть проекцию P на BC
    if (va <= 0.0f && unom >= 0.0f && udenom >= 0.0f)
        return b + unom / (unom + udenom) * bc;
    // P находится вне (или на) CA, если тройное скалярное произведение [N PC PA] <= 0
    float vb = Dot(n, Cross(c - p, a - p));
    // Если P за пределами CA и в пределах функционального региона CA,
    // вернуть проекцию P на CA
    if (vb <= 0.0f && tnom >= 0.0f && tdenom >= 0.0f)
        return a + tnom / (tnom + tdenom) * ac;
    // P должен выступать внутри области грани. Вычислить Q, используя барицентрические координаты
    float u = va / (va + vb + vc);
    float v = vb / (va + vb + vc);
    float w = 1.0f - u - v; // = vc / (va + vb + vc)
    return u * a + v * b + w * c;
}
```

В представленном виде этот код содержит четыре вызова векторного произведения. Поскольку вычисление векторных произведений зачастую обходится дороже, чем скалярных произведений, стоит изучить, можно ли их заменить более экономичными выражениями. Оказывается, тождество Лагранжа

$( \textbf a × \textbf b) · ( \textbf c × \textbf d) = ( \textbf a · \textbf c)( \textbf b · \textbf d) − ( \textbf a · \textbf d)( \textbf b ·  \textbf c)$

можно использовать для выражения трех скалярных тройных произведений

```cpp
Vector n = Cross(b - a, c - a);
float va = Dot(n, Cross(b - p, c - p));
float vb = Dot(n, Cross(c - p, a - p));
float vc = Dot(n, Cross(a - p, b - p));
```

с точки зрения шести скалярных произведений

```cpp
float d1 = Dot(b - a, p - a);
float d2 = Dot(c - a, p - a);
float d3 = Dot(b - a, p - b);
float d4 = Dot(c - a, p - b);
float d5 = Dot(b - a, p - c);
float d6 = Dot(c - a, p - c);
```
в качестве

```cpp
float va = d3*d6 - d5*d4;
float vb = d5*d2 - d1*d6;
float vc = d1*d4 - d3*d2;
```

Фактически, эти шесть скалярных произведений, от $\textbf d1$ до $\textbf d6$, также могут использоваться для вычисления членов $\textbf {snom, sdenom, tnom, tdenom, unom}$ и $\textbf {udenom}$:

```cpp
float snom = d1;
float sdenom = -d3;
float tnom = d2;
float tdenom = -d6;
float unom = d4 - d3;
float udenom = d5 - d6;
```

Вектор $\textbf n$ больше не нужен. Это позволяет оптимизировать код до финальной версии.

```cpp
Point ClosestPtPointTriangle(Point p, Point a, Point b, Point c){
    // Проверить, находится ли P в области вершин вне A
    Vector ab = b - a;
    Vector ac = c - a;
    Vector ap = p - a;
    float d1 = Dot(ab, ap);
    float d2 = Dot(ac, ap);
    if (d1 <= 0.0f && d2 <= 0.0f) return a; // барицентрические координаты (1,0,0)
    // Проверить, находится ли P в области вершины вне B
    Vector bp = p - b;
    float d3 = Dot(ab, bp);
    float d4 = Dot(ac, bp);
    if (d3 >= 0.0f && d4 <= d3) return b; // барицентрические координаты (0,1,0)
    // Проверить, находится ли P в краевой области AB, если да, вернуть проекцию P на AB
    float vc = d1*d4 - d3*d2;
    if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f) {
        float v = d1 / (d1 - d3);
        return a + v * ab; // барицентрические координаты (1-v,v,0)
    }
    // Проверить, находится ли P в области вершины вне C
    Vector cp = p - c;
    float d5 = Dot(ab, cp);
    float d6 = Dot(ac, cp);
    if (d6 >= 0.0f && d5 <= d6) return c; // барицентрические координаты (0,0,1)
    // Проверить, находится ли P в краевой области AC, если да, вернуть проекцию P на AC
    float vb = d5*d2 - d1*d6;
    if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f) {
        float w = d2 / (d2 - d6);
        return a + w * ac; // барицентрические координаты (1-w,0,w)
    }
    // Проверить, находится ли P в краевой области BC, если да, вернуть проекцию P на BC
    float va = d3*d6 - d5*d4;
    if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f) {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b); // барицентрические координаты (0,1-w,w)
    }
    // P внутри области грани. Вычислить Q через его барицентрические координаты (u,v,w)
    float denom = 1.0f / (va + vb + vc);
    float v = vb * denom;
    float w = vc * denom;
    return a + ab * v + ac * w; // = u*a + v*b + w*c, u = va * denom = 1.0f - v - w
}
```

Третий способ получить ближайшую точку - использовать метод векторного исчисления, как предложено в [Eberly01]. Вкратце, треугольник ABC параметризован как $T(s, t)=A + s (B - A) + t (C - A)$, где $s ≥ 0$, $t ≥ 0$ и $s + t ≤ 1$. Ближайшая точка до данной точки P теперь соответствует минимуму функции квадрата расстояния

$d (s, t)=|| T (s, t) - P ||^2$, что является квадратичным выражением от $s$ и $t$. Минимум этой функции должен встречаться в одном из трех случаев: в вершине, на ребре или внутри треугольника. Сначала дифференцируя $d(s, t)$ по этим различным случаям (то есть подставляя $s=0$, $t=0$ или $t=1 - s$, если необходимо), устанавливая производные равными нулю и решая, а затем сравнивая приводя значения $s$ и $t$ к границам треугольника, можно выяснить, какой случай соответствует минимуму.

Для этого конкретного приложения решение векторного исчисления становится более сложным, чем только что описанное. Однако общий подход рассмотрения проблемы как задачи квадратичной минимизации ценен, и ту же идею можно использовать для определения расстояния между, скажем, линией или отрезком линии и треугольником. Дополнительная информация о методе векторного исчисления, включая псевдокод, приведена в [Eberly01].

### 5.1.6 Ближайшая точка на Тетраэдре к Точке
### 5.1.7 Ближайшая точка Выпуклого многогранника к Точке
### 5.1.8 Ближайшие точки двух Линий
### 5.1.9 Ближайшие точки двух линейных участков
#### 5.1.9.1 2D Пересечение Сегментов
### 5.1.10 Ближайшие точки Отрезка линии и Треугольника
### 5.1.11 Ближайшие точки двух Треугольников
## 5.2 Тестирование пересечения примитивов
### 5.2.1 Тест разделяющей оси
#### 5.2.1.1 Устойчивость теста разделяющей оси
### 5.2.2 Тестирование пересечения Сферы и Плоскости
### 5.2.3 Тестирование пересечения Параллелипипеда и Плоскости
### 5.2.4 Тестирование пересечения Конуса и Плоскости
### 5.2.5 Тестирование пересечения Сферы и AABB
### 5.2.6 Тестирование пересечения Сферы и OBB
### 5.2.7 Тестирование пересечения Сферы и Треугольника
### 5.2.8 Тестирование пересечения Сферы и Многоугольника
### 5.2.9 Тестирование пересечения AABB и Треугольника
### 5.2.10 Тестирование пересечения Треугольника и Треугольника
## 5.3 Пересекающиеся линии, лучи и (направленные) сегменты
### 5.3.1 Пересекающиеся Сегмент и Плоскость
### 5.3.2 Пересекающиеся Луч или Сегмент и Сфера
### 5.3.3 Пересекающиеся Луч или Сегмент и Параллелипипед
### 5.3.4 Пересекающиеся Линия и Треугольник
### 5.3.5 Пересекающиеся Линия и Четырехугольник
### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник
### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)
### 5.5.7 Пересечение движущейся сферы относительно AABB
### 5.5.8 Пересечение движущегося AABB относительно AABB
## 5.6 Резюме

1. # Введение
    1. Обзор содержания
        1. Глава 2: Проблемы проектирования обнаружения столкновений
        2. Глава 3: Учебник по математике и геометрии
        3. Глава 4: Ограничивающие объёмы
        4. Глава 5: Базовые примитивные тесты
        5. Глава 6: Иерархии ограничивающих объемов
        6. Глава 7: Пространственное разбиение
        7. Глава 8: Иерархии деревьев BSP
        8. Глава 9: Основанные на выпуклости методы
        9. Глава 10: Обнаружение столкновений с помощью GPU
        10. Глава 11: Числовая устойчивость
        11. Глава 12: Геометрическая устойчивость
        12. Глава 13: Оптимизация
    2. О коде
2. # Вопросы проектирования обнаружения столкновений
    1. Факторы проектирования алгоритма коллизий
    2. Представление области приложения
        1. Представления объектов
        2. Столкновение против геометрии рендеринга
        3. Специализация алгоритмов столкновений
    3. Типы запросов
    4. Параметры моделирования окружающей среды
        1. Количество объектов
        2. Последовательное или одновременное движение
        3. Дискретное и непрерывное движение
    5. Производительность
        1. Обзор оптимизации
    6. Надежность
    7. Простота реализации и использования
        1. Отладка системы обнаружения столкновений
    8. Резюме
3. # Учебник по математике и геометрии
    1. Матрицы
        1. Матричная арифметика
        2. Алгебраические тождества с матрицами
        3. Детерминанты
        4. Решение малых систем линейных уравнений с помощью правила Крамера 
        5. Обращение матриц для матриц 2 × 2 и 3 × 3
        6. Детерминантные предикаты
            1. ORIENT2D(A, B, C )
            2. ORIENT3D(A, B, C, D)
            3. INCIRCLE2D(A, B, C, D)
            4. INSPHERE(A, B, C, D, E )
    2. Системы координат и точки
    3. Векторы
        1. Векторная арифметика
        2. Алгебраические тождества с векторами
        3. Скалярное произведение
        4. Алгебраические тождества скалярных произведений
        5. Векторное произведение
        6. Алгебраические тождества векторых произведений
        7. Тройное скалярное произведение
        8. Алгебраические тождества тройных скалярных произведений
    4. Барицентрические координаты
    5. Линии, лучи и сегменты
    6. Плоскости и полупространства
    7. Многоугольники
        1. Проверка многоугольной выпуклости
    8. Многогранники
        1. Проверка многогранной выпуклости
    9. Вычисление выпуклой оболочки
        1. Алгоритм Эндрю
        2. Алгоритм Quickhull
    10. Регионы Вороного
    11. Сумма Минковского и разность
    12. Резюме
4. # Ограничивающие объёмы 
    1. Желательные характеристики BV
    2. Выровненные по оси ограничительные параллелипипеды (Axis-aligned Bounding Boxes, AABBs)
        1. AABB-AABB пересечение
        2. Вычисления и обновления AABBs
        3. AABB из ограничивающей объект сферы
        4. AABB реконструирован из исходного набора точек
        5. AABB из восхождения к вершине представления объекта
        6. AABB пересчитан из повернутого AABB
    3. Сферы
        1. Сфера-сфера пересечения
        2. Вычисление ограничивающей сферы
        3. Ограничивающая сфера из направления максимального распространения
        4. Ограничивающая сфера посредством итеративного уточнения
        5. Минимальная ограничивающая сфера
    4. Ориентированные ограничивающие параллелипипеды (Oriented Bounding Boxes, OBBs)
        1. OBB-OBB пересечение
        2. Повышение надежности теста разделительной оси
        3. Вычисление жесткого OBB
        4. Оптимизация OBB на основе PCA
        5. Установка OBB методом перебора
    5. Объемы, охваченные сферой
        1. Пересечение объемов, охваченных сферой
        2. Вычисление ограничивающих объемов, охватываемых сферой
    6. Объемы пересечения полупространства
        1. Kay–Kajiya объемы на основе плит (Slab)
        2. Дискретно-ориентированные многогранники (Discrete-orientation Polytopes, k-DOPs)
        3. Тест на перекрытие k-DOP – k-DOP
        4. Вычисление и настройка k-DOP
        5. Приблизительные тесты на пересечение выпуклой оболочки
    7. Другие ограничивающие объемы
    8. Резюме
5. # Базовые примитивные тесты
    1. Вычисления ближайших точек
        1. Ближайшая точка на плоскости к точке
        2. Ближайшая точка на отрезке линии к точке
            1. Расстояние от точки до сегмента
        3. Ближайшая точка на AABB к точке
            1. Расстояние от точки до AABB
        4. Ближайшая точка OBB к точке
            1. Расстояние от точки до OBB
            2. Ближайшая точка на 3D-прямоугольнике к точке
        5. Ближайшая точка на Треугольнике к Точке
        6. Ближайшая точка на Тетраэдре к Точке
        7. Ближайшая точка Выпуклого многогранника к Точке
        8. Ближайшие точки двух Линий
        9. Ближайшие точки двух линейных участков
            1. 2D Пересечение Сегментов
        10. Ближайшие точки Отрезка линии и Треугольника
        11. Ближайшие точки двух Треугольников
    2. Тестирование пересечения примитивов
        1. Тест разделяющей оси
            1. Устойчивость теста разделяющей оси
        2. Тестирование пересечения Сферы и Плоскости
        3. Тестирование пересечения Параллелипипеда и Плоскости
        4. Тестирование пересечения Конуса и Плоскости
        5. Тестирование пересечения Сферы и AABB
        6. Тестирование пересечения Сферы и OBB
        7. Тестирование пересечения Сферы и Треугольника
        8. Тестирование пересечения Сферы и Многоугольника
        9. Тестирование пересечения AABB и Треугольника
        10. Тестирование пересечения Треугольника и Треугольника
    3. Пересекающиеся линии, лучи и (направленные) сегменты
        1. Пересекающиеся Сегмент и Плоскость
        2. Пересекающиеся Луч или Сегмент и Сфера
        3. Пересекающиеся Луч или Сегмент и Параллелипипед
        4. Пересекающиеся Линия и Треугольник
        5. Пересекающиеся Линия и Четырехугольник
        6. Пересекающиеся Луч или Сегмент и Треугольник
        7. Пересекающиеся Луч или Сегмент и Цилиндр
        8. Пересекающиеся Луч или Сегмент и Выпуклый многогранник
    4. Дополнительные тесты
        1. Тестирование Точки в многоугольнике
        2. Тестирование Точки в Треугольнике
        3. Тестирование Точки в Многограннике
        4. Пересечение двух Плоскостей
        5. Пересечение трех Плоскостей
    5. Тест динамических пересечений
        1. Уменьшение вдвое интервала пересечения движущихся объектов
        2. Тест разделяющей оси для движущихся выпуклых объектов
        3. Пересечение движущейся Сферы относительно Плоскости
        4. Пересечение движущихся AABB относительно Плоскости
        5. Пересечение движущейся Сферы относительно Сферы
        6. Пересечение движущейся сферы относительно треугольника (и многоугольника)
        7. Пересечение движущейся сферы относительно AABB
        8. Пересечение движущегося AABB относительно AABB
    6. Резюме
6. # Иерархии ограничивающих объемов
    1. Вопросы проектирования иерархии
        1. Желаемые характеристики BVH
        2. Функции стоимости
        3. Степень дерева
    2. Стратегии построения иерархии конструкций
        1. Построение сверху вниз
            1. Стратегии разбиения
            2. Выбор оси разделения
            3. Выбор точки разделения
        2. Построение снизу вверх
            1. Улучшенная конструкция снизу вверх
            2. Другие стратегии строительства снизу вверх
            3. Снизу вверх n-арные деревья кластеризации
        3. Инкрементальная (вставная) конструкция
            1. Метод инкрементной конструкции Goldsmith–Salmon
    3. Обход иерархии
        1. Правила спуска
        2. Общий информированный обход в глубину
        3. Одновременный обход в глубину
        4. Оптимизированный переход по листу в глубину
    4. Пример иерархии ограничивающих объемов
        1. OBB Деревья
        2. Деревья AABB и BoxTrees
        3. Дерево Сферы через Octree Подразделение
        4. Дерево Сферы с покрытых сферой поверхностей
        5. Покрытие сферы генерации и сокращения
        6. k-dop Деревья
    5. Объединение ограничивающих объемов
        1. Слияние двух AABB
        2. Слияние двух сфер
        3. Слияние двух OBB
        4. Слияние двух k-DOP
    6. Эффективное представление дерева и обход
        1. Представление массива
        2. Порядок обхода предзаказа
        3. Смещения вместо указателей
        4. Структуры, удобные для кеширования (Недвоичные деревья)
        5. Узел дерева и порядок примитивов
        6. О рекурсии
        7. Группировка запросов
    7. Улучшенные запросы через кеширование
        1. Кэширование поверхности: кеширование пересекающихся примитивов
        2. Переднее отслеживание
    8. Резюме
7. # Пространственное разбиение
    1. Равномерная сетка
        1. Проблемы с размером ячейки
        2. Сетки как массивы связанных списков
        3. Хешированное хранилище и бесконечные сети
        4. Хранение статических данных
        5. Неявные сетки
        6. Объектно-объектный тест Равномерной сетки
            1. Один тест за раз
            2. Все тесты одновременно
        7. Дополнительные соображения по сетке
    2. Иерархические сетки
        1. Базовая реализация Hgrid
        2. Альтернативные иерархические сеточные представления
        3. Другие иерархические сетки
    3. Деревья
        1. Октодеревья (и Квадродеревья)
        2. Назначение объекта Октодерева
        3. Коды местоположения и поиск октанта для точки
        4. Линейные октодеревья (на основе хэша)
        5. Вычисление ключа Мортона
        6. Свободные октодеревья
        7. k-d Деревья
        8. Гибридные схемы
    4. Обход лучей и отрезков направленных линий
        1. k-d Тест на пересечение деревьев
        2. Тест на пересечение Равномерной сетки
    5. Методы сортировки и поиска
        1. Реализация отсортированного связного списка
        2. Сортировка по массивам
    6. Ячейки и порталы
    7. Избегание повторного тестирования
        1. Битовые флаги
        2. Штамп времени
        3. Амортизированная очистка штампов времени
    8. Резюме
8. # Иерархии деревьев BSP
    1. BSP Деревья
    2. Типы BSP-деревьев
        1. BSP-деревья с хранением узлов
        2. Деревья BSP с хранением Листов
        3. Деревья BSP с твердыми листьями
    3. Построение BSP-дерева
        1. Выбор разделяющих плоскостей
        2. Оценка разделяющих плоскостей
        3. Классификация полигонов по плоскости
        4. Разбиение полигонов на плоскости
        5. Подробнее об устойчивости к разбиению полигонов
        6. Настройка производительности дерева BSP
    4. Использование BSP Дерева
        1. Проверка точки на BSP-дереве с твердыми листьями
        2. Пересечение луча с твердолистным деревом BSP
        3. Многогранники на деревьях BSP с твердыми листьями
    5. Резюме
9. # Основанные на выпуклости методы
    1. Обнаружение столкновений на основе границ
    2. Алгоритмы с Ближайшими особенностями
        1. Алгоритм V-Clip
    3. Иерархические представления многогранников
        1. Иерархия Добкина–Киркпатрика
    4. Линейное и квадратичное программирование
        1. Линейное программирование
            1. Устранение Фурье–Моцкина
            2. Алгоритм Зейделя
        2. Квадратичное программирование
    5. Алгоритм Гилберта–Джонсона–Кирти
        1. Алгоритм Гилберта–Джонсона–Кирти
        2. Нахождение точки минимальной нормы в симплексе
        3. GJK, Ближайшие точки и контактные многообразия
        4. Восхождение на холм для экстремальных вершин
        5. Использование когерентности с помощью кэширования вершин
        6. Оптимизация вращающихся объектов
        7. GJK для движущихся объектов
    6. Алгоритм разделяющих векторов Чанга–Ванга
    7. Резюме
10. # Обнаружение столкновений с помощью GPU
    1. Взаимодействие с графическим процессором
        1. Считывание буфера
        2. Запросы окклюзии
    2. Тестирование выпуклых объектов
    3. Тестирование вогнутых объектов
    4. Фильтрация столкновений на основе графического процессора
    5. Резюме
11. # Числовая устойчивость
    1. Типы проблем устойчивости
    2. Представление действительных чисел
        1. Форматы с плавающей запятой IEEE-754
        2. Бесконечная арифметика
        3. Источники ошибок с плавающей точкой
    3. Надежное использование чисел с плавающей запятой
        1. Сравнение допусков для значений с плавающей запятой
        2. Надежность за счет толстых плоскостей
        3. Надежность за счет совместного использования расчетов
        4. Надежность толстых предметов
    4. Интервальная арифметика
        1. Примеры интервальной арифметики
        2. Интервальная арифметика при обнаружении столкновений
    5. Точные и полуточные вычисления
        1. Точная арифметика с использованием целых чисел
        2. Целочисленное деление
        3. Пересечение сегментов с использованием целочисленной арифметики
    6. Дальнейшие предложения по повышению надежности
    7. Резюме
12. # Геометрическая устойчивость
    1. Вершинная сварка
    2. Вычисление информации о смежности
        1. Вычисление таблицы Vertex-to-Face
        2. Вычисление таблицы Edge-to-Face
        3. Проверка связности
    3. Дыры, Трещины, Зазоры и Т-образные переходы 
    4. Объединение копланарных граней
        1. Проверка копланарности двух многоугольников
        2. Проверка плоскостности многоугольника
    5. Триангуляция и выпуклое разбиение
        1. Триангуляция путем разрезания ушей [1](https://ru.wikipedia.org/wiki/Задача_о_триангуляции_многоугольника#Отрезание_ушей)
            1. Триангуляция многоугольников с отверстиями
        2. Выпуклая декомпозиция многоугольников
        3. Выпуклое разложение многогранников
        4. Работа с «неразложимой» вогнутой геометрией
    6. Проверка непротиворечивости с использованием формулы Эйлера
    7. Резюме
13. # Оптимизация
    1. Кеши процессора
    2. Оптимизация кэша инструкций
    3. Оптимизация кэша данных
        1. Оптимизация структуры
        2. Квантованные и сжатые данные вершин
        3. Предварительная загрузка
    4. Структуры данных и алгоритмы с учетом кеширования
        1. Компактное статическое k-d дерево
        2. Компактное дерево AABB
        3. Кеширование забывчивости
    5. Программное кеширование
        1. Пример кэшированной линеаризации
        2. Амортизированное кэширование с предсказательной линеаризацией
    6. Сглаживание
        1. Анализ псевдонимов на основе типов
        2. Ограниченные указатели
        3. Избегание сглаживаний
    7. Параллелизм благодаря оптимизации SIMD
        1. SIMD-тест «Четыре сферы против четырех сфер»
        2. SIMD-тест «Четыре сферы против четырех AABB»
        3. SIMD-тест «Четыре AABB  против четырех AABB»
    8. Ветвление
    9. Резюме
14. Рекомендации
15. Индекс
16. О коде


# Введение

Это произведение посвящено теме обнаружения столкновений, широкой теме, связанной с, казалось бы, простой проблемой: обнаружение пересечения двух (или более) объектов. Обнаружение столкновений касается проблем определения того, **есть ли* соприкосновение, *когда* и *где* двух объектов. *“Есть ли”* включает установление логического результата, ответ на вопрос, пересекаются ли объекты. *“Когда”* дополнительно необходимо определить, в какое время во время движения произошло столкновение. *“Где”* устанавливает, как предметы входят в контакт. Грубо говоря, на эти три типа запросов становится все сложнее отвечать в указанном порядке. Сбор информации о том, когда и где (в дополнение к логическому результату обнаружения столкновения) иногда обозначается как *«обнаружение столкновения»*. Термины *«обнаружение пересечения»* и *«обнаружение помех»* иногда используются как синонимы «обнаружение столкновения».

Обнаружение столкновений является фундаментальным для многих разнообразных приложений, включая компьютерные игры, физическое моделирование (например, компьютерную анимацию), робототехнику, виртуальное прототипирование и инженерное моделирование (и это лишь некоторые из них). В компьютерных играх обнаружение столкновений гарантирует сохранение иллюзии твердого мира. Он не дает персонажам игроков проходить сквозь стены или проваливаться через пол; он обеспечивает запросы о прямой видимости, сообщая противникам, видят ли они игрока и, следовательно, могут ли они атаковать; и он удерживает скейтбордиста прикрепленным к невидимой направляющей поверхности, гарантируя, что игрок безопасно вернется в хафпайп после того, как поднялся в воздух.

В компьютерной анимации обнаружение столкновений используется, например, для ограничения физической симуляции ткани, чтобы одежда выглядела реалистично и не соскальзывала с персонажа при его движении. Обнаружение столкновений используется для планирования пути в робототехнике, помогая роботам избегать препятствий. В виртуальном прототипировании обнаружение столкновений помогает вычислить зазоры и в целом позволяет дорабатывать прототипы без создания физических моделей. Обнаружение столкновений используется в краш-тестах и другом инженерном моделировании.

Некоторые приложения, такие как планирование пути и рендеринг анимации, не требуют работы их систем столкновения в реальном времени. Другие приложения, в частности компьютерные игры, предъявляют особые требования к эффективности систем обнаружения столкновений в реальном времени. Экшн-игры для компьютеров и консолей включают моделирование, требующее выполнения большого количества запросов с частотой кадров от 30 до 60 кадров в секунду (fps). С такими жесткими временными ограничениями и с обнаружением столкновений, являющимся неотъемлемой частью игровых и физических движков, обнаружение столкновений может составлять большую часть времени, необходимого для создания игрового кадра. В компьютерных играх плохо спроектированная система столкновений может легко стать ключевым узким местом.

Это произведение не только об обнаружении коллизий в целом, но и конкретно об эффективной реализации структур данных и алгоритмов для решения проблем обнаружения коллизий в приложениях реального времени. В то время как область игр часто используется в качестве примеров, некоторые неигровые приложения имеют требования к производительности, аналогичные (или даже превышающие) требования к играм, включая системы тактильной (силовой обратной связи), симуляции частиц, хирургические симуляторы и другие симуляции виртуальной реальности. Описанные здесь методы одинаково хорошо применимы к этим приложениям.

Многие из обсуждаемых здесь методов применимы к областям, отличным от обнаружения столкновений. Например, методы, обсуждаемые в главах с 6 по 8, могут использоваться для ускорения трассировки лучей и их преобразования (например, для вычисления освещения сцены), а также в отношении географических информационных систем (ГИС) для ответа на запросы в больших географических базах данных. Некоторые проблемы из области компьютерной графики могут быть решены как проблемы обнаружения столкновений. Например, отсечение усеченного вида можно решить, используя методы, описанные в главах 6 и 7.

## 1.1 Обзор содержания

В следующих разделах дается краткое описание глав этой книги.

### 1.1.1 Глава 2: Проблемы проектирования обнаружения столкновений

В этой главе рассказывается о проблемах, которые необходимо учитывать при построении системы обнаружения столкновений, и о факторах, влияющих на проектирование. К таким факторам относятся то, как представлены объекты, их количество, как они перемещаются и какие типы запросов о столкновениях пользователь хочет задать. Глава 2 также знакомит с терминологией, которая используется в остальной части книги.

### 1.1.2 Глава 3: Учебник по математике и геометрии

Любая нетривиальная система обнаружения столкновений требует много математических расчетов, основанных на геометрии, чтобы определить, есть ли, когда и где для запросов столкновения. Глава 3 знакомит с математическими и геометрическими понятиями, необходимыми для понимания материала, изучаемого в остальных главах.

### 1.1.3 Глава 4: Граничные объемы

Чтобы ускорить выполнение запросов на столкновение, сначала используются простые геометрические объекты, такие как сферы и прямоугольники, для представления объектов более сложной природы. Только в случае столкновения «простых» ограничивающих объемов (которые достаточно велики для инкапсуляции сложных объектов) выполняются тесты на сложной геометрии. Глава 4 описывает несколько типов ограничивающих объемов, как выполнять для них тесты на пересечение и как подогнать ограничивающий объем к сложному объекту.

### 1.1.4 Глава 5: Базовые тесты примитивов

В предыдущей главе мы начали рассматривать тесты на пересечение. В главе 5 подробно описывается большое количество тестов для определения статуса пересечения и расстояния между парами объектов разного типа, включая линии, лучи, сегменты, плоскости, треугольники, многоугольники, сферы, параллелипипеды, цилиндры и многогранники. В этих тестах рассматриваются как статические, так и движущиеся объекты.

### 1.1.5 Глава 6: Иерархии ограничивающих объемов

Для больших объектов и для коллекций объектов повышение производительности может быть достигнуто за счет построения иерархий ограничивающих объемов над объектом (объектами). Такие иерархии обеспечивают быструю идентификацию объектов или частей объекта, которые не могут участвовать в столкновении, позволяя запросам ограничивать тестирование небольшим количеством объектов или частей объекта. В главе 6 рассказывается о желаемых характеристиках иерархий ограничивающих объёмов и способах построения и выполнения запросов к ним. В главе также исследуются эффективные способы представления этих иерархий.

### 1.1.6 Глава 7: Пространственное разбиение

Когда рассматривается большое количество объектов для столкновения, объекты должны быть разделены на небольшие непересекающиеся подгруппы для облегчения быстрых тестов (с целью избежать наихудшего квадратичного поведения тестирования всех объектов относительно всех других объектов). Иерархии ограничивающих объемов, обсуждаемые в главе 6, представляют собой один из способов выполнения такого разделения. Глава 7 исследует другие подходы к разделению, основанные на сетках, деревьях и сортировке объектов.

### 1.1.7 Глава 8: Иерархии деревьев BSP

Одной из наиболее универсальных древовидных структур для представления данных обнаружения столкновений является дерево разделения двоичного пространства (binary space partitioning, BSP). Деревья BSP можно использовать для разделения пространства независимо от объектов в пространстве. Их также можно использовать для отделения границы объекта от пространства, в котором он находится, тем самым эффективно формируя объемное представление объекта. Глава 8 рассказывает о надежном построении BSP-деревьев и о том, как выполнять тесты на полученных деревьях.

### 1.1.8 Глава 9: Основанные на выпуклости методы

Глава 9 рассматривает ряд более продвинутых методов выполнения запросов на столкновение с выпуклыми объектами, используя особые свойства выпуклых объектов. Представлены иерархические представления, алгоритм ближайших особенностей V-Clip, математические методы оптимизации линейного и квадратичного программирования, эффективный алгоритм Гилберта–Джонсона–Кирти и алгоритм разделяющих векторов Чанга и Ванга.

### 1.1.9 Глава 10: Обнаружение столкновений с помощью GPU

Обычные графические карты для ПК достигли такой степени, что обладают большей вычислительной мощностью, чем основной процессор ПК. Это изменение вызвало интерес к переложению вычислений на видеокарты. В главе 10 кратко рассказывается, как выполнять тесты обнаружения столкновений с использованием графического оборудования.

### 1.1.10 Глава 11: Числовая устойчивость

Даже самые маленькие ошибки в системе обнаружения столкновений могут привести к катастрофическим сбоям. Например: объекты не могут столкнуться со статическим пейзажем геометрии мира и, таким образом, выпадают из мира. В этой главе обсуждаются вопросы устойчивости, связанные с работой с арифметикой с плавающей запятой, и предлагаются подходы к решению этих проблем.

### 1.1.11 Глава 12: Геометрическая устойчивость

В то время как Глава 11 рассматривает, как надежно выполнять вычисления, Глава 12 рассматривает проблему взятия произвольного набора многоугольников и превращения его в хорошо сформированную геометрию, пригодную для ввода в систему обнаружения столкновений. Представлены методы сварки вершин, удаления зазоров и трещин, сращивания копланарных граней и разложения объектов на выпуклые (или треугольные) части.

### 1.1.12 Глава 13: Оптимизация

В последней главе книги рассказывается о том, как взять эффективные структуры данных и алгоритмы, представленные в книге, и сделать их еще более эффективными, нацелив и настроив их для конкретной аппаратной платформы. Значительный прирост производительности может быть достигнут за счет оптимизации кода для использования преимуществ иерархии памяти (кешей) и параллелизма кода и данных. В главе 13 представлено подробное описание того, как проводить такую оптимизацию.

## 1.2 О коде

В рамках практического характера этой книги многие из представленных идей дополняются примерами кода. В то время как многие книги полагаются исключительно на высокоуровневый псевдокод для передачи общих идей алгоритма, здесь большая часть кода дается на C++. Есть две причины для представления кода в этом виде. Во-первых, он предоставляет детали, которые часто жизненно важны для понимания (и реализации) алгоритма. Во-вторых, понимание теперь можно дополнительно получить, запустив код и изучив значения переменных во время выполнения. Последнее особенно важно для читателя, который не может полностью разбираться в математике, необходимой для реализации конкретного алгоритма. Лишь в нескольких местах книги данный код выражен псевдокодом, в основном там, где было бы непрактично предоставить полную реализацию.

Хотя C++ используется для кода в книге, следует подчеркнуть, что основное внимание в книге уделяется не C++. C++ используется только как средство для представления подробных исполняемых алгоритмов описанных концепций. Этой цели мог бы служить любой компьютерный язык, но C++ был выбран по нескольким причинам, включая его популярность и его способность кратко абстрагироваться от низкоуровневых манипуляций с геометрическими объектами, такими как точки и векторы, с использованием классов и (перегруженных) инфиксных операторов. Чтобы сделать представленный код доступным как можно большему количеству программистов (например, тех, кто знаком только с C или Java), по возможности намеренно избегали определенных функций C++, таких как шаблоны и STL (Стандартная библиотека шаблонов). Любители C++ могут захотеть сделать несколько глубоких вдохов в начале каждой главы!

Точно так же это не книга по разработке программного обеспечения. Чтобы основные идеи были представлены как можно лучше, код должен быть кратким и по существу. Были сделаны уступки, чтобы не загромождать текст подробным синтаксисом C++. Например, определения классов намеренно минималистичны (или отсутствуют), глобальные переменные иногда заменяют правильные переменные-члены, указатели не объявляются как константы (или ограничивают), а массивы часто объявляются фиксированного размера вместо того, чтобы динамически выделяться соответствующего размера. Имена переменных также были ограничены по длине, чтобы строки кода лучше вписывались на страницу набора.

Чтобы превратить представленный код в реальный производственный код, могут потребоваться некоторые дополнения. Например, тесты на деление на ноль не всегда выполняются, чтобы не вдаваться в детали, которые могут затруднить понимание общего подхода. Точно так же некоторые тесты кода могут потребовать добавления значений допуска для полной устойчивости. Цель состоит в том, чтобы обсудить надежность в главе 11, чтобы прояснить, какие изменения (если таковые имеются) необходимы для превращения представленного кода в надежный производственный код. Чтобы прояснить, какие аргументы функции являются входами, а какие - выходами, входные переменные часто передаются по значению, а выходные переменные - по ссылке. В некоторых случаях было бы более эффективно передавать входные переменные по ссылке. Это оставлено в качестве упражнения для читателя.

Комментарии набираются курсивом, а код - жирным шрифтом. Имена функций, классов, структур и определяемых пользователем типов начинаются с заглавной буквы, а переменные - с строчной буквы. Где возможно, имена переменных были выбраны в соответствии с обозначениями, используемыми в сопроводительном тексте. В некоторых случаях эти правила противоречат друг другу. Например, точки в тексте обозначаются заглавными буквами, а в коде - строчными.

Представленный в книге код реализован в большей степени в проекте Эрвина Куманса [«Bullet»](https://github.com/bulletphysics/bullet3).

# Глава 2
# Вопросы проектирования обнаружения столкновений

Проектирование эффективной системы обнаружения столкновений немного похоже на сборку головоломки: необходимо соединить множество частей, прежде чем появится общая картина. Подобным образом большая часть этой книги посвящена изучению отдельных частей, в которых используются различные подходы к обнаружению столкновений. Общая картина станет ясной по ходу книги. В этой главе дается краткий обзор ряда вопросов, которые необходимо учитывать при выборе подходов, и того, как соотносятся компоненты этих подходов. В этой главе также вводится ряд терминов, определения и пояснения которых будут даны в следующих главах. Более подробно затронутые здесь вопросы представлены в остальных главах книги.

## 2.1 Факторы проектирования алгоритма коллизий

Есть несколько факторов, влияющих на выбор, сделанный при разработке системы обнаружения столкновений. Эти факторы будут разбиты на следующие категории:

1. *Представление области приложения*. Геометрические представления, используемые для сцены и ее объектов, имеют прямое отношение к используемым алгоритмам. С меньшими ограничениями, накладываемыми на эти представления, необходимо использовать более общие решения по обнаружению столкновений с возможными последствиями для производительности.
2. *Различные типы запросов*. Как правило, чем более подробны типы запросов и результаты, тем больше вычислительных усилий требуется для их получения. Для поддержки определенных запросов могут потребоваться дополнительные структуры данных. Не все представления объектов поддерживают все типы запросов.
3. *Параметры моделирования окружающей среды*. Само моделирование содержит несколько параметров, оказывающих непосредственное влияние на систему обнаружения столкновений. Сюда входит количество объектов, их относительные размеры и положение, перемещаются ли они и как, разрешено ли им проникать друг в друга, и являются ли они жесткими или гибкими.
4. *Производительность*. Системы обнаружения столкновений в реальном времени работают с жесткими ограничениями по времени и размеру. Поскольку время и пространство всегда являются компромиссом, несколько функций обычно сбалансированы для удовлетворения заявленных требований к производительности.
5. *Надежность*. Не все приложения требуют одинакового уровня физического моделирования. Например, укладка кирпичей друг на друга требует гораздо большей сложности от системы обнаружения столкновений, чем наличие баскетбольного мяча, подпрыгивающего на баскетбольной площадке. Мяч, отскочивший слишком рано или под несколько большим углом, останется незамеченным, но даже малейшие ошибки в вычислении точек соприкосновения сложенных кирпичей могут привести к тому, что они медленно начнут проникать друг в друга или соскальзывать друг с друга.
6. *Простота реализации и использования*. Большинство проектов выполняются в установленные сроки. Планирование функций системы обнаружения столкновений ничего не значит, если система не может быть завершена и введена в эксплуатацию вовремя. Поэтому решения относительно простоты реализации играют большую роль в выборе подхода.

Эти вопросы более подробно рассматриваются в оставшейся части главы.

## 2.2 Представление области приложения

Чтобы выбрать подходящие алгоритмы обнаружения столкновений, важно учитывать типы геометрических представлений, которые будут использоваться для сцены и ее объектов. В этом разделе вкратце рассказывается о различных представлениях объектов, о том, как упрощенную геометрию можно использовать вместо геометрии моделирования, и как знание конкретных приложений может позволить использовать специализированные решения вместо более общих решений.

### 2.2.1 Представления объектов

В большинстве современных аппаратных средств в качестве основного примитива рендеринга используются треугольники. Следовательно, *многоугольное представление* является естественным выбором для сцен и объектов сцены, а также для их соответствующей геометрии столкновения. Самым общим полигональным представлением является *буфер из полигонов*: неупорядоченный набор полигонов без информации о связности, указывающей, как один полигон связан с другим. Без каких-либо ограничений, буфер из многоугольников является привлекательным представлением для художников и дизайнеров уровней. Алгоритмы, работающие с буферами полигонов, применимы к любому набору полигонов, но, как правило, менее эффективны и менее надежны, чем те, которые полагаются на дополнительную информацию. Например, многоугольный буфер не содержит информации о «внутренней части» объекта, поэтому нет простого способа узнать, оказался ли объект каким-то образом ошибочно внутри другого объекта. Упомянутая дополнительная информация может включать в себя, какие ребра соединяются с какими вершинами и какие грани соединяются с данной гранью, образует ли объект замкнутое твердое тело и является ли объект выпуклым или вогнутым.


**Рисунок 2.1** Геометрические модели, подобные изображенной на картинке, обычно строятся из набора полигональных сеток.

Многоугольники могут быть соединены друг с другом на своих краях, чтобы сформировать большую многоугольную поверхность, называемую *многоугольной сеткой*. Построение объектов из набора полигональных сеток - один из наиболее распространенных методов создания геометрических моделей (рис. 2.1).

Многоугольные объекты определяются в терминах их вершин, ребер и граней. Говорят, что при таком построении объекты имеют *явное* представление. *Неявные* объекты относятся к сферам, конусам, цилиндрам, эллипсоидам, торам и другим геометрическим примитивам, которые не определены явно таким образом, но неявно через математическое выражение. Неявные объекты часто описываются как отображение функций из трехмерного пространства в действительные числа, f:ℝ<sup>3</sup>→ℝ, где точки заданы f(x,y,z)<0
и принадлежат объекту, f(x,y,z)=0 граница, и f(x,y,z)>0 находятся вне объекта (рисунок 2.2). Граница объекта, определяемая неявной функцией, называется неявной поверхностью. Неявные объекты могут использоваться как грубые аппроксимации объектов сцены для быстрой отбраковки. Неявная форма может позволить проводить быстрые тесты на пересечение, особенно с линиями и лучами - факт, используемый в приложениях для трассировки лучей. Несколько примеров неявных тестов приведены в главе 5.

**Рисунок 2.2** Неявно определенная сфера (где сфера определяется как граница плюс внутренняя часть).

**Рисунок 2.3** (а) Куб с цилиндрическим отверстием в нем. (b) Дерево построения CSG для левого объекта, где цилиндр вычитается из куба.

Выпуклые многоугольные объекты также можно описать как пересечение ряда полупространств. Например, куб может быть выражен как пересечение шести полупространств, каждое полупространство «обрезает» часть пространства, лежащую за пределами грани куба. Полупространства и объемы пересечений полупространств более подробно описаны в главе 3.

Геометрические примитивы, такие как сферы, параллелипипеды и цилиндры, также являются строительными блоками объектов, созданных с помощью структуры конструктивной твердотельной геометрии (constructive solid geometry, CSG). Объекты CSG рекурсивно формируются путем применения теоретико-множественных операций (таких как объединение, пересечение или различие) с основными геометрическими фигурами или другими объектами CSG, что позволяет создавать объекты произвольной сложности. Таким образом, объект CSG представлен в виде (бинарного) дерева с теоретико-множественными операциями, заданными во внутренних узлах, и геометрическими примитивами в листьях (рис. 2.3). Объекты CSG подразумевают, что вершины, ребра и грани не доступны напрямую.

Сильной стороной CSG-моделирования является то, что результирующие объекты всегда действительны - без трещин и других проблем, мешающих полигональным представлениям. CSG также является представлением объёма, что позволяет легко определить, например, находится ли точка запроса внутри объекта CSG. CSG на многогранных объектах может быть реализован с помощью процессов, описанных, например, в [Laidlaw86] и [Thibault87]. Однако может быть трудно добиться надежных реализаций из-за неточности численных расчетов.

### 2.2.2 Столкновение против геометрии рендеринга

Хотя можно передать геометрию визуализации непосредственно в систему столкновений, есть несколько причин, по которым лучше иметь отдельную геометрию, с которой выполняется обнаружение столкновений.

1. Графические платформы продвинулись до такой степени, что визуализация геометрии становится слишком сложной, чтобы ее можно было использовать для обнаружения столкновений или физики. Кроме того, обычно существует ограничение на то, насколько точными должны быть столкновения. Таким образом, вместо использования той же геометрии, которая использовалась для рендеринга, для обнаружения столкновений вместо нее можно использовать упрощенную прокси-геометрию. В играх, например, принято полагаться на простые геометрические фигуры, такие как сферы и параллелипипеды, для представления игрового объекта, независимо от сложности объекта. Если прокси-объекты сталкиваются, предполагается, что сталкиваются и фактические объекты. Эти простые геометрические формы или *ограничивающие объемы* часто используются для ускорения запросов на столкновение независимо от того, какое геометрическое представление используется. Ограничивающие объемы обычно делаются так, чтобы полностью заключить геометрию. Граничные объемы подробно обсуждаются в Главе 4.

2. Для современного оборудования геометрия, как правило, задается в очень специфических форматах (таких как полосы треугольников и индексированные буферы вершин), которые позволяют быстро рендерить, но не обнаруживают столкновения. Вместо того, чтобы декодировать эти структуры на лету (даже если декодированные данные можно кэшировать для повторного использования), обычно более эффективно предоставить специальную геометрию столкновения. Кроме того, графическое оборудование часто поддерживает форматы только для треугольников. Для геометрии столкновения эффективность иногда может быть достигнута за счет поддержки других, нетреугольных примитивов.

3. Необходимые данные и организация данных для геометрии рендеринга и геометрии столкновений, вероятно, сильно различаются. В то время как данные статического рендеринга могут быть отсортированы по материалам, данные о столкновениях обычно организованы пространственно. Для визуализации геометрии требуются встроенные данные, такие как информация о материале, цвета вершин и координаты текстуры, тогда как геометрия столкновений требует связанных свойств поверхности. Разделение этих двух и хранение всей информации, относящейся к столкновениям, уменьшает данные о столкновении. Меньшие данные, в свою очередь, приводят к повышению эффективности за счет большей согласованности кэша данных.

4. Иногда геометрия столкновения отличается от визуализированной геометрии конструктивно. Например, снег по колено для игры сноуборд можно смоделировать с помощью поверхности столкновения на полметра ниже визуализированного представления поверхности снега. Аналогичным образом можно поступить с ходьбой по колышущейся траве по щиколотку или по мутной воде по пояс. Даже если геометрия визуализации используется в качестве геометрии столкновения, должны быть предусмотрены условия для исключения некоторой геометрии визуализации из (и для включения дополнительной геометрии без визуализации в) набор данных геометрии столкновения.

5. В целях моделирования данные о столкновениях должны храниться, даже если данные визуализации могут быть выброшены как невидимые. Поскольку геометрия столкновения меньше, чем соответствующая геометрия рендеринга, таким образом уменьшается объем постоянной памяти.

6. Исходная геометрия может быть представлена в виде полигонального буфера или сетки, тогда как для моделирования требуется представление твердотельного объекта. В этом случае гораздо проще вычислить твердую прокси-геометрию, чем пытаться каким-то образом укрепить исходное геометрическое представление.

Однако у использования раздельной геометрии столкновений есть некоторые потенциальные недостатки.

1. Дублирование данных (в основном вершин) приводит к использованию дополнительной памяти. Эту проблему можно облегчить, создав часть или всю геометрию столкновения из геометрии рендеринга на лету с помощью кэширования линеаризации (как описано в Разделе 13.5 и далее).

2. Для изготовления и поддержания двух наборов одинаковой геометрии может потребоваться дополнительная работа. Построение прокси-геометрии вручную ухудшит график ее создания. Если он построен с помощью инструмента, этот инструмент должен быть написан до того, как система столкновений станет пригодной для использования. Кроме того, если есть необходимость вручную изменить выходные данные инструмента, изменения необходимо каким-то образом передать обратно в инструмент и исходный набор данных.

3. Если они построены и поддерживаются отдельно, геометрия рендеринга и коллизий может не совпадать в разных местах. Когда геометрия столкновения не заполняет тот же объем, что и геометрия визуализации, объекты могут частично исчезать или парить над поверхностью других объектов.

4. Версии и другие проблемы логистики могут проявиться для двух геометрий. Была ли геометрия столкновения действительно перестроена при изменении геометрии рендеринга? Если создается вручную, что будет первым: геометрия столкновения или геометрия визуализации? И как вы обновляете одно, когда другое меняется?

Для игр достаточно хорошо работает использование прокси-геометрии, которая близка (но может не совсем соответствовать) реальным визуальным эффектам. С точки зрения восприятия люди не очень хорошо определяют, происходят ли точные столкновения. Чем больше задействовано объектов и чем быстрее они движутся, тем меньше вероятность того, что игрок заметит какие-либо несоответствия. Люди также плохо умеют предсказывать, каким должен быть исход столкновения, что позволяет проявлять вольность и при реагировании на столкновение. В играх обнаружением столкновений и реагированием на них можно эффективно управлять по принципу «если все выглядит правильно, значит, правильно». Другие приложения предъявляют более строгие требования к точности.

### 2.2.3 Специализация алгоритмов столкновений

Вместо того, чтобы иметь одну всеобъемлющую систему обнаружения столкновений, часто бывает целесообразно предоставить специализированные системы столкновений для конкретных сценариев. Примером того, где важна специализация, являются столкновения частиц. Вместо того, чтобы отправлять частицы одну за другой через обычную систему столкновений, они лучше обрабатываются и отправляются на столкновение как группы частиц, где группы могут формироваться и преобразовываться в зависимости от контекста. Частицы могут быть даже исключены из столкновения, в тех случаях, когда отсутствие столкновения не заметно.

Другой пример - использование отдельных алгоритмов для обнаружения столкновения между объектом и другими объектами, а также между объектом и сценой. Столкновения объект-объект могут быть даже дополнительно специализированы, чтобы персонаж игрока и быстро движущиеся снаряды обрабатывались иначе, чем другие объекты. Например, случай, когда все объекты всегда сталкиваются с персонажем игрока, лучше рассматривать как жестко запрограммированный тест, а не вставлять персонажа игрока в общую систему столкновений.

Рассмотрим также моделирование больших миров. Для маленьких миров данные о столкновениях могут всегда храниться в памяти. Однако в большом бесшовном мире данные о столкновениях должны загружаться и выгружаться по мере прохождения мира. В последнем случае наличие объектов, отделенных от мировой структуры, снова является привлекательным выбором, поэтому на объекты не влияют изменения мировой структуры. Возможный недостаток наличия отдельных структур для хранения, скажем, объектов и мира, заключается в том, что теперь выполнение запросов влечет за собой обход двух структур данных, а не только одной.

## 2.3 Типы запросов

Самый простой запрос на столкновение - это проблема *обнаружения пересечения* или *проверки пересечения*: ответ на логический вопрос о том, перекрываются ли два (статических) объекта, A и B, в их заданных положениях и ориентациях. Логические запросы пересечения быстро и легко реализовать, поэтому они широко используются. Однако иногда логического результата недостаточно и необходимо найти пересекающиеся части. Проблема *поиска пересечений* является более сложной, поскольку включает поиск одной или нескольких точек соприкосновения.

Для некоторых приложений достаточно найти какую-либо общую точку между объектами. В других случаях, например, при моделировании твердого тела, может потребоваться определение набора точек соприкосновения, то есть *контактного коллектора*. Надежное вычисление контактного многообразия - сложная задача. В целом, с *приблизительными запросами*, ответы на которые требуются только с точностью до заданного допуска, гораздо проще иметь дело, чем с *точными запросами*. Примерные запросы - обычное дело в играх. Кроме того, в играх запросы о столкновении обычно требуются для сообщения определенных свойств столкновения, назначенных объектам и их границам. Например, такие свойства могут включать скользкость дорожного покрытия или способность преодолевать подъем по поверхности стены.

Если объекты проникают, некоторые приложения требуют определения *глубины проникновения*. Глубина проникновения обычно определяется как *минимальное поступательное расстояние*: длина самого короткого вектора движения, который разделял бы объекты. В общем, вычисление этого вектора движения - сложная задача. *Расстояние разделения* между двумя непересекающимися объектами A и B определяется как минимум расстояний между точками в A и точками в B. Когда расстояние равно нулю, объекты пересекаются. Измерение расстояния между двумя объектами полезно, так как позволяет прогнозировать следующее столкновение. Более общая проблема заключается в нахождении *ближайших точек* к A и B: точки в A и точки в B, определяющих расстояние между объектами. Обратите внимание, что ближайшие точки не обязательно уникальны; может быть бесконечное количество ближайших точек. Для динамических объектов вычисление следующего времени столкновения известно как расчет *предполагаемого времени прибытия* (estimated time of arrival, ETA) или *времени столкновения* (time of impact, TOI). Значение ETA можно использовать, например, для управления временным шагом при моделировании твердого тела. Тип движения - один из параметров моделирования, обсуждаемых далее в следующем разделе.

## 2.4 Параметры моделирования окружающей среды

Как упоминалось ранее в этой главе, несколько параметров моделирования напрямую влияют на то, что является подходящим выбором для системы обнаружения столкновений. Чтобы проиллюстрировать некоторые из проблем, которые они могут вызвать, в следующих разделах конкретно рассматривается, как количество объектов и их перемещение связаны с обработкой столкновений.

### 2.4.1 Количество объектов

Поскольку любой объект потенциально может столкнуться с любым другим объектом, требуется симуляция с n объектами (n−1)+(n−2)+...+1=n(n−1)/2=O(n<sup>2</sup>) попарных тестов,
худший случай. Из-за квадратичной временной сложности наивное тестирование каждой пары объектов на столкновение быстро становится слишком дорогостоящим даже при умеренных значениях n. Снижение затрат, связанных с парным тестом, только линейно повлияет на время выполнения. Чтобы действительно ускорить процесс, необходимо уменьшить количество тестируемых пар. Это сокращение выполняется путем разделения обработки столкновений нескольких объектов на две фазы: *широкую фазу (broad phase)* и *узкую фазу (narrow phase)*.

На широкой фазе определяются более мелкие группы объектов, которые *могут* сталкиваться, и быстро исключаются те, которые определенно *не сталкиваются*. Узкая фаза представляет собой попарные тесты внутри подгрупп. Он отвечает за определение точных столкновений, если таковые имеются. Широкую и узкую фазы иногда называют обработкой n тел и парной обработкой соответственно.

На рисунке 2.4 показано, как широкофазная обработка снижает рабочую нагрузку за счет стратегии «разделяй и властвуй» (divide-and-conquer). Для 11 объектов (показаны прямоугольниками) для теста всех пар потребуется 55 тестов отдельных пар. После того, как обработка в широкой фазе дала 5 непересекающихся подгрупп (обозначенных заштрихованными областями), в узкой фазе нужно будет выполнить только 10 индивидуальных парных тестов. Методы обработки с широкой фазой обсуждаются в главах с 6 по 8. Обработка с узкой фазой рассматривается в главах 4, 5 и 9.

**Рисунок 2.4** На широкой фазе определяются непересекающиеся группы возможно пересекающихся объектов.

Помимо количества объектов, относительный размер объектов также влияет на количество тестов, которые необходимо выполнить. Когда в сцене присутствуют как маленькие, так и большие объекты, широкофазная система обычно должна работать усерднее (или быть более сложной) для идентификации групп, чем для набора однородных по размеру объектов. Как размер объекта влияет на широкофазовые методы, обсуждается далее в главе 7.

### 2.4.2 Последовательное или одновременное движение

В реальной жизни объекты движутся *одновременно* в течение заданного временного шага движения, и любые возможные столкновения разрешаются за этот временной шаг. Для точного компьютерного моделирования реального события необходимо каким-то образом определить самое раннее время контакта между любыми двумя движущимися объектами. Затем симуляцию можно продвинуть до этого момента времени, переместив все объекты в положение, в котором они были бы, когда произойдет первое столкновение. Затем столкновение разрешается, и процесс продолжает определять следующее столкновение, повторяя его до тех пор, пока не будет использован весь временной шаг движения.

Выполнение моделирования путем многократного перехода к следующему наиболее раннему моменту контакта становится довольно дорогостоящим. Например, когда один или несколько объектов упираются в поверхность, следующее столкновение происходит почти сразу после текущего времени столкновения. Таким образом, симуляция продвигается лишь на небольшую часть, и для определения полного временного шага перемещения может потребоваться практически «вечность». Одно из решений этой проблемы - использовать широкую фазу для идентификации групп объектов, которые могут взаимодействовать внутри группы, но не с объектами других групп в течение временного шага. Таким образом, моделирование каждой группы может выполняться с разной скоростью, помогая облегчить проблему в целом.

**Рисунок 2.5** (a) Вверху: Если оба объекта движутся одновременно, столкновения нет. Внизу: если круговой объект перемещается раньше треугольником, объекты сталкиваются. В (b) снова нет столкновения для одновременного движения, но для последовательного движения объекты сталкиваются. (c) объекты сталкиваются при одновременном движении, но не при последовательном движении.

Альтернативный вариант - перемещать объекты одновременно, но с фиксированным (маленьким) шагом по времени для перемещения. Одновременное движение может привести к взаимопроникновению объектов, с чем обычно нужно как-то бороться, например, путем резервного копирования моделирования в более раннее состояние. В обоих случаях одновременные обновления остаются дорогостоящими и поэтому часто используются для точного моделирования твердого тела. Однако многие игры, как и другие приложения, не являются симуляциями твердого тела, и было бы излишним и потраченным впустую попытки имитировать движение с высокой точностью. Для них альтернативным вариантом является *последовательное* разрешение движения. То есть объекты перемещаются по одному объекту за раз, и любые столкновения обнаруживаются и разрешаются до того, как процесс продолжится со следующим объектом.

Ясно, что последовательное движение не является физически точной моделью движения. Некоторые объекты могут столкнуться с объектами, которые еще не двигались в этом кадре, но которые бы сдвинулись с места, если бы два объекта двигались одновременно (рис. 2.5a). Другие объекты могут столкнуться с объектами, которые двигались раньше, а теперь находятся на их пути (рис. 2.5b). В некоторых случаях, когда два одновременно движущихся объекта столкнулись бы на полпути своего движения, столкновения теперь будут пропускаться, поскольку один объект перемещается мимо другого (рис. 2.5c). В играх, например, проблемы, связанные с моделью последовательного движения, часто можно игнорировать. Высокая частота кадров в играх часто делает шаг движения настолько маленьким, что перекрытие также невелико и не очень заметно.

Одним из преимуществ модели последовательного движения является то, что инвариант непроникания объекта очень легко поддерживать. Если во время движения объекта происходит столкновение, движение можно просто отменить (например). Только необходимость отменить движение одного объекта следует противопоставить модели одновременного движения с фиксированным временным шагом, в которой движение всех одновременно перемещаемых объектов должно быть отменено.

### 2.4.3 Дискретное и непрерывное движение

То, что может сильно повлиять как на вычислительные усилия, необходимые для определения результата столкновения, так и на точность самого результата, заключается в том, что два объекта, участвующие в парном тесте, движутся во время тестирования. *Обнаружение статического столкновения* включает обнаружение пересечения между объектами в дискретные моменты времени во время их движения. В каждый такой момент времени объекты обрабатываются так, как если бы они были неподвижны в своих текущих положениях с нулевой скоростью. Напротив, *динамическое обнаружение столкновений* учитывает полное непрерывное движение объектов в течение заданного интервала времени. Динамические тесты столкновения обычно могут сообщать точное время столкновения и точку (точки) первого контакта. Статические тесты (намного) дешевле, чем динамические, но интервалы времени между тестами должны быть короткими, чтобы движение объектов было меньше пространственной протяженности объектов. В противном случае объекты могут просто переходить друг друга от одного временного шага к следующему без обнаружения столкновения. Это явление называется *туннелированием*.

Объем, покрываемый объектом, непрерывно движущимся за заданный промежуток времени, называется *охватываемым объемом (swept volume)*. Если эти объемы двух движущихся объектов не пересекаются, значит, между объектами нет пересечения. Даже если охватываемые объемы пересекаются, объекты могут не пересекаться во время движения. Таким образом, пересечение охватываемых объемов является достаточным, но не необходимым условием столкновения объектов. Для сложных движений охватываемый объем сложно вычислить и с ним работать. К счастью, идеальная точность требуется редко. Динамическое испытание на столкновение сложных опрокидывающихся движений обычно можно упростить, допустив кусочно-линейное движение; то есть линейное перемещение по диапазону движения с мгновенным вращением в конце (или начале) движения. Где-то между этими двумя альтернативами находится замена неограниченного движения винтовым движением (то есть фиксированным вращательным и поступательным движением).

При работе с движущимися объектами практически всегда предпочтительно учитывать относительное движение объектов, вычитая движение одного объекта из другого объекта, таким образом фактически оставляя один объект статичным. Предполагая линейное поступательное движение для объектов, эта операция представляет собой простое вычитание вектора. Ключевым преимуществом рассмотрения только относительного движения является то, что для тестирования одного движущегося объекта относительно неподвижного объекта тест с охватываемым объемом теперь является тестом на точное пересечение. В играх весь охватываемый объем иногда просто заменяется *скоростным коробкой*: продолговатым прямоугольником, закрывающим весь диапазон движения объекта (или каким-либо аналогичным простым прокси-объектом, не обязательно прямоугольником).

## 2.5 Производительность

Если взять в качестве примера игровые приставки, для получения наилучших визуальных эффектов игры должны работать со скоростью 60 кадров в секунду (в странах с форматом NTSC TV; 50 кадров в секунду на территории PAL). Эта частота кадров оставляет 16,7 мс для подготовки каждого игрового кадра. В зависимости от типа игры обнаружение столкновений может составлять, скажем, от 10 до 30% кадра, в свою очередь оставляя от 2 до 5 мс для обнаружения столкновений. Для платформенной игры, в которой могут быть десятки объектов, зависящих от столкновений, активных в данный момент времени, для обработки столкновения для каждого объекта может быть доступно только от 50 до 250 мкс - это немного времени. Ясно, что очень важно уменьшить среднее время выполнения запросов на столкновение. Однако, поскольку в играх очень заметны большие внезапные падения частоты кадров, также важно убедиться, что худший случай для выбранных алгоритмов не занимает больше времени, чем в среднем.

Можно сделать несколько вещей, чтобы ускорить обработку столкновений, чему в значительной степени и посвящена это произведение. Некоторые общие идеи относительно того, какие оптимизации важны для обнаружения столкновений, обсуждаются в следующем разделе.

### 2.5.1 Обзор оптимизации

Первый принцип оптимизации заключается в том, что нет ничего быстрее, чем вообще не выполнять задачу. Таким образом, некоторые из наиболее успешных оптимизаций скорости вращаются вокруг как можно более быстрого сокращения объема работы до минимально возможного. Таким образом, одной из наиболее важных оптимизаций для системы обнаружения столкновений является широкая фаза обработки, упомянутая в разделе 2.4.1, то есть использование пространственной локализации объектов. Поскольку объекты могут поражать только те предметы, которые находятся рядом с ними, испытаний с удаленными объектами можно избежать, разбив их по пространству. Затем тесты производятся только в отношении областей, расположенных непосредственно рядом с объектом, игнорируя те, которые находятся слишком далеко, чтобы пересекать объект. Есть сильное сходство между этим пространственным разделением и тем, что сделано для отсечения вида, чтобы ограничить количество нарисованных графических объектов.

Пространственное разделение может быть выполнено с использованием плоской структуры, например, путем разделения пространства на сетку ячеек одинакового размера. Это также может быть реализовано в терминах иерархии, где пространство рекурсивно делится пополам, пока не будет достигнута некоторая цель завершения. Затем объекты вставляются в сетку или иерархию. Сетки и иерархическое разбиение также полезны для парных тестов узкой фазы, особенно когда объекты имеют высокую сложность. Вместо того, чтобы тестировать один объект против другого, они позволяют ограничить тесты столкновений частями двух ближайших друг к другу объектов. Объектное и пространственное разбиение обсуждается в главах 6 и 7.

Проведение недорогих тестов ограничивающего объема перед выполнением более дорогих геометрических тестов также является хорошим способом сократить объем работы, необходимой для определения столкновения. Скажем, охватывающие ограничивающие сферы были добавлены ко всем объектам, тогда простой тест на пересечение сфер со сферами теперь покажет - когда сферы не перекрываются - что дальнейшее тестирование сложной содержащейся геометрии не требуется. Граничные объемы рассматриваются в главе 4.

Понимание того, что объекты имеют тенденцию делать небольшие локальные шаги от кадра к кадру - если они вообще перемещаются - приводит к третьей важной оптимизации: использовать эту *временную (или от кадра к кадру) когерентность*. Например, нужно тестировать только объекты, которые переместились с момента последнего кадра; статус столкновения остается таким же для других объектов. Временная когерентность также может позволить кэшировать данные и вычисления и повторно использовать их в одном или нескольких будущих кадрах, что ускоряет тесты. Предположения, основанные на согласованности движений, очевидно, становятся недействительными, если объектам разрешено «телепортироваться» в произвольные места. Согласованность более подробно обсуждается в главе 9.

Наконец, очень важны оптимизации для конкретной архитектуры. Многие платформы поддерживают некоторый тип кода или параллелизм данных, которые при полном использовании могут обеспечить значительное ускорение. Из-за больших различий между скоростью, с которой работают ЦП, и скоростью, с которой основная память может предоставлять данные для работы (с преимуществом скорости для ЦП), то, как геометрия столкновений и другие данные хранятся в памяти, также может иметь огромное влияние скорости на систему столкновения. Эти вопросы подробно рассматриваются в главе 13.

## 2.6 Надежность

Обнаружение столкновений - одно из множества геометрических приложений, для которых очень важна надежность. В этой книге надежность используется просто для обозначения способности программы работать с численными вычислениями и геометрическими конфигурациями, с которыми в некотором роде трудно справиться. Столкнувшись с такими проблемными входными данными, надежная программа дает ожидаемые результаты. Ненадежная программа может в тех же ситуациях аварийно завершиться или зайти в бесконечный цикл. Проблемы устойчивости можно в общих чертах разделить на два класса: проблемы, связанные с отсутствием *числовой устойчивости*, и проблемы, связанные с отсутствием *геометрической устойчивости*.

Проблемы числовой устойчивости возникают из-за использования переменных конечной точности во время вычислений. Например, когда промежуточные вычисления становятся больше, чем может быть представлено переменной с плавающей точкой или целым числом, промежуточный результат будет недействительным. Если такие проблемы не обнаружены, окончательный результат вычисления также может быть неверным. Надежные реализации должны гарантировать невозможность возникновения таких проблем, или если они это сделают, вместо них будут возвращены скорректированные действительные результаты.

Геометрическая устойчивость влечет за собой обеспечение топологической правильности и общей геометрической согласованности. Проблемы часто связаны с невозможной или вырожденной геометрией, что может быть результатом неправильного численного расчета. Большинство алгоритмов на том или ином уровне ожидают правильно сформированных входных данных. Если задана неправильная входная геометрия, например, треугольники, вырождающиеся в точку, или многоугольники, не все вершины которых лежат в плоскости, может произойти что угодно, если эти случаи не будут обнаружены и рассмотрены.

Иногда трудно провести различие между числовой и геометрической надежностью, поскольку одно может порождать другое. Чтобы избежать неясных и трудно исправляемых ошибок времени выполнения, надежность должна рассматриваться как при проектировании, так и при разработке системы обнаружения столкновений. В главах 11 и 12 устойчивость обсуждается более подробно.

## 2.7 Простота реализации и использования

В случае внедрения системы обнаружения столкновений с нуля вопрос ожидаемого времени разработки может быть столь же важным, как и желаемый набор функций. Например, игры часто имеют ограниченный бюджет и временные рамки, и задержка любого критического компонента может дорого обойтись. При оценке простоты реализации интересно посмотреть не только на общую сложность алгоритма, но и на то, сколько и какого типа особые случаи задействованы, сколько задействованных переменных настройки (таких как числовые допуски) и другие ограничения, которые могут повлиять на время разработки.

Несколько дополнительных вопросов связаны с использованием системы обнаружения столкновений. Например, насколько общая система? Может ли она работать с объектами самых разных размеров? Может ли она также отвечать на различные запросы? Сколько времени требуется в процессе сборки для создания структур данных, связанных с конфликтами? Что касается последнего вопроса, хотя время, затрачиваемое на предварительную обработку, не имеет значения для производительности во время выполнения, оно все ещё важно на этапе проектирования и производства. В процессе разработки модели часто меняются, а длительное время предварительной обработки снижает производительность и затрудняет экспериментирование. Некоторые из этих вопросов можно решить, допустив более быстрое и менее оптимизированное построение структуры данных во время разработки, а также более медленное, но более оптимальное построение для неотладочных сборок.

### 2.7.1 Отладка системы обнаружения столкновений

Как и весь код, системы обнаружения столкновений подвержены ошибкам. Поиск этих ошибок иногда может быть трудным и требовать много времени. Во время разработки можно предпринять шаги, чтобы сделать этот процесс отладки менее болезненным. Вот несколько хороших идей:

- Храните циклический буфер аргументов для n последних запросов о конфликте, соответствующих данным за несколько секунд (или больше). Затем, когда что-то пойдет не так, программа может быть приостановлена, а данные могут быть выведены для дальнейшего анализа, например, для пошагового выполнения вызовов с сохраненными аргументами. Регистрируемые данные также могут предоставить полезную информацию при срабатывании утверждения.
- Предоставьте средства для визуализации геометрии столкновения. Например, вы можете визуализировать проверенные поверхности, их атрибуты столкновения, а также любые иерархии и группировки поверхностей. Кроме того, визуализируйте сами запросы на столкновение, предпочтительно с историей, предоставленной циклическим буфером, упомянутым ранее. Эта визуализация обеспечивает контекст, который позволяет легко выявлять неверные запросы на столкновение.
- Реализуйте простой *эталонный алгоритм* (например, алгоритм перебора, который проверяет все объекты или все полигоны относительно друг друга) и запускайте эталонный алгоритм параллельно с более сложным алгоритмом. Если результаты различаются, есть проблема (по всей видимости, с более продвинутым алгоритмом).
- Поддерживайте набор тестов и запускайте код столкновения с набором тестов при изменении кода. Код геометрической природы, как правило, имеет множество особых случаев, и наличие набора всеобъемлющих тестов помогает в раннем обнаружении проблем. Каждый раз, когда обнаруживается ошибка, добавляйте тестовые примеры, чтобы определить, появляется ли она когда-либо повторно.

Конечно, также применимы все общие стратегии отладки, такие как использование вызовов **assert()**. Хорошее обсуждение таких стратегий можно найти в [McConnell93,
Глава 26].

## 2.8 Резюме

В этой главе описаны многие факторы, которые необходимо учитывать при разработке и внедрении системы обнаружения столкновений. В нем говорилось о возможных представлениях геометрии столкновений и о том, следует ли использовать геометрию рендеринга или специальную геометрию для выполнения тестов столкновений. Обработка коллизий была определена как происходящая в два этапа: узкую и широкую. Широкая фаза связана с грубым определением небольших подгрупп потенциально сталкивающихся объектов, тогда как узкая фаза выполняет подробные тесты парных столкновений между объектами. Узкофазное тестирование является основной темой глав 4 и 5, где обсуждается множество различных типов запросов для самых разных геометрических представлений объектов. Узкофазное тестирование также обсуждается в главе 9. Широкофазовые методы обсуждаются в главах с 6 по 8. Была подчеркнута важность устойчивости. В этой книге две полные главы посвящены теме устойчивости, главы 11 и 12. Поскольку эта книга посвящена обнаружению столкновений для приложений реального времени, производительность также была подчеркнута как важное системное соображение. В некотором смысле большая часть книги посвящена производительности, поскольку на протяжении всего ее обсуждения обсуждаются эффективные алгоритмы и структуры данных. Книга завершается обсуждением оптимизации в главе 13.

```
    // Compute variance of a set of 1D values
    float Variance(float x[], int n)
    {
        float u = 0.0f;
        for (int i = 0; i < n; i++)
        u += x[i];
        u /= n;
        float s2 = 0.0f;
        for (int i = 0; i < n; i++)
        s2 += (x[i] - u) * (x[i] - u);
        return s2 / n;
    }
```

$$\alpha$$

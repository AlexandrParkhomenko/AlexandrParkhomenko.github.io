---
layout: default
title: "Робототехника"
description: "Физика столкновений на примере свободного физического движка реального времени Эрвина Куманса Bullet"
date: 
---


$P = C + x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (оригинальное выражение)

$P − C = x \textbf u_0 + y \textbf u_1 + z \textbf u_2$ ⇔ (перемещение C влево)

$(P − C) · \textbf u_0 = (x \textbf u_0 + y \textbf u_1 + z \textbf u_2 ) · \textbf u_0$ ⇔ (взяв скалярное произведение с $u_0$ с обеих сторон)

$(P − C) · \textbf u_0 = x( \textbf u_0 · \textbf u_0 ) + y( \textbf u_1 ·  \textbf u_0 ) + z( \textbf u_2 · \textbf u_0 )$ ⇔ (расширение выражения скалярного произведения)

$(P − C) · \textbf u_0 = x$ (упрощение использования $\textbf u_0 · \textbf u_0 = 1$, $\textbf u_1 · \textbf u_0 = \textbf u_2 · \textbf u_0 = 0$)

Таким образом, полный набор координат OBB представлен в виде $x = (P − C) · \textbf u_0$ , $y = (P − C) · \textbf u_1$ ,
и $z = (P − C) · \textbf u_2$.

Чтобы вычислить точку R на (или в) B, ближайшую к P, можно применить тот же подход, что и для AABB, выразив P в системе координат OBB как Q, ограничив Q до значений $e_0$, $e_1$ и $e_2$ и повторное выражение Q в мировых координатах. Код для этого следующий.

```cpp
// Для данной точки p вернуть точку q на (или в) OBB b, ближайшую к p
void ClosestPtPointOBB(Point p, OBB b, Point &q){
    Vector d = p - b.c;
    // Начальный результат в центре П-да; делать шаги оттуда
    q = b.c;
    // Для каждой оси OBB...
    for (int i = 0; i < 3; i++) {
        // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра параллелипипеда
        float dist = Dot(d, b.u[i]);
        // Если расстояние больше, чем размер параллелипипеда, зажмите параллелипипеда
        if (dist > b.e[i]) dist = b.e[i];
        if (dist < -b.e[i]) dist = -b.e[i];
        // Изменить это расстояние по оси, чтобы получить мировую координату
        q += dist * b.u[i];
    }
}
```

Математически описанный метод эквивалентен преобразованию точки P в локальную систему координат OBB, вычислению точки на OBB (теперь фактически AABB), ближайшей к преобразованной точке, и преобразованию полученной точки обратно в мировые координаты.

#### 5.1.4.1 Расстояние от точки до OBB

Чтобы получить квадрат расстояния между точкой P и ближайшей точкой на OBB B, предыдущая функция может быть вызвана таким образом:

```cpp
    // Вычислить квадрат расстояния между точкой p и OBB b
    float SqDistPointOBB(Point p, OBB b){
        Point closest;
        ClosestPtPointOBB(p, b, closest);
        float sqDist = Dot(closest - p, closest - p);
        return sqDist;
    }
```
Если нужен только квадрат расстояния, а не ближайшая точка, этот код можно еще больше упростить. Путем проецирования вектора $\textbf v$ из центра B в P на каждую из трех осей OBB получается расстояние d от P до центра параллелипипеда вдоль этой оси. Поскольку оси ортогональны, любое избыточное количество, которое d выходит за пределы параллелипипеда для данной оси, может быть вычислено, возведено в квадрат и добавлено к общему квадрату расстояния P независимо от двух других осей.

```cpp
// Вычислить квадрат расстояния между точкой p и OBB b
float SqDistPointOBB(Point p, OBB b){
    Vector v = p - b.c;
    float sqDist = 0.0f;
    for (int i = 0; i < 3; i++) {
        // Спроецировать вектор от центра параллелипипеда до точки p на каждой оси, получить расстояние
        // p вдоль этой оси, и подсчитать любое превышение расстояния за пределами параллелипипеда
        float d = Dot(v, b.u[i]), excess = 0.0f;
        if (d < -b.e[i])
        excess = d + b.e[i];
        else if (d > b.e[i])
        excess = d - b.e[i];
        sqDist += excess * excess;
    }
    return sqDist;
}
```

#### 5.1.4.2 Ближайшая точка на 3D-прямоугольнике к точке

Определение точки Q на трехмерном прямоугольнике R, ближайшей к данной точке P, фактически эквивалентно задаче поиска ближайшей точки на OBB, поскольку трехмерный прямоугольник можно рассматривать как OBB с нулевой протяженностью по оси z.

Таким образом, прямоугольник определяется центральной точкой C, двумя ортогональными единичными векторами $\textbf u_0$ и $\textbf u_1$, определяющими ориентацию осей x и y R, и двумя скалярными значениями $e_0$ и $e_1$, определяющими пределы полуширины прямоугольника вдоль каждого ось. В этом представлении все точки S, содержащиеся в R, имеют вид $S = C + a \textbf u_0 + b \textbf u_1$ , где $|a| ≤ e 0$ и $b ≤ e_1$ . Выраженная в виде кода, эта прямоугольная структура становится:

```cpp
struct Rect {
Point c;     // центральная точка прямоугольника
Vector u[2]; // единичные векторы, определяющие локальные оси x и y для прямоугольника
float e[2];  // размеры полуширины прямоугольника по осям
};
```

Переписывание кода **ClosestPtPointOBB()** для учета оси z нулевой протяженности приводит к следующему коду для поиска ближайшей точки на 3D прямоугольнике.

```cpp
    // Для данной точки p вернуть точку q на (или в) прямоугольнике r, ближайшем к p
    void ClosestPtPointRect(Point p, Rect r, Point &q){
        Vector d = p - r.c;
        // Начальный результат в центре прямоугольника; делать шаги оттуда
        q = r.c;
        // Для каждой оси прямоугольника...
        for (int i = 0; i < 2; i++) {
            // ...спроецировать d на эту ось, чтобы получить расстояние по оси d от центра прямоугольника
            float dist = Dot(d, r.u[i]);
            // Если расстояние больше, чем размеры прямоугольника, зажмите прямоугольник
            if (dist > r.e[i]) dist = r.e[i];
            if (dist < -r.e[i]) dist = -r.e[i];
            // Изменить это расстояние по оси, чтобы получить мировую координату
            q += dist * r.u[i];
        }
    }
```

Трехмерный прямоугольник R также может быть задан тремя точками (A, B и C), такими, что векторы B − A и C − A охватитывают прямоугольник. Теперь все точки S в R имеют вид $S = A + u(B − A) + v(C − A)$, $0 ≤ u ≤ 1$, и $0 ≤ v ≤ 1$. В этом сценарии можно использовать аналогичный проекционный подход (но с поправкой на новые интервалы ограничения). Оптимизация реализации для этого случая приводит к следующему коду.


```cpp
// Возвратить точку q на (или в) прямоугольнике (указанном a, b и c), ближайшем к данной точке p
void ClosestPtPointRect(Point p, Point a, Point b, Point c, Point &q){
    Vector ab = b - a; // вектор через прямоугольник
    Vector ac = c - a; // вектор вниз прямоугольника
    Vector d = p - a;
    // Начать результат в верхнем левом углу прямоугольника; делать шаги оттуда
    q = a;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник в поперечном направлении
    float dist = Dot(d, ab);
    float maxdist = Dot(ab, ab);
    if (dist >= maxdist)
    q += ab;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ab;
    // Зажмите p’ (проекция p на плоскость r), чтобы прямоугольник был направлен вниз
    dist = Dot(d, ac);
    maxdist = Dot(ac, ac);
    if (dist >= maxdist)
    q += ac;
    else if (dist > 0.0f)
    q += (dist / maxdist) * ac;
}
```

Это немного дороже, чем первоначальный подход, так как он не выигрывает от нормализации векторов поперек и вниз прямоугольника на этапе предварительного вычисления.

### 5.1.5 Ближайшая точка на Треугольнике к Точке

Даны треугольник ABC и точка P, пусть Q описывает точку на ABC, ближайшую к P. Один из способов получить Q - это полагаться на тот факт, что если P ортогонально проецируется внутрь ABC, точка проекции является ближайшей точкой Q. Если P проецируется вне ABC, ближайшая точка должна лежать на одном из его краев. В этом случае Q можно получить, вычислив точку, ближайшую к P для каждого из отрезков AB, BC и CA, и вернув вычисленную точку, ближайшую к P. Хотя это работает, это не очень эффективный подход. Лучшее решение - вычислить, в какой из характерных областей Вороного треугольника P находится.

**Рисунок 5.5**. Область Вороного вершины A, VR(A), является пересечением отрицательных полупространств двух плоскостей $(X – A) · (B – A) = 0$ и $(X – A) · (C – A) = 0$.

После определения необходимо вычислить только ортогональную проекцию P на соответствующий объект, чтобы получить Q.

Чтобы увидеть, как можно определить, что P находится в области Вороного вершины, рассмотрим область Вороного вершины A. Эта область определяется как пересечение отрицательных полупространств двух плоскостей, проходящих через A, одной с нормалью B - A и другой с нормальным C - A (как показано на рисунке 5.5).

Определить, находится ли P в одной из краевых областей Вороного, можно несколькими способами. Оказывается, что эффективный тест состоит в том, чтобы эффективно вычислить барицентрические координаты ортогональной проекции R точки P на ABC. Напомним из раздела 3.4, что барицентрические координаты R задаются как отношения (пропорциональные) площадей со знаком треугольников RAB, RBC и RCA к площади со знаком ABC. Пусть n - нормаль к ABC и пусть $R = P − t \textbf n$ для некоторой t. Барицентрические координаты $(u, v, w)$ для $R, R = uA + vB + wC$, затем можно рассчитать по количеству

```cpp
Vector n = Cross(b - a, c - a);
float rab = Dot(n, Cross(a - r, b - r)); // пропорционально обозначненной области RAB
float rbc = Dot(n, Cross(b - r, c - r)); // пропорционально обозначненной области RBC
float rca = Dot(n, Cross(c - r, a - r)); // пропорционально обозначненной области RCA
float abc = rab + rbc + rca; // пропорционально обозначненной области ABC
```

как $u = rbc/abc$, $v = rca/abc$, и $w = rab/abc$. Однако небольшая векторная арифметика показывает, что эти выражения упрощаются. Например, выражение для rab упрощается следующим образом:

- $\textbf n · ((A − R) × (B − R))$ = (оригинальное выражение)
- $\textbf n · (A × (B − R) − R × (B − R))$ = (раскрытие векторного произведения)
- $\textbf n · (A × B − A × R − R × B)$ = (раскрытие векторного произведения; удаление $\textbf n · (R × R) = 0$ члена)
- $\textbf n · (A × B − A × (P − t \textbf n) − (P − t \textbf n) × B)$ = (замена $R = P − tn$ для $R$)
- $\textbf n · (A × B − A × P + tA × \textbf n − P × B + t \textbf n × B)$ = (раскрытие скалярного произведения)
- $\textbf n · (A × B − A × P − P × B + t \textbf n × (B − A))$ = (группировка аналогичных членов)
- $\textbf n · (A × B − A × P − P × B)$ = (удаление $\textbf n · (t \textbf n × (B − A)) = 0$ члена)
- $\textbf n · ((A − P) × (B − P))$ (объединение векторного произведения после добавления $\textbf n · (P × P) = 0$ члена)

Другими словами, барицентрические координаты R могут быть получены непосредственно из P без вычисления R.

**Рисунок 5.6**. Когда угол в A тупой, P может лежать в области Вороного ребра CA, даже если P лежит вне AB, а не в областях вершины Вороного A или B.

Чтобы $P$ лежал в краевой области Вороного - например, область, соответствующая краю $AB - P$ должна лежать вне или на $AB$, обозначенном $rab ≤ 0$, а также в положительных полупространствах плоскостей $(X - A ) · (B - A)=0$ и $(X - B) · (A - B)=0$. Обратите внимание, что недостаточно просто проверить, находится ли $P$ вне $AB$, в этом случае для треугольника с тупым углом в $A$ , $P$ может находиться вне $AB$ и фактически находиться в области Вороного края $CA$ (рис. 5.6). (Точно так же распространенной ошибкой является предположение, например, что $A$ является ближайшей точкой к $P$, если $P$ лежит вне $AB$ и $(P - A) · (B - A) <0$.) Если $P$ не находится в любой из вершин или ребер Вороного область $Q$ должна лежать внутри $ABC$ и, фактически, ортогональная проекция R, которую теперь можно легко вычислить согласно предыдущему. Этой информации теперь достаточно, чтобы создать кодовое решение.

```cpp
Point ClosestPtPointTriangle(Point p, Point a, Point b, Point c){
    Vector ab = b - a;
    Vector ac = c - a;
    Vector bc = c - b;
    // Вычислить параметрическое положение s для проекции P’ точки P на AB,
    // P’ = A + s*AB, s = snom/(snom+sdenom)
    float snom = Dot(p - a, ab), sdenom = Dot(p - b, a - b);
    // Вычислить параметрическое положение t для проекции P’ точки P на AC,
    // P’ = A + t*AC, s = tnom/(tnom+tdenom)
    float tnom = Dot(p - a, ac), tdenom = Dot(p - c, a - c);
    if (snom <= 0.0f && tnom <= 0.0f) return a;
    // Вершинная область рано ушла
    // Вычислить параметрическое положение u для проекции P’ точки P на BC,
    // P’ = B + u*BC, u = unom/(unom+udenom)
    float unom = Dot(p - b, bc), udenom = Dot(p - c, b - c);
    if (sdenom <= 0.0f && unom <= 0.0f) return b; // Вершинная область рано ушла
    if (tdenom <= 0.0f && udenom <= 0.0f) return c; // Вершинная область рано ушла
    // P находится вне (или на) AB, если тройное скалярное произведение [N PA PB] <= 0
    Vector n = Cross(b - a, c - a);
    float vc = Dot(n, Cross(a - p, b - p));
    // Если P за пределами AB и внутри характерной области AB, 
    // вернуть проекцию P на AB
    if (vc <= 0.0f && snom >= 0.0f && sdenom >= 0.0f)
        return a + snom / (snom + sdenom) * ab;
    // P находится вне (или на) BC, если тройное скалярное произведение [N PB PC] <= 0
    float va = Dot(n, Cross(b - p, c - p));
    // Если P за пределами BC и в пределах характерного региона BC,
    // вернуть проекцию P на BC
    if (va <= 0.0f && unom >= 0.0f && udenom >= 0.0f)
        return b + unom / (unom + udenom) * bc;
    // P находится вне (или на) CA, если тройное скалярное произведение [N PC PA] <= 0
    float vb = Dot(n, Cross(c - p, a - p));
    // Если P за пределами CA и в пределах функционального региона CA,
    // вернуть проекцию P на CA
    if (vb <= 0.0f && tnom >= 0.0f && tdenom >= 0.0f)
        return a + tnom / (tnom + tdenom) * ac;
    // P должен выступать внутри области грани. Вычислить Q, используя барицентрические координаты
    float u = va / (va + vb + vc);
    float v = vb / (va + vb + vc);
    float w = 1.0f - u - v; // = vc / (va + vb + vc)
    return u * a + v * b + w * c;
}
```

В представленном виде этот код содержит четыре вызова векторного произведения. Поскольку вычисление векторных произведений зачастую обходится дороже, чем скалярных произведений, стоит изучить, можно ли их заменить более экономичными выражениями. Оказывается, тождество Лагранжа

$( \textbf a × \textbf b) · ( \textbf c × \textbf d) = ( \textbf a · \textbf c)( \textbf b · \textbf d) − ( \textbf a · \textbf d)( \textbf b ·  \textbf c)$

можно использовать для выражения трех скалярных тройных произведений

```cpp
Vector n = Cross(b - a, c - a);
float va = Dot(n, Cross(b - p, c - p));
float vb = Dot(n, Cross(c - p, a - p));
float vc = Dot(n, Cross(a - p, b - p));
```

с точки зрения шести скалярных произведений

```cpp
float d1 = Dot(b - a, p - a);
float d2 = Dot(c - a, p - a);
float d3 = Dot(b - a, p - b);
float d4 = Dot(c - a, p - b);
float d5 = Dot(b - a, p - c);
float d6 = Dot(c - a, p - c);
```
в качестве

```cpp
float va = d3*d6 - d5*d4;
float vb = d5*d2 - d1*d6;
float vc = d1*d4 - d3*d2;
```

Фактически, эти шесть скалярных произведений, от $\textbf d1$ до $\textbf d6$, также могут использоваться для вычисления членов $\textbf {snom, sdenom, tnom, tdenom, unom}$ и $\textbf {udenom}$:

```cpp
float snom = d1;
float sdenom = -d3;
float tnom = d2;
float tdenom = -d6;
float unom = d4 - d3;
float udenom = d5 - d6;
```

Вектор $\textbf n$ больше не нужен. Это позволяет оптимизировать код до финальной версии.

```cpp
Point ClosestPtPointTriangle(Point p, Point a, Point b, Point c){
    // Проверить, находится ли P в области вершин вне A
    Vector ab = b - a;
    Vector ac = c - a;
    Vector ap = p - a;
    float d1 = Dot(ab, ap);
    float d2 = Dot(ac, ap);
    if (d1 <= 0.0f && d2 <= 0.0f) return a; // барицентрические координаты (1,0,0)
    // Проверить, находится ли P в области вершины вне B
    Vector bp = p - b;
    float d3 = Dot(ab, bp);
    float d4 = Dot(ac, bp);
    if (d3 >= 0.0f && d4 <= d3) return b; // барицентрические координаты (0,1,0)
    // Проверить, находится ли P в краевой области AB, если да, вернуть проекцию P на AB
    float vc = d1*d4 - d3*d2;
    if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f) {
        float v = d1 / (d1 - d3);
        return a + v * ab; // барицентрические координаты (1-v,v,0)
    }
    // Проверить, находится ли P в области вершины вне C
    Vector cp = p - c;
    float d5 = Dot(ab, cp);
    float d6 = Dot(ac, cp);
    if (d6 >= 0.0f && d5 <= d6) return c; // барицентрические координаты (0,0,1)
    // Проверить, находится ли P в краевой области AC, если да, вернуть проекцию P на AC
    float vb = d5*d2 - d1*d6;
    if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f) {
        float w = d2 / (d2 - d6);
        return a + w * ac; // барицентрические координаты (1-w,0,w)
    }
    // Проверить, находится ли P в краевой области BC, если да, вернуть проекцию P на BC
    float va = d3*d6 - d5*d4;
    if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f) {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b); // барицентрические координаты (0,1-w,w)
    }
    // P внутри области грани. Вычислить Q через его барицентрические координаты (u,v,w)
    float denom = 1.0f / (va + vb + vc);
    float v = vb * denom;
    float w = vc * denom;
    return a + ab * v + ac * w; // = u*a + v*b + w*c, u = va * denom = 1.0f - v - w
}
```

Третий способ получить ближайшую точку - использовать метод векторного исчисления, как предложено в [Eberly01]. Вкратце, треугольник ABC параметризован как $T(s, t)=A + s (B - A) + t (C - A)$ , где $s ≥ 0$ , $t ≥ 0$ и $s + t ≤ 1$ . Ближайшая точка до данной точки P теперь соответствует минимуму функции квадрата расстояния

$d (s, t)={\parallel T (s, t) - P \parallel}^2$ , что является квадратичным выражением от $s$ и $t$. Минимум этой функции должен встречаться в одном из трех случаев: в вершине, на ребре или внутри треугольника. Сначала дифференцируя $d(s, t)$ по этим различным случаям (то есть подставляя $s=0$ , $t=0$ или $t=1 - s$, если необходимо), устанавливая производные равными нулю и решая, а затем сравнивая приводя значения $s$ и $t$ к границам треугольника, можно выяснить, какой случай соответствует минимуму.

Для этого конкретного приложения решение векторного исчисления становится более сложным, чем только что описанное. Однако общий подход рассмотрения проблемы как задачи квадратичной минимизации ценен, и ту же идею можно использовать для определения расстояния между, скажем, линией или отрезком линии и треугольником. Дополнительная информация о методе векторного исчисления, включая псевдокод, приведена в [Eberly01].

### 5.1.6 Ближайшая точка на Тетраэдре к Точке

Для точки P проблема заключается в определении точки Q на тетраэдре ABCD (или в нем), ближайшем к P (как показано на рисунке 5.7). Простое решение - вычислить Q, вызвав функцию **ClosestPtPointTriangle()** (определенную в предыдущем разделе) один раз для каждой плоскости грани тетраэдра P. Из всех вычисленных точек ближайшая к P возвращается как Q. Отдельно от расстояния тесты, проводится другой тест, чтобы увидеть, лежит ли P внутри всех плоскостей граней. Когда это произойдет, ближайшая точка - сама точка.

Предполагая, что тетраэдр ABCD определен так, что его грани ABC, ACD, ADB и BDC расположены против часовой стрелки, если смотреть снаружи тетраэдра, это решение может быть реализовано следующим образом.

```cpp
Point ClosestPtPointTetrahedron(Point p, Point a, Point b, Point c, Point d) {
    // Начнём с предположения о точке внутри всех полупространств, которая ближе всего к себе
    Point closestPt = p;
    float bestSqDist = FLT_MAX;
    // Если точка находится за пределами грани abc, вычислить ближайшую точку на abc
    if (PointOutsideOfPlane(p, a, b, c)) {
    Point q = ClosestPtPointTriangle(p, a, b, c);
    float sqDist = Dot(q - p, q - p);
    // Обновить самую близкую точку, если (в квадрате) расстояние меньше текущего лучшего
    if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    // Повторить тест для грани acd
    if (PointOutsideOfPlane(p, a, c, d)) {
        Point q = ClosestPtPointTriangle(p, a, c, d);
        float sqDist = Dot(q - p, q - p);
        if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    // Повторить тест для грани adb
    if (PointOutsideOfPlane(p, a, d, b)) {
        Point q = ClosestPtPointTriangle(p, a, d, b);
        float sqDist = Dot(q - p, q - p);
        if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    // Повторите тест для грани bdc
    if (PointOutsideOfPlane(p, b, d, c)) {
        Point q = ClosestPtPointTriangle(p, b, d, c);
        float sqDist = Dot(q - p, q - p);
        if (sqDist < bestSqDist) bestSqDist = sqDist, closestPt = q;
    }
    return closestPt;
}
```

Здесь значение **PointOutsideOfPlane(P, A, B, C)** соответствует знаку скалярного тройного произведения векторов P − A, B − A, and C − A.

```cpp
    // Проверить, лежит ли точка p вне плоскости через abc
    int PointOutsideOfPlane(Point p, Point a, Point b, Point c){
        return Dot(p - a, Cross(b - a, c - a)) >= 0.0f; // [AP AB AC] >= 0
    }
```

Часто изгиб вершин тетраэдра заранее неизвестен, что означает, что нельзя предположить, скажем, что грань ABC повернута против часовой стрелки, если смотреть снаружи тетраэдра. В этом случае решение состоит в том, чтобы дополнительно передать четвертую вершину тетраэдра в **PointOutsideOfPlane()** и убедиться, что она и проверяемая точка лежат по разные стороны от грани проверяемого тетраэдра. Другими словами, тогда функция становится:

```cpp
    // Проверить, лежат ли точки p и d на противоположных сторонах плоскости, проходящей через abc
    int PointOutsideOfPlane(Point p, Point a, Point b, Point c, Point d){
        float signp = Dot(p - a, Cross(b - a, c - a)); // [AP AB AC]
        float signd = Dot(d - a, Cross(b - a, c - a)); // [AD AB AC]
        // Указывает на противоположные стороны, если знаки выражения противоположны
        return signp * signd < 0.0f;
    }
```

Этот общий подход хорошо работает и прост в реализации. Однако можно получить более эффективное решение, применив тот же базовый метод, который используется для поиска ближайшей точки на треугольнике. Сначала определяется характерная область Вороного, в которой находится точка P. Как только признак получен, Q задается ортогональной проекцией P на этот признак. Для тетраэдра необходимо учитывать 14 общих областей признаков Вороного: четыре области вершин, шесть краевых областей и четыре грани. Если P не лежит в одной из областей признаков, P по умолчанию должен содержаться в тетраэдре. Тесты на локализацию в функциональной области аналогичны тем, которые проводились ранее для треугольника. Например, теперь определяется, что P лежит в области Вороного вершины A, если выполняются следующие выражения.

$$(P − A) · (B − A) ≤ 0$$
$$(P − A) · (C − A) ≤ 0$$
$$(P − A) · (D − A) ≤ 0$$

Чтобы P лежал в области Вороного, связанной с ребром AB, должны быть выполнены следующие тесты (опять же при условии известного поворота граней против часовой стрелки).

$$(P − A) · (B − A) ≥ 0$$
$$(P − B) · (A − B) ≥ 0$$
$(P − A) · ((B − A) × \textbf n_{ABC} ) ≥ 0$, где $\textbf n_{ABC} = (B − A) × (C − A)$

$(P − A) · (\textbf n_{ADB} × (B − A)) ≥ 0$, где $\textbf n_{ADB} = (D − A) × (B − A)$

Аналогичные наборы выражений могут быть определены для тестирования сдерживания в остальных регионах. На первый взгляд, это может показаться не лучшим вариантом по сравнению с предыдущим тестом. Однако многие из вычисленных величин распределяются между различными регионами Вороного и не нуждаются в пересчете. Также можно упростить выражения, участвующие в тестировании областей Вороного, используя тождество Лагранжа, аналогично оптимизации, сделанной для теста ближайшей точки на треугольнике. В этом случае оказывается, что все тесты могут быть составлены из 10 различных скалярных произведений.

### 5.1.7 Ближайшая точка Выпуклого многогранника к Точке

Существует несколько подходов к нахождению расположения точки выпуклого многогранника H, ближайшей к точке P в пространстве. Простой в реализации метод O(n) состоит в том, чтобы вычислить точку на каждой грани многогранника, ближайшую к P, и вернуть ту, которая наиболее близка к P. Одновременный тест определяет, лежит ли P внутри всех граней H, и в этом случае P является внутренней по отношению к H. Чтобы ускорить тест, расчет расстояния до грани должен выполняться только тогда, когда P находится перед гранью.

Для больших многогранников более быстрый подход состоит в построении в качестве предварительного вычисления иерархии по частям многогранника. Использование предварительно построенной иерархии позволяет найти ближайшую точку в логарифмическом времени. Примером такой иерархии является иерархия Добкина – Киркпатрика, описанная в главе 9. Глава 9 также описывает другие подходы, которые могут эффективно определять местонахождение ближайшей точки на многогранниках (например, алгоритм GJK).

### 5.1.8 Ближайшие точки двух Линий

В то время как пара линий в двух измерениях всегда пересекается, если они не параллельны, пара линий в трех измерениях почти никогда не пересекается. Более того, даже если две трехмерные линии пересекаются в точной реальной арифметике, при арифметике с плавающей точкой они, скорее всего, не пересекаются из-за ошибок округления. Таким образом, чтобы иметь возможность надежно проверить пересечение двух трехмерных линий, лучше всего предположить, что линии могут не пересекаться, а только достаточно близко подходят друг к другу. Затем проверка пересечения сводится к определению расстояния между линиями и проверке того, меньше ли это расстояние заданного порогового значения.

Ближайшие точки двух линий можно определить следующим образом. Пусть прямые $L_1$ и $L_2$ параметрически заданы точками $P_1$ и $Q_1$ и $P_2$ и $Q_2$:

$$L_1 (s) = P_1 + s \textbf d_1 , \textbf d_1 = Q_1 − P_1$$
$$L_2 (t) = P_2 + t \textbf d_2 , \textbf d_2 = Q_2 − P_2$$

Для некоторой пары значений s и t, $L_1 (s)$ и $L_2 (t)$ соответствуют ближайшим точкам на линиях, а $\textbf v(s, t) = L_1(s) - L_2(t)$ описывает вектор между ними (Рисунок 5.8).
Точки наиболее близки, когда $\textbf v$ имеет минимальную длину. Ключевое понимание состоит в том, что это происходит, когда $\textbf v$ перпендикулярна как $L_1$, так и $L_2$. Чтобы убедиться в этом, предположим, что кратчайшее расстояние между точкой P и прямой L - это длина прямой линии между P и точкой Q, соответствующей ортогональной проекции P на L. Следовательно, прямая PQ ортогональна L. Поскольку это рассуждение справедливо как для $L_1 (s)$ по отношению к $L_2$, так и для $L_2 (t)$ по отношению к $L_1$, $\textbf v$ должна быть перпендикулярна обеим линиям. Для непараллельных прямых $\textbf v$ уникальна.

**Рисунок 5.8** Вектор $\textbf v (s, t)$, соединяющий две ближайшие точки двух прямых, $L_1 (s)$ и $L_2 (t)$, всегда перпендикулярен обеим линиям.

Теперь задача состоит в том, чтобы найти значения s и t, удовлетворяющие этим двум ограничениям перпендикулярности:

$$\textbf d_1 · \textbf v(s, t) = 0$$
$$\textbf d_2 · \textbf v(s, t) = 0.$$

Подстановка параметрического уравнения для $v(s, t)$ дает:

$$\textbf d_1 · (L_1 (s) − L_2 (t)) = \textbf d_1 · ((P_1 − P_2 ) + s \textbf d_1 − t \textbf d_2 ) = 0$$
$$ \textbf d_2 · (L_1 (s) − L_2 (t)) = \textbf d_2 · ((P_1 − P_2 ) + s \textbf d_1 − t \textbf d_2 ) = 0.$$

Это можно выразить в виде системы линейных уравнений 2 × 2

$$( \textbf d_1 · \textbf d_1 )s − (\textbf d_1 · \textbf d_2 )t = −(\textbf d_1 · r)$$
$$( \textbf d_2 · \textbf d_1 )s − (\textbf d_2 · \textbf d_2 )t = −(\textbf d_2 · r),$$
where $\textbf r = P_1 − P_2$ .

Написанное символически в матричной записи, это соответствует

\begin{equation*}
\begin{bmatrix}
a & -b \\
b & e 
\end{bmatrix}
\begin{bmatrix}
s \\
t 
\end{bmatrix}=
\begin{bmatrix}
-c \\
-f 
\end{bmatrix}
\end{equation*}

где $a = \textbf d_1 · \textbf d_1 , b = \textbf d_1 · \textbf d_2 , c = \textbf d_1 · r, e = \textbf d_2 · \textbf d_2$ , и $f = \textbf d_2 · r$. Эта система уравнений решается, например, с использованием правила Крамера для получения

$$s = (bf − ce)/d$$
$$t = (af − bc)/d,$$

где $d = ae − b^2$ . Обратите внимание, что $d ≥ 0$, для $d = \| \textbf d_1 \|^2 \| \textbf d_2 \|^2 ( \| \textbf d_1 \| \| \textbf d_2 \| cos(θ))^2 = ( \| \textbf d_1 \| \| \textbf d_2 \| sin(θ))^2$ . Когда $d = 0$, две линии параллельны, и их нужно обрабатывать отдельно. В этом случае любую точку P можно выбрать на одной линии. На другой строке точка, ближайшая к P, выбирается с использованием метода проекции, описанного в Разделе 5.1.2.

### 5.1.9 Ближайшие точки двух линейных участков

Задача определения ближайших точек двух отрезков $S_1$ и $S_2$,

$$S_1 (s) = P_1 + s \textbf d_1 , \textbf d_1 = Q_1 − P_1 , 0 ≤ s ≤ 1$$
$$S_2 (t) = P_2 + t \textbf d_2 , \textbf  d_2 = Q_2 − P_2 , 0 ≤ t ≤ 1,$$

является более сложной, чем вычисление ближайших точек прямых $L_1$ и $L_2$, частью которых являются отрезки. Только когда самые близкие точки $L_1$ и $L_2$ лежат на сегментах, применяется метод определения ближайших точек между линиями. В случае, когда ближайшие точки между $L_1$ и $L_2$ лежат за пределами одного или обоих сегментов, распространено заблуждение, что достаточно прижать внешние точки к ближайшей конечной точке сегмента. Однако, как показывают случаи (b) и (c) на рисунке 5.9, это неверное предположение.

Можно показать, что если хотя бы одна из ближайших точек между линиями находится за пределами соответствующего сегмента, эта точка может быть привязана к соответствующей конечной точке сегмента, и вычисляется точка на другом сегменте, ближайшая к конечной точке [Lumelsky85]. Это соответствует случаю (b) на рисунке 5.9, в котором ближайшая точка на $L_1$ привязана к конечной точке $Q_1$ на сегменте $S_1$. Затем вычисляется ближайшая точка R на $L_2$ к $Q_1$, и оказывается, что она находится на сегменте S2, оставляя ближайшие точки как $Q_1$ и R.

Если обе точки находятся за пределами соответствующих сегментов, ту же процедуру зажима необходимо повторить дважды, как показано на примере (c) на рисунке 5.9. Снова ближайшая точка на $L_1$ фиксируется к конечной точке $Q_1$ на $S_1$. Вычисляется ближайшая точка R на $L_2$ к $Q_1$. Поскольку обнаружено, что R находится вне сегмента $S_2$, он ограничивается ближайшей конечной точкой сегмента $Q_2$. Затем вычисляется ближайшая точка $S$ на $L_1$ к $Q_2$, и теперь обнаруживается, что она находится на сегменте $S_1$, оставляя самые близкие точки как $Q_2$ и $S$.

Для точки $S_2(t) = P_2 + t \textbf d_2$ на втором сегменте ближайшая точка $L_1 (s)$ на $L_1$ определяется выражением

$$s = (S_2 (t) − P_1 ) · \textbf d_1 / \textbf d_1 · \textbf d_1 = (P_2 + t \textbf d_2 − P_1 ) · \textbf d_1 / \textbf d_1 · \textbf d_1 .$$

**Рисунок 5.9** Ближайшие точки (a) внутри обоих сегментов, (b) и (c) внутри конечной точки одного сегмента другого, (d) конечные точки обоих сегментов (после [Lumelsky85]).

Так же, для точки $S_1 (s) = P_1 + s \textbf d_1$ на $S_1$ , ближайшая точка $L_2 (t)$ на $L_2$ вычисляется как

$$t = (S_1 (s) − P_2 ) · \textbf d_2 / \textbf d_2 · \textbf d_2 = (P_1 + s \textbf d_1 − P 2 ) · \textbf d_2 / \textbf d_2 · \textbf d_2 .$$

В качестве альтернативы, метод исключения Гаусса может использоваться в системе линейных уравнений 2 × 2, чтобы решить одно неизвестное через другое. В любом случае выражения для s и t упрощаются до

$$s = (bt − c)/a$$
$$t = (bs + f )/e,$$

с $a = d_1 · d_1$, $b = d_1 · d_2$, $c = d_1 · r$, $e = d_2 · d_2$ и $f = d_2 · r$. Код, реализующий эту функцию, приведен ниже.

```cpp
// Зажать n, чтобы он лежал в пределах диапазона [min, max]
float Clamp(float n, float min, float max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
}
// Вычислить ближайшие точки C1 и C2 для 
// S1(s) = P1 + s * (Q1 - P1) и S2(t) = P2 + t * (Q2 - P2), возвратить s и t. 
// Результат функции - квадрат расстояния между S1(s) и S2(t)
float ClosestPtSegmentSegment(Point p1, Point q1, Point p2, Point q2,
float &s, float &t, Point &c1, Point &c2) {
    Vector d1 = q1 - p1; // Вектор направления отрезка S1
    Vector d2 = q2 - p2; // Вектор направления отрезка S2
    Vector r = p1 - p2;
    float a = Dot(d1, d1); // Квадрат длины сегмента S1, всегда неотрицательный
    float e = Dot(d2, d2); // Квадрат длины сегмента S2, всегда неотрицательный
    float f = Dot(d2, r);
    // Проверить, превращаются ли один или оба сегмента в точки
    if (a <= EPSILON && e <= EPSILON) {
        // Оба отрезка вырождаются в точки
        s = t = 0.0f;
        c1 = p1;
        c2 = p2;
        return Dot(c1 - c2, c1 - c2);
    }
    if (a <= EPSILON) {
        // Первый отрезок вырождается в точку
        s = 0.0f;
        t = f / e; // s = 0 => t = (b*s + f) / e = f / e
        t = Clamp(t, 0.0f, 1.0f);
    } else {
        float c = Dot(d1, r);
        if (e <= EPSILON) {
        // Второй отрезок вырождается в точку
        t = 0.0f;
        s = Clamp(-c / a, 0.0f, 1.0f); // t = 0 => s = (b*t - c) / a = -c / a
        } else {
            // Здесь начинается общий невырожденный случай
            float b = Dot(d1, d2);
            float denom = a*e-b*b; // Всегда неотрицательно
            // Если сегменты не параллельны, вычислить ближайшую точку на L1 к L2
            // и зафиксировать сегмент S1. 
            // В противном случае выбрать произвольное значение s (здесь 0)
            if (denom != 0.0f) {
            s = Clamp((b*f - c*e) / denom, 0.0f, 1.0f);
            } else s = 0.0f;
            // Вычислить точку на L2, ближайшую к S1 (s), используя
            // t = Dot((P1 + D1*s) - P2,D2) / Dot(D2,D2) = (b*s + f) / e
            t = (b*s + f) / e;
            // Если t в [0,1] уже. В противном случае зажать t, 
            // пересчитать s для нового значения t, используя 
            // s = Dot((P2 + D2*t) - P1,D1) / Dot(D1,D1)= (t*b - c) / a
            // и зафиксировать s в [0, 1]
            if (t < 0.0f) {
                t = 0.0f;
                s = Clamp(-c / a, 0.0f, 1.0f);
            } else if (t > 1.0f) {
                t = 1.0f;
                s = Clamp((b - c) / a, 0.0f, 1.0f);
            }
        }
    }
    c1 = p1 + d1 * s;
    c2 = p2 + d2 * t;
    return Dot(c1 - c2, c1 - c2);
}
```

В качестве оптимизации деление на e можно отложить до тех пор, пока не станет известно, что t находится в диапазоне [0, 1], в результате чего код в конце большого оператора else будет таким :

```cpp
    ...
    float tnom = b*s + f;
    if (tnom < 0.0f) {
        t = 0.0f;
        s = Clamp(-c / a, 0.0f, 1.0f);
    } else if (tnom > e) {
        t = 1.0f;
        s = Clamp((b - c) / a, 0.0f, 1.0f);
    } else {
        t = tnom / e;
    }
```

Такая отсрочка позволяет сэкономить на одной, зачастую дорогой, операции деления в общем случае.

#### 5.1.9.1 2D Пересечение Сегментов

Проверить, пересекаются ли два 2D-сегмента AB и CD, можно, сначала вычислив точку пересечения их удлиненных линий, а затем верифицировать, что точка пересечения находится в пределах ограничивающей рамки каждого сегмента. Примеры см. На рисунках 5.10a и b. Случай, когда линии параллельны, следует рассматривать отдельно.

**Рисунок 5.10** (a) Сегменты AB и CD не пересекаются, потому что точка пересечения P их продолженных прямых лежит за пределами ограничивающей рамки CD. (b) Отрезки AB и CD пересекаются, потому что P лежит внутри ограничивающих прямоугольников как AB, так и CD. (c) Сегмент CD пересекает линию, проходящую через AB, потому что треугольники ABD и ABC имеют противоположную ориентацию.

Пересечение между удлиненными линиями можно вычислить, написав первую строку в явном виде, $L_1(t) = A + t(B − A)$, и вторая строка в неявной форме,
$\textbf n · (X − C) = 0$, где $\textbf n = (D − C)^⊥$ перпендикуляр к CD. Подставляя уравнение первой линии для неизвестной точки во второе уравнение и решая для t, получаем:

$\textbf n · (A + t(B − A) − C) = 0$ ⇔ (замена A + t(B − A) для X)

$\textbf n · (A − C) + t(\textbf n · (B − A)) = 0$ ⇔ (расширение скалярного произведения; группируем аналогичные члены)

$t(\textbf n · (B − A)) = −\textbf n · (A − C)$ ⇔ (изолируем t член слева)

$t(\textbf n · (B − A)) = \textbf n · (C − A)$ ⇔ (удаление отрицания на правой стороне путем инвертирования вектора)

$t = \textbf n · (C − A)/n · (B − A)$ ⇔ (деление обеих стороны на $\textbf n · (B − A)$)

Фактическая точка пересечения $P=L_1 (t)$ теперь может быть получена путем подстановки t в явное уравнение. Альтернативой проверке, лежит ли P в пределах ограничивающей рамки AB, является проверка этого 0 ≤ t ≤ 1.

Альтернативный тест на перекрытие для 2D-сегментов может быть основан на понимании того, что сегменты перекрываются, только если конечные точки любого сегмента расположены по разные стороны от продолженной линии, проходящей через другой сегмент. То есть, чтобы AB и CD перекрывались, A и B должны быть по разные стороны от CD, а C и D должны быть по разные стороны от AB.

Проверить, находятся ли конечные точки C и D по разные стороны от AB, можно, убедившись, что треугольники ABD и ABC разворачиваются в разных направлениях (показано на рисунке 5.10c). Чтобы определить ориентацию, можно вычислить площадь треугольника со знаком. Напомним, что площадь со знаком положительная, если треугольник вращается против часовой стрелки, отрицательная, если он вращается по часовой стрелке, и ноль, если треугольник вырожденный (коллинеарные или совпадающие точки).

```cpp
// Возвращает удвоенную площадь треугольника со знаком. Результат будет положительным, если abc равно ccw, 
// отрицательным, если abc равно cw, нулевым, если abc является вырожденным.
float Signed2DTriArea(Point a, Point b, Point c){
    return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
}
```

В случае, когда сегменты пересекаются, оказывается, что области со знаком, вычисленные для обнаружения этого, также могут использоваться для вычисления точки пересечения. Вычисление и его вывод приведены в следующей реализации.

```cpp
// Проверить, перекрываются ли сегменты ab и cd. Если они это сделают, вычислить 
// и вернуть значение пересечения t вдоль ab и положение пересечения p
int Test2DSegmentSegment(Point a, Point b, Point c, Point d, float &t, Point &p) {
    // Знак площадей соответствует тому, с какой стороны ab находятся точки c и d
    float a1 = Signed2DTriArea(a, b, d); // Вычислить ориентацию abd (+ или -)
    float a2 = Signed2DTriArea(a, b, c); // Для пересечения должен иметь знак противоположный a1
    // Если c и d находятся по разные стороны от ab, участки имеют разные знаки
    if (a1 * a2 < 0.0f) {
        // Вычислить знаки a и b относительно сегмента cd
        float a3 = Signed2DTriArea(c, d, a); // Вычислить ориентацию cda (+ или -)
        // Так как площадь постоянная a1 - a2 = a3 - a4, или a4 = a3 + a2 - a1
        float a4 = Signed2DTriArea(c, d, b); // Должен иметь противоположный знак a3
        float a4 = a3 + a2 - a1;
        // Точки a и b по разные стороны cd, если области имеют разные знаки
        if (a3 * a4 < 0.0f) {
            // Сегменты пересекаются. Найти точку пересечения вдоль L(t) = a + t * (b - a).
            // Дана высота h1 над cd и высота h2 над cd,
            // t = h1 / (h1 - h2) = (b*h1/2) / (b*h1/2 - b*h2/2) = a3 / (a3 - a4),
            // где b (основание треугольников cda и cdb, т.е. длина cd) сокращено.
            t = a3 / (a3 - a4);
            p = a + t * (b - a);
            return 1;
        }
    }
    // Сегменты не пересекаются (или коллинеарны)
    return 0;
}
```

Здесь выражение $a1 * a2 < 0.0f$ используется для проверки того, имеют ли a1 и a2 разные знаки (аналогично для a3 и a4). При работе с целыми числами со знаком лучшей альтернативой является использование исключающего ИЛИ вместо умножения, $a1 ∧ a2 < 0$, что позволяет избежать потенциальных проблем с переполнением. При наличии коллинеарных точек один или оба значения a1 и a2 могут быть равны нулю. Чтобы обнаружить правильные пересечения в этих случаях, тест должен быть написан в следующих строках:

```cpp
if (a1 != 0.0f && a2 != 0.0f && a1*a2 < 0.0f) ... // для переменных с плавающей запятой
if ((a1 | a2) != 0 && a1 ∧ a2 < 0) ... // для целочисленных переменных
```

Наконец, обратите внимание, что для некоторых приложений стоит проверить, перекрываются ли ограничивающие прямоугольники AB и CD, прежде чем приступить к одному из этих тестов пересечения сегментов. Это особенно верно для определения пересечения отрезков линий в 3D, для которых соответствующие вычисления более затратны.

### 5.1.10 Ближайшие точки Отрезка линии и Треугольника

Ближайшая пара точек между отрезком PQ и треугольником ABC не обязательно уникальна. Когда сегмент параллелен плоскости треугольника, может быть бесконечное количество пар, одинаково близких друг к другу. Однако, независимо от того, параллелен ли сегмент плоскости или нет, всегда можно найти точки так, чтобы минимальное расстояние было либо (а) между конечной точкой сегмента и внутренней частью треугольника, либо (б) между сегментом. и край треугольника. Эти два случая показаны на рисунке 5.11.

**Рисунок 5.11** Ближайшая пара точек между отрезком линии и треугольником всегда может быть найдена либо (а) между конечной точкой сегмента и внутренней частью треугольника, либо (б) между сегментом и краем треугольника.

Случай (а) может иметь место только в том случае, если проекция конца отрезка на опорную плоскость треугольника лежит внутри треугольника. Однако даже когда конечная точка сегмента выступает внутрь треугольника, край треугольника может обеспечивать более близкую точку к сегменту. Таким образом, ближайшую пару точек можно найти путем вычисления ближайших пар точек между объектами

- отрезок PQ и ребро треугольника AB ,
- отрезок PQ и ребро треугольника BC ,
- отрезок PQ и ребро треугольника CA ,
- конечная точка отрезка P и плоскость треугольника (когда P проецируется внутрь ABC), и
- конечная точка отрезка Q и плоскость треугольника (когда Q проецируется внутрь ABC)

и возвращая в результате пару с наименьшим минимальным разделяющим расстоянием.

В некоторых случаях количество необходимых тестов может быть сокращено. Например, когда обе конечные точки проецируются внутрь треугольника, тесты сегмент-кромка не требуются, потому что любая проекция конечной точки должна соответствовать ближайшей точке. Когда одна конечная точка проецируется внутрь треугольника, требуется только один тест «сегмент-кромка». Когда обе конечные точки выступают за пределы треугольника, один из тестов на ребро сегмента не требуется. Для последних двух случаев необходимые тесты на границе сегмента можно определить, исследуя, в каких областях Вороного лежат конечные точки сегмента.

Остающийся случай - это когда отрезок пересекает треугольник. Для поперечного пересечения точка пересечения соответствует ближайшим точкам. Когда сегмент лежит в плоскости треугольника, любая точка сегмента, пересекающегося с треугольником, реализует ближайшие точки. Альтернативный метод определения ближайших точек между сегментом и треугольником, основанный на подходе векторного исчисления, описан в [Eberly01] и [Schneider02].

### 5.1.11 Ближайшие точки двух Треугольников

Как в случае определения ближайшей пары точек между отрезком и треугольником, между двумя треугольниками может быть бесконечное количество одинаково близких точек. Однако ближайшие точки между двумя треугольниками T1 и T2 всегда могут быть реализованы таким образом, чтобы одна точка лежала на границе одного из треугольников. Следовательно, пару ближайших точек между двумя треугольниками можно найти путем вычисления ближайших точек между отрезком и треугольником для всех шести возможных комбинаций ребра из одного треугольника, проверенного относительно другого треугольника. Тогда пара точек, имеющих наименьшее (квадратичное) расстояние, соответствует ближайшей паре точек минимального глобального расстояния.

Тестирование расстояния отрезок-треугольник довольно дорогое, и поэтому лучшая реализация состоит в том, что ближайшая пара точек между T1 и T2 может быть найдена либо на ребре каждого треугольника (рис. 5.12a), либо в виде вершины одного треугольника и точка внутри другого треугольника (рис. 5.12b). Теперь проблема заключается в вычислении ближайших точек среди всех пар ребер, по одной от каждого треугольника и ближайшей точки на противоположном треугольнике для каждой вершины каждого треугольника (когда указанная вершина проецируется внутрь другого треугольника). Всего требуется шесть тестов вершина-треугольник и девять тестов ребро-ребро. Из всех пар ближайших точек та, у которой общее наименьшее расстояние, соответствует самой близкой в глобальном масштабе паре точек между треугольниками.

Если априори не известно, что треугольники не пересекаются, требуется дополнительная проверка, чтобы исключить пересечение двух треугольников. При пересечении расстояние между треугольниками тривиально равно нулю, но ближайшие точки вряд ли будут хорошо определены, потому что их может быть бесконечно много (например, если треугольники параллельны и перекрываются).

**Рисунок 5.12** Ближайшая пара точек между двумя треугольниками может быть реализована (а) как лежащая на ребре любого из треугольников или (б) как вершина одного треугольника и точка внутри другого треугольника.

## 5.2 Тестирование пересечения примитивов

Тестирование примитивов менее общее, чем вычисление расстояния между ними. Как правило, тест указывает только на то, что примитивы пересекаются, но не определяет, где и как они пересекаются. Следовательно, эти тесты пересечения часто намного быстрее, чем тесты, возвращающие дополнительную информацию.

### 5.2.1 Тест разделяющей оси

Чрезвычайно полезным инструментом для реализации различных тестов пересечения является *тест разделяющей оси*. Это следует из *теоремы о разделяющей гиперплоскости*, фундаментального результата выпуклого анализа. Эта теорема утверждает, что для данных двух выпуклых множеств A и B либо эти два множества пересекаются, либо существует разделяющая гиперплоскость P такая, что A находится по одну сторону от P, а B - с другой.

Проверка разделяющей оси интуитивно следует из теоремы, потому что два выпуклых объекта не могут «изгибаться» друг вокруг друга. Таким образом, когда они не пересекаются, между ними будет промежуток, в который можно вставить плоскость, разделяющую два объекта. Когда один или оба объекта вогнуты, плоскости, как правило, уже недостаточно для разделения непересекающихся объектов. Вместо этого для разделения объектов потребуется изогнутая поверхность. Когда объекты пересекаются, никакая поверхность - изогнутая или нет - не может быть вставлена между объектами, чтобы разделить их.

Для гиперплоскости P, разделяющей A и B, разделяющая ось - это линия L, перпендикулярная P. Она называется разделяющей осью, потому что ортогональные проекции A и B на L приводят к двум непересекающимся интервалам (рис. 5.13). Поскольку два интервала не пересекаются, можно сделать вывод, что геометрии не должны пересекаться. Поскольку разделяющая ось существует тогда и только тогда, когда существует разделяющая гиперплоскость, любая из них может быть проверена. Однако на практике оказывается, что лучше проверить разделение на оси, так как это дает менее дорогостоящий тест.

Для выполнения теста разделяющей оси стоит отметить, что многие примитивы столкновения, такие как сегменты, AABB, OBB, k-DOP и сферы, симметричны в том смысле, что у них есть центральная точка C, которая всегда проецируется в середина проекционного интервала их проекции на ось. Учитывая потенциально разделяющую ось L, эффективным тестом разделения двух симметричных объектов A и B, следовательно, является вычисление полуширины или радиусов их интервалов проекции и сравнение их суммы с расстоянием между их центральными проекциями. Если сумма меньше расстояния между центральными проекциями, объекты не должны пересекаться. Пример приведен на рисунке 5.14, на котором A и B соответствуют кругу и ориентированному прямоугольнику (или, что то же самое, сфере и OBB, если смотреть сбоку). Сначала для каждого объекта получается точка опоры по L; то есть точка, наиболее удаленная от центра объекта по любому направлению L (в том смысле, что проекции симметричны, направление не имеет значения; будет точка, одинаково удаленная в обоих направлениях). Два радиуса объекта, $r_A$ и $r_B$, затем получаются путем вычисления расстояния между проекциями на L центров объектов и их соответствующими наиболее удаленными точками. Также вычисляется расстояние d между центральными выступами. С учетом этих вычисленных величин объекты теперь разделены, если $r_A + r_B < d$.

**Рисунок 5.13** (a) Два выпуклых объекта, A и B, разделенных гиперплоскостью P (одной из многих возможных гиперплоскостей). Другими словами, A и B не пересекаются в своей проекции на разделяющую ось L (которая перпендикулярна P). (b) Те же выпуклые объекты находятся в ситуации пересечения и, следовательно, не могут быть отделены какой-либо гиперплоскостью.

**Рисунок 5.14** Два объекта разделяются, если сумма радиуса (полуширины) их проекций меньше расстояния между их центральными проекциями.

Тест разделяющей оси применяется, даже когда объект не является симметричным - как, например, в случае произвольной выпуклой оболочки - но тест должен быть изменен, чтобы спроецировать вершины корпуса на ось, чтобы найти интервалы проекции.

Разделительные оси легко обнаружить при осмотре. Однако для реализации важно иметь возможность автоматически ограничивать бесконечное количество потенциально разделяющих осей всего несколькими тестируемыми осями. Для выпуклых многогранников можно резко уменьшить количество проверяемых осей. Игнорируя порядок, два многогранных объекта могут вступать в контакт шестью различными способами по отношению к своим характеристикам. Они могут встречаться с гранью-гранью, гранью-ребром, гранью-вершиной, ребром-ребром, ребром-вершиной или вершиной-вершиной. Поскольку вершины можно рассматривать как часть ребер, комбинации, включающие вершины, относятся к тем же ситуациям, связанным с ребрами. Это сокращает ситуации контакта до трех существенно различных комбинаций: грань-грань, грань-ребро и ребро-ребро.

Для случаев «грань-грань» и «грань-ребро» достаточно проверить нормали граней обоих объектов как потенциальные разделяющие оси. Для случая грань-ребро проверяемая потенциальная разделительная ось соответствует поперечному произведению двух кромок. Причина, по которой перекрестное произведение используется для проверки разделяющей оси в случае «край-край», может быть обоснована рассмотрением того, что происходит, когда два объекта соприкасаются край к краю. Точки на ближайших друг к другу краях образуют ножки перпендикуляра между двумя краями. Поскольку этот перпендикуляр является поперечным произведением краев, он является правильным кандидатом для тестирования в качестве разделяющей оси. Таким образом, для проверки разделимости двух многогранных объектов необходимо проверить следующие оси.

- Оси параллельны нормали к граням объекта A
- Оси параллельны нормали к граням объекта B
- Оси параллельны векторам, полученным в результате векторного произведения всех ребер в A со всеми ребрами в B

Как только разделительная ось будет найдена, тест может быть немедленно завершен "без пересечения". Если все оси проверены, а разделительная ось не найдена, объекты должны пересекаться.

Для двух общих многогранников с одинаковым количеством граней (F) и ребер (E) существует 2F + E2 потенциальных разделяющих осей. Поскольку количество разделяющих осей квадратично по количеству ребер, проверка разделяющих осей может оказаться невозможной для объектов средней и высокой сложности. Тем не менее, можно ускорить проверку разделяющей оси, кэшируя последнюю успешную разделяющую ось и проверяя ее сначала на следующем запросе, в надежде получить ранний выход без пересечения благодаря пространственной и временной когерентности объектов между запросами.

Когда два многогранника сталкиваются, проверка разделяющей оси также может помочь в вычислении контактной информации. Вместо того, чтобы выходить раньше, когда обнаруживается перекрытие на оси, все оси проверяются на перекрытие. После тестирования всех осей ось с наименьшим (нормализованным) перекрытием может использоваться в качестве нормали контакта, а перекрытие может использоваться для оценки глубины проникновения. После некоторой дополнительной работы точки контакта можно также вычислить с помощью разделительной оси. Для тех, кто хочет читать дальше, тест разделяющей оси был предложен для обнаружения столкновений ориентированных ограничивающих прямоугольников [Larcombe95].

#### 5.2.1.1 Устойчивость теста разделяющей оси
### 5.2.2 Тестирование пересечения Сферы и Плоскости
### 5.2.3 Тестирование пересечения Параллелипипеда и Плоскости
### 5.2.4 Тестирование пересечения Конуса и Плоскости
### 5.2.5 Тестирование пересечения Сферы и AABB
### 5.2.6 Тестирование пересечения Сферы и OBB
### 5.2.7 Тестирование пересечения Сферы и Треугольника
### 5.2.8 Тестирование пересечения Сферы и Многоугольника
### 5.2.9 Тестирование пересечения AABB и Треугольника
### 5.2.10 Тестирование пересечения Треугольника и Треугольника
## 5.3 Пересекающиеся линии, лучи и (направленные) сегменты

Испытания с использованием линий, лучей и сегментов часто используются, например, для имитации выстрела пули или для проверки прямой видимости. Иногда вместо более сложных запросов используются линейные тесты. Например, контакт руки или ноги персонажа игрока с окружающей средой или контакт колеса транспортного средства с землей часто можно эффективно смоделировать с помощью простого линейного теста. В следующих разделах исследуются эффективные тесты линий, лучей и сегментов с использованием различных общих примитивов столкновения.

### 5.3.1 Пересекающиеся Сегмент и Плоскость
### 5.3.2 Пересекающиеся Луч или Сегмент и Сфера
### 5.3.3 Пересекающиеся Луч или Сегмент и Параллелипипед
### 5.3.4 Пересекающиеся Линия и Треугольник
### 5.3.5 Пересекающиеся Линия и Четырехугольник
### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник
### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)
### 5.5.7 Пересечение движущейся сферы относительно AABB

Пусть сфера $S$ задана центром $C$ и радиусом $r$, и пусть $\textbf d$ - вектор направления для $S$, так что движение центра сферы задается формулой $C(t)=C + t \textbf d$ на интервале движения $0 ≤ t ≤ 1$. Пусть $B$ - AABB. Пересечение движущейся сферы $S$ с параллелипипедом $B$ эквивалентно пересечению отрезка $L(t)=C + t \textbf d$, $0 ≤ t ≤ 1$, с объемом $V$, который получается после переметания B с помощью S (то есть с суммой Минковского B и S, V=B ⊕ S), как показано на рисунке 5.37. Последний тест может быть эффективно выполнен без формирования V, как показано ниже.

Пусть E будет AABB, полученным расширением граней B наружу на расстояние, эквивалентное радиусу сферы r. Это самый плотный AABB, ограничивающий V, отличающийся от V только отсутствием сферически скошенных ребер. Теперь пересекаем L с E. Если L не пересекает E, то очевидно, что S не пересекает B. В противном случае пусть P=L(t) обозначает точку, в которой L пересекает E в момент времени t.

Если P лежит в области Вороного на грани поверхности B, то больше ничего не требуется: S пересекает B в момент времени t, когда центр сферы находится в точке P. Однако, если P лежит на краю или вершине области Вороного, требуются дальнейшие тесты для определить, проходит ли L через скошенную область V, отсутствующую в E, таким образом пропуская V, или L пересекает V по одному из своих скошенных ребер или вершин в некоторый более поздний момент времени t', t < t' ≤ 1.

Когда P лежит в краевой области Вороного B, L должен дополнительно пересекаться с капсулой радиуса r, определяемого ребром. Если и только если L пересекает капсулу, S пересекает B. Пересечение L и капсулы соответствует фактическому пересечению S и B.

**Рисунок 5.37**. Двухмерная иллюстрация того, как проверка движущейся сферы относительно AABB трансформируется в тестирование отрезка линии относительно объема, полученного после протягивания AABB сферой (формируя сумму Минковского сферы и AABB).

Последнее соображение - когда P лежит в вершине области Вороного. В этом случае L необходимо дополнительно пересечь по всем трем капсулам радиуса r, определяемого ребрами, совпадающими с вершиной. Если L не пересекает одну из капсул, S не пересекает B. В противном случае пересечение S с B происходит в наименьший момент времени t, когда L пересекает одну из краевых капсул. В качестве потенциального ускорения L можно проверить на сфере K радиуса r с центром в вершине. Если L пересекает K, а точка пересечения лежит в области Вороного вершины, то эта точка пересечения дает ответ, и капсулы не нужно проверять. Однако, если точка пересечения между L и K лежит вне области Вороного вершины (или если L вообще не пересекает K), проверка сферы была напрасной, и три цилиндра должны быть пересечены в любом случае. В следующем фрагменте кода показано, как эффективно определить, в какой области Вороного P содержится и какие ребра необходимо проверить для случаев области ребер и вершин.

```cpp
    int IntersectMovingSphereAABB(Sphere s, Vector d, AABB b, float &t){
        // Вычислить AABB, полученный в результате расширения b на радиус сферы r
        AABB e = b;
        e.min.x -= s.r; e.min.y -= s.r; e.min.z -= s.r;
        e.max.x += s.r; e.max.y += s.r; e.max.z += s.r;
        // Луч пересечения против расширенного AABB e. Выйти без пересечения, 
        // если луч не попадет в точку e, иначе в качестве результата получится точка пересечения p и время t
        Point p;
        if (!IntersectRayAABB(s.c, d, e, t, p) || t > 1.0f)
        return 0;
        // Вычислить, за пределами какой минимальной и максимальной граней b лежит точка пересечения p. 
        // Обратите внимание, что u и v не могут иметь одинаковые установленные биты, 
        // и среди них должен быть установлен хотя бы один бит
        int u = 0, v = 0;
        if (p.x < b.min.x) u |= 1;
        if (p.x > b.max.x) v |= 1;
        if (p.y < b.min.y) u |= 2;
        if (p.y > b.max.y) v |= 2;
        if (p.z < b.min.z) u |= 4;
        if (p.z > b.max.z) v |= 4;

        // «Или» все установленные биты вместе в битовую маску (примечание: здесь u + v == u | v)
        int m = u + v;
        // Определить отрезок [c, c + d], заданный движением сферы
        Segment seg(s.c, s.c + d);
        // Если все 3 бита установлены (m == 7), то p находится в области вершины
        if (m == 7) {
            // Теперь должен пересекать сегмент [c, c + d] относительно капсул трех ребер, 
            // встречающихся в вершине, и возвращать лучшее время, если одно или несколько попаданий
            float tmin = FLT_MAX;
            if (IntersectSegmentCapsule(seg, Corner(b, v), Corner(b, v ∧ 1), s.r, &t))
            tmin = Min(t, tmin);
            if (IntersectSegmentCapsule(seg, Corner(b, v), Corner(b, v ∧ 2), s.r, &t))
            tmin = Min(t, tmin);
            if (IntersectSegmentCapsule(seg, Corner(b, v), Corner(b, v ∧ 4), s.r, &t))
            tmin = Min(t, tmin);
            if (tmin == FLT_MAX) return 0;
            // Нет пересечения
            t = tmin;
            return 1;
            // Пересечение в момент времени t == tmin
        }
        // Если в m установлен только один бит, то p находится в области грани
        if ((m & (m - 1)) == 0) {
            // Ничего не делать. Время t от пересечения с развернутым прямоугольником 
            // является правильным временем пересечения
            return 1;
        }
        // p находится в реберной области. Пересекает капсулу ребром
        return IntersectSegmentCapsule(seg, Corner(b, u ∧ 7), Corner(b, v), s.r, &t);
    }
    // Функция поддержки, возвращающая вершину AABB с индексом n
    Point Corner(AABB b, int n){
        Point p;
        p.x = ((n & 1) ? b.max.x : b.min.x);
        p.y = ((n & 1) ? b.max.y : b.min.y);
        p.z = ((n & 1) ? b.max.z : b.min.z);
        return p;
    }
```

Этот тест также работает для выполнения того же пересечения с OBB: выражая центр сферы C и вектор движения d в локальной системе координат OBB, проблема эффективно сводится к проблеме движущейся сферы относительно AABB.

### 5.5.8 Пересечение движущегося AABB относительно AABB

**Рисунок 5.38**, иллюстрирующий расстояния, проекций параллелограмма B, для достижения первого и последнего контакта с проекцией неподвижного параллелограмма A, когда B движется к A.

Поскольку AABB является примером выпуклого многогранника, проблема определения пересечения между двумя движущимися AABB, A и B с соответствующими скоростями $v_A$ и $v_B$, может быть решена с использованием движущейся версии теста разделяющей оси, как описано в разделе 5.5.2.

Сначала задача сводится к проблеме неподвижного параллелограмма A и движущегося параллелограмма B путем вычитания скорости A из B, что дает относительную скорость $v=v_B - v_A$. На рис. 5.38 показано, что для данного B, движущегося в сторону A, расстояния $d_{ﬁrst}$ и $d_{last}$, которые B должен преодолеть, чтобы достичь первого и последнего контакта с A. Время до первого и последнего контакта, $t_{ﬁrst}$ и $t_{last}$, затем легко получить, разделив эти расстояния на скорость, с которой B движется к A. Эти времена получены для всех трех главных осей, а наибольшее t первое и наименьшее t последнее соответствуют пересечению в моментах времени, когда прямоугольники перекрываются на трех осях, если вообще перекрываются. Если окажется, что проекции прямоугольников не пересекаются и расходятся по оси, тест может быть немедленно завершен без пересечения. Далее следует полная реализация этого теста.

```cpp
// Пересечение AABB «a» и «b», движущихся с постоянными скоростями va и vb.
// При пересечении вернуть время первого и последнего контакта в tfirst и tlast
int IntersectMovingAABBAABB(AABB a, AABB b, Vector va, Vector vb,
float &tfirst, float &tlast){
    // Выйдити раньше, если «a» и «b» изначально перекрываются
    if (TestAABBAABB(a, b)) {
        tfirst = tlast = 0.0f;
        return 1;
    }
    // Использовать относительную скорость; эффективно рассматривать 'а' как стационарный
    Vector v = vb - va;
    // Инициализация время первого и последнего контакта
    tfirst = 0.0f;
    tlast = 1.0f;
    // Для каждой оси определить время первого и последнего контакта, если таковые имеются
    for (int i = 0; i < 3; i++) {
        if (v[i] < 0.0f) {
            if (b.max[i] < a.min[i]) return 0;
            // Непересекающиеся и расходящиеся
            if (a.max[i] < b.min[i]) tfirst = Max((a.max[i] - b.min[i]) / v[i], tfirst);
            if (b.max[i] > a.min[i]) tlast = Min((a.min[i] - b.max[i]) / v[i], tlast);
        }
        if (v[i] > 0.0f) {
            if (b.min[i] > a.max[i]) return 0;
            // Непересекающиеся и расходящиеся
            if (b.max[i] < a.min[i]) tfirst = Max((a.min[i] - b.max[i]) / v[i], tfirst);
            if (a.max[i] > b.min[i]) tlast = Min((a.max[i] - b.min[i]) / v[i], tlast);
        }
        // Перекрытие невозможно, если время первого контакта происходит позже времени последнего контакта
        if (tfirst > tlast) return 0;
    }
    return 1;
}
```

Решение, подобное представленному здесь, приведено в [Gomez99].

## 5.6 Резюме

В этой главе довольно подробно обсуждалось большое количество различных тестов и запросов. К ним относятся вычисления ближайших точек (которые позволяют напрямую определять расстояние между двумя объектами запроса); тесты неоднородного пересечения (например, между сферой и OBB); пересечения линий, лучей и отрезков (например, треугольников); и тесты на удержание точек (как для полигонов, так и для многогранников), и это лишь некоторые из них. В дополнение к статическим испытаниям на пересечение были описаны методы выполнения динамических испытаний, включая мощное обобщение испытания с разделительной осью.

Несмотря на то, что в этой главе был рассмотрен широкий спектр тестов, читатели неизбежно обратят внимание на конкретные тесты, которые были исключены из охвата. Как упоминалось в начале главы, цель предоставленного спектра тестов и приведенных математических деталей состоит в том, чтобы позволить читателям самостоятельно вывести эти другие тесты, используя идеи, представленные здесь. Возможность создавать тесты с нуля важна, потому что существует не так много источников, которые в значительной степени охватывают тесты пересечения, и даже те, которые содержат, вряд ли охватят конкретные тесты, необходимые читателю. Заметным исключением из отсутствия исчерпывающих источников для тестов на перекрестки является [Schneider02],
который является сокровищницей геометрических тестов всех типов и прекрасным дополнением к этой главе. [Eberly01] и [Bergen03] также являются хорошими справочными материалами, хотя и не такими исчерпывающими. Отдельные статьи по конкретным тестам также можно найти в серии пятитомных книг Graphic Gems [Glassner90], [Arvo91], [Kirk92], [Heckbert94],
и [Paeth95].

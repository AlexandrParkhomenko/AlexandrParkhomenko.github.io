---
layout: default
title: "Робототехника"
description: "Физика столкновений на примере свободного физического движка реального времени Эрвина Куманса Bullet"
date: 
---


### 5.3.2 Пересекающиеся Луч или Сегмент и Сфера

Пусть луч задается формулой $R (t)=P + t \textbf d, t ≥ 0$, где P - начало луча и нормализованный вектор направления $\textbf d$, $\textbf ||d||=1$. Если $R(t)$ описывает сегмент, а не луч, то $0 ≤ t ≤ t_{max}$. Пусть граница сферы определяется как $(X - C) · (X - C)=r^2$, где $C$ - центр сферы, а $r$ - ее радиус. Чтобы найти значение $t$, при котором луч пересекает поверхность сферы, $R (t)$ подставляется вместо $X$, давая

$$(P + t \textbf d − C) · (P + t \textbf d − C) = r^2 .$$

Пусть $\textbf m = P − C$, тогда:

- $(\textbf m + t \textbf d) · (\textbf m + t \textbf d) = r^2$ ⇔ (замена $\textbf m = P − C$)
- $(\textbf d · \textbf d)t^2 + 2(\textbf +m · \textbf d)t + (\textbf m · \textbf m) = r^2$ ⇔ (раскрытие скалярного произведения)
- $t^2 + 2(\textbf m · \textbf d)t + (\textbf m · \textbf m) − r^2 = 0$  (упрощение $\textbf d · \textbf d = 1$; каноническая форма квадратного уравнения)

Это квадратное уравнение в t. Для квадратичной формулы $t^2 + 2bt + c = 0$, решения даются $t = −b ± \sqrt {b^2 − c}$. Здесь, $b = \textbf m · \textbf d$ и $c = (\textbf m · \textbf m) − r^2$ .

**Рисунок 5.21** Различные случаи пересечения луча и сферы: (a) луч пересекает сферу (дважды) при t> 0, (b) ложное пересечение при t <0, (c) луч пересекает сферу по касательной, (d) луч начинается внутри сферы, и (e) нет пересечения.

Решение квадратного уравнения имеет три результата, классифицируемых дискриминантом $d = b^2 − c$. Если $d < 0$, нет реальных корней, что соответствует лучу, никакой частью не пересекающему сферу. Если $d = 0$, существует один действительный (двойной) корень, соответствующий лучу, касающемуся сферы в точке. Если $d > 0$, есть два действительных корня, и луч дважды пересекает сферу: один раз входит и второй раз выходит за пределы сферы. В последнем случае меньшее значение t пересечения является релевантным $t = −b − \sqrt {b^2 − c}$. Однако важно различать случай ложного пересечения луча, начинающегося вне сферы и направленного от нее, что приводит к значению пересечения $t < 0$. Этот случай проиллюстрирован на рисунке 5.21 вместе со всеми другими пересечениями луча и сферы. отношения. Следующий код реализует тест пересечения лучей и сфер.

```cpp
// Пересекает луч r = p + td, |d| = 1, со сферой s и, если они пересекаются ,
// возвращает t значение пересечения и точки пересечения q
int IntersectRaySphere(Point p, Vector d, Sphere s, float &t, Point &q){
    Vector m = p - s.c;
    float b = Dot(m, d);
    float c = Dot(m, m) - s.r * s.r;
    // Выйти, если начало r находится за пределами s (c > 0) и r направлено в противоположную сторону s (b > 0)
    if (c > 0.0f && b > 0.0f) return 0;
    float discr = b*b - c;
    // Отрицательный дискриминант соответствует отсутствия луча в сфере
    if (discr < 0.0f) return 0;
    // Теперь обнаружено, что Рэй пересекает сферу, вычисляется наименьшее значение t пересечения
    t = -b - Sqrt(discr);
    // Если t отрицательно, луч начинается внутри сферы, поэтому зафиксируйте t равным нулю
    if (t < 0.0f) t = 0.0f;
    q = p + t * d;
    return 1;
}
```

Для пересечения ориентированного отрезка AB со сферой можно использовать тот же код, задав $P = A$ и $\textbf d = (B − A) ||B − A||$. На перекрестке важно это проверить $t ≤ ||B − A||$ так, чтобы обнаруженное пересечение не выходило за пределы конца отрезка. Чтобы просто проверить, пересекает ли луч сферу (но не когда и где), код можно оптимизировать, чтобы не выполнять потенциально дорогостоящую операцию извлечения квадратного корня.

Сделав ранний выход как можно скорее, код будет выглядеть следующим образом :

```cpp
// Проверить, пересекает ли луч r = p + td сферу s
int TestRaySphere(Point p, Vector d, Sphere s){
    Vector m = p - s.c;
    float c = Dot(m, m) - s.r * s.r;
    // Если определенно существует хотя бы один реальный корень, должно быть пересечение
    if (c <= 0.0f) return 1;
    float b = Dot(m, d);
    // Ранний выход, если луч выходит за пределы сферы и луч направлен от сферы
    if (b > 0.0f) return 0;
    float disc = b*b - c;
    // Отрицательный дискриминант соответствует отсутствия луча в сфере
    if (disc < 0.0f) return 0;
    // Теперь луч должен попасть в сферу
    return 1;
}
```

Если d не нормализовано, решаемое квадратное уравнение принимает вид 
$$(\textbf d · \textbf d)t^2 + 2(\textbf m · \textbf d)t + (\textbf m · \textbf m) − r^2 = 0. $$
Для квадратного уравнения, такого как это, вида $at^2 + 2bt + c = 0$, решения даются

$$t = \frac {-b ± \sqrt {b^2 - ac}}{a} $$

с дискриминантом d = b2 − ac.

### 5.3.3 Пересекающиеся Луч или Сегмент и Параллелипипед

Вспоминая определение плиты как пространства между парой параллельных плоскостей, объем прямоугольного параллелипипеда можно рассматривать как пересечение трех таких плит под прямым углом друг к другу. Так же, как точка находится внутри параллелипипеда тогда и только тогда, когда она лежит внутри всех трех плит, сегмент пересекает параллелипипед тогда и только тогда, когда пересечения между сегментом и плитами перекрываются. Если пересечения сегмента с плитами не перекрываются, сегмент не может находиться внутри плит одновременно и, следовательно, не может пересекать объем, образованный пересечением плит. Тот же принцип применим и к пересечению луча или линии с параллелипипедом. Пересечение и непересечение луча с двухмерным параллелипипедом, образованным как пересечение x-плиты и y-плиты, показано на рисунке 5.22.

**Рисунок 5.22**. Луч R1 не пересекает параллелипипед, потому что его пересечения с перекрытием x и перекрытием y не перекрываются. Луч R2 действительно пересекает прямоугольник, потому что пересечения перекрытий перекрываются.

Поэтому для проверки пересечения луча с параллелипипедом необходимо только вычислить интервалы пересечения луча с плоскостями плит и выполнить несколько простых операций сравнения для поддержания логического пересечения всех интервалов пересечения вдоль луча. Все, что требуется, - это отслеживать самый дальний из всех входов в плиту и ближайший из всех выходов из плиты. Если самый дальний вход когда-либо становится дальше, чем ближайший выход, луч не может пересекать объем пересечения плиты, и тест может выйти раньше (в результате непересечения).

Интервалы пересечения луча с плитами получаются путем вставки параметрического уравнения луча $R(t) = P + t \textbf d$, в плоские уравнения плоскостей плиты, $X · \textbf n_i = d_i$ , и решая для t, давая $t = (d − P · \textbf n_i )/(\textbf d · \textbf n_i )$. Для AABB две компоненты нормали равны нулю и, следовательно, даны $P = (p_x , p_y , p_z )$ и $d = (d_x , d_y , d_z )$
выражение упрощается, например, до, $t = (d − p_x )/d_x$ для плоскости, перпендикулярной оси x, где d просто соответствует положению плоскости вдоль оси x. Чтобы избежать деления на ноль, когда луч параллелен плите, этот случай лучше всего обрабатывать отдельно, заменяя тест на то, что начало луча содержится в плите. Следующий код является реализацией теста луча против AABB.

```cpp
// Луч пересечения R(t) = p + t*d против AABB a. При пересечении
// возвращает расстояние пересечения tmin и точку пересечения q
int IntersectRayAABB(Point p, Vector d, AABB a, float &tmin, Point &q){
    tmin = 0.0f; // установите -FLT_MAX, чтобы получить первое попадание в линию
    float tmax = FLT_MAX; // установлен на максимальное расстояние, которое может пройти луч (для сегмента)
    // Для всех трех плит
    for (int i = 0; i < 3; i++) {
        if (Abs(d[i]) < EPSILON) {
            // Луч параллелен плите. Нет попадания, если исходная точка не в пределах плиты
            if (p[i] < a.min[i] || p[i] > a.max[i]) return 0;
        } else {
            // Вычислить значение t пересечения луча с ближней и дальней плоскостями плиты
            float ood = 1.0f / d[i];
            float t1 = (a.min[i] - p[i]) * ood;
            float t2 = (a.max[i] - p[i]) * ood;
            // Сделать t1 пересечением с ближней плоскостью, t2 с дальней плоскостью
            if (t1 > t2) Swap(t1, t2);
            // Вычислить пересечение интервалов пересечения перекрытий
            if (t1 > tmin) tmin = t1;
            if (t2 > tmax) tmax = t2;
            // Выйти без столкновения, как только пересечение перекрытий станет пустым
            if (tmin > tmax) return 0;
        }
    }
    // Луч пересекает все 3 плиты. Точка возврата (q) и значение t пересечения (tmin)
    q = p + d * tmin;
    return 1;
}
```

Если один и тот же луч пересекается с большим количеством блоков, три задействованных деления могут быть предварительно вычислены один раз для луча, а затем повторно использованы для всех тестов. В качестве дальнейшей оптимизации результат утверждения **if (t1 > t2) Swap(t1, t2)**
также полностью определяется знаками компонент вектора направления луча. Поэтому его можно было бы удалить, определив заранее, какую из восьми (или четырех для двухмерного теста) альтернативных подпрограмм вызвать, в которых эффекты операторов if были включены в окружающий код.

Обратите внимание, что представленный тест на пересечение луча и параллелипипеда является частным случаем теста пересечения луча с объемом плиты Кая – Каджиа, описанным в Разделе 4.6.1. Увеличение количества плит позволяет добиться сколь угодно хорошей подгонки выпуклой оболочки объектов. Тест Кея – Каджи, в свою очередь, на самом деле является лишь специализацией алгоритма отсечения Сайруса – Бека [Cyrus78]. Подход Сайруса – Бека с отсечением также используется в разделе 5.3.8 для пересечения луча или сегмента с выпуклым многогранником.

Если проблема состоит в том, чтобы просто проверить, пересекается ли сегмент с прямоугольником, без определения точки пересечения, альтернативным решением является использование теста разделяющей оси. Без потери общности можно выбрать систему координат, в которой прямоугольник центрируется в начале координат и ориентирован вместе с осями координат. Для AABB центрирование выполняется путем перевода сегмента вместе с AABB в начало координат. Для OBB конечные точки сегмента могут быть преобразованы из мирового пространства в OBB-пространство, после чего оба могут быть переведены в исходную точку таким же образом, как и для AABB. Предполагая, что OBB задается центральной точкой C; вектор экстента половинной ширины $e = (e_0 , e_1 , e_2 )$; и локальные оси координат $\textbf u_0$ , $\textbf u_1$ , и $\textbf u_2$ ; тогда точка P в мировом пространстве может быть выражена в системе координат OBB как точка (x, y, z), где
$x = (P − C) · \textbf u_0$ , $y = (P − C) · \textbf u_1$ , и $z = (P − C) · \textbf u_2$ .

### 5.3.4 Пересекающиеся Линия и Треугольник
### 5.3.5 Пересекающиеся Линия и Четырехугольник
### 5.3.6 Пересекающиеся Луч или Сегмент и Треугольник
### 5.3.7 Пересекающиеся Луч или Сегмент и Цилиндр
### 5.3.8 Пересекающиеся Луч или Сегмент и Выпуклый многогранник
## 5.4 Дополнительные тесты
### 5.4.1 Тестирование Точки в многоугольнике
### 5.4.2 Тестирование Точки в Треугольнике
### 5.4.3 Тестирование Точки в Многограннике
### 5.4.4 Пересечение двух Плоскостей
### 5.4.5 Пересечение трех Плоскостей
## 5.5 Тест динамических пересечений
### 5.5.1 Уменьшение вдвое интервала пересечения движущихся объектов
### 5.5.2 Тест разделяющей оси для движущихся выпуклых объектов
### 5.5.3 Пересечение движущейся Сферы относительно Плоскости
### 5.5.4 Пересечение движущихся AABB относительно Плоскости
### 5.5.5 Пересечение движущейся Сферы относительно Сферы
### 5.5.6 Пересечение движущейся сферы относительно треугольника (и многоугольника)
